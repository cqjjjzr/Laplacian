package org.ffmpeg.avdevice57;
import com.ochafik.lang.jnaerator.runtime.NativeSize;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.PointerByReference;
import org.ffmpeg.avformat57.AVFormatContext;
import org.ffmpeg.avformat57.AVInputFormat;
import org.ffmpeg.avformat57.AVOutputFormat;
import org.ffmpeg.avutil55.AVDictionary;
/**
 * JNA Wrapper for library <b>avdevice-57</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Avdevice57Library extends Library {
	public static final String JNA_LIBRARY_NAME = "avdevice-57";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(Avdevice57Library.JNA_LIBRARY_NAME);
	public static final Avdevice57Library INSTANCE = (Avdevice57Library)Native.loadLibrary(Avdevice57Library.JNA_LIBRARY_NAME, Avdevice57Library.class);
	/**
	 * Message types used by avdevice_app_to_dev_control_message().<br>
	 * <i>native declaration : libavdevice\avdevice.h:72</i><br>
	 * enum values
	 */
	public static interface AVAppToDevMessageType {
		/** <i>native declaration : libavdevice\avdevice.h:60</i> */
		public static final int AV_APP_TO_DEV_NONE = (('E') | (('N') << 8) | (('O') << 16) | (('N') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:61</i> */
		public static final int AV_APP_TO_DEV_WINDOW_SIZE = (('M') | (('O') << 8) | (('E') << 16) | (('G') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:62</i> */
		public static final int AV_APP_TO_DEV_WINDOW_REPAINT = (('A') | (('P') << 8) | (('E') << 16) | (('R') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:63</i> */
		public static final int AV_APP_TO_DEV_PAUSE = ((' ') | (('U') << 8) | (('A') << 16) | (('P') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:64</i> */
		public static final int AV_APP_TO_DEV_PLAY = (('Y') | (('A') << 8) | (('L') << 16) | (('P') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:65</i> */
		public static final int AV_APP_TO_DEV_TOGGLE_PAUSE = (('T') | (('U') << 8) | (('A') << 16) | (('P') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:66</i> */
		public static final int AV_APP_TO_DEV_SET_VOLUME = (('L') | (('O') << 8) | (('V') << 16) | (('S') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:67</i> */
		public static final int AV_APP_TO_DEV_MUTE = (('T') | (('U') << 8) | (('M') << 16) | ((' ') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:68</i> */
		public static final int AV_APP_TO_DEV_UNMUTE = (('T') | (('U') << 8) | (('M') << 16) | (('U') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:69</i> */
		public static final int AV_APP_TO_DEV_TOGGLE_MUTE = (('T') | (('U') << 8) | (('M') << 16) | (('T') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:70</i> */
		public static final int AV_APP_TO_DEV_GET_VOLUME = (('L') | (('O') << 8) | (('V') << 16) | (('G') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:71</i> */
		public static final int AV_APP_TO_DEV_GET_MUTE = (('T') | (('U') << 8) | (('M') << 16) | (('G') << 24));
	};
	/**
	 * Message types used by avdevice_dev_to_app_control_message().<br>
	 * <i>native declaration : libavdevice\avdevice.h:86</i><br>
	 * enum values
	 */
	public static interface AVDevToAppMessageType {
		/** <i>native declaration : libavdevice\avdevice.h:75</i> */
		public static final int AV_DEV_TO_APP_NONE = (('E') | (('N') << 8) | (('O') << 16) | (('N') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:76</i> */
		public static final int AV_DEV_TO_APP_CREATE_WINDOW_BUFFER = (('E') | (('R') << 8) | (('C') << 16) | (('B') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:77</i> */
		public static final int AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER = (('E') | (('R') << 8) | (('P') << 16) | (('B') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:78</i> */
		public static final int AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER = (('S') | (('I') << 8) | (('D') << 16) | (('B') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:79</i> */
		public static final int AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER = (('S') | (('E') << 8) | (('D') << 16) | (('B') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:80</i> */
		public static final int AV_DEV_TO_APP_BUFFER_OVERFLOW = (('L') | (('F') << 8) | (('O') << 16) | (('B') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:81</i> */
		public static final int AV_DEV_TO_APP_BUFFER_UNDERFLOW = (('L') | (('F') << 8) | (('U') << 16) | (('B') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:82</i> */
		public static final int AV_DEV_TO_APP_BUFFER_READABLE = ((' ') | (('D') << 8) | (('R') << 16) | (('B') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:83</i> */
		public static final int AV_DEV_TO_APP_BUFFER_WRITABLE = ((' ') | (('R') << 8) | (('W') << 16) | (('B') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:84</i> */
		public static final int AV_DEV_TO_APP_MUTE_STATE_CHANGED = (('T') | (('U') << 8) | (('M') << 16) | (('C') << 24));
		/** <i>native declaration : libavdevice\avdevice.h:85</i> */
		public static final int AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED = (('L') | (('O') << 8) | (('V') << 16) | (('C') << 24));
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil\rational.h:0</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : libavdevice\version.h</i> */
	public static final int LIBAVDEVICE_VERSION_MAJOR = (int)57;
	/** <i>native declaration : libavdevice\version.h</i> */
	public static final int LIBAVDEVICE_VERSION_MINOR = (int)6;
	/** <i>native declaration : libavdevice\version.h</i> */
	public static final int LIBAVDEVICE_VERSION_MICRO = (int)100;
	/** <i>native declaration : libavdevice\version.h</i> */
	public static final int LIBAVDEVICE_VERSION_INT = (int)((57) << 16 | (6) << 8 | (100));
	/**
	 * define<br>
	 * Conversion Error : 57.6.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavdevice\version.h:0</i><br>
	 * 57.6.
	 */
	/** <i>native declaration : libavdevice\version.h</i> */
	public static final int LIBAVDEVICE_BUILD = (int)((57) << 16 | (6) << 8 | (100));
	/** <i>native declaration : libavdevice\version.h</i> */
	public static final String LIBAVDEVICE_IDENT = (String)"Lavd57.6.100";
	/**
	 * Return the LIBAVDEVICE_VERSION_INT constant.<br>
	 * Original signature : <code>int avdevice_version()</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:4</i>
	 */
	int avdevice_version();
	/**
	 * Return the libavdevice build-time configuration.<br>
	 * Original signature : <code>char* avdevice_configuration()</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:9</i>
	 */
	String avdevice_configuration();
	/**
	 * Return the libavdevice license.<br>
	 * Original signature : <code>char* avdevice_license()</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:14</i>
	 */
	String avdevice_license();
	/**
	 * Initialize libavdevice and register all the input and output devices.<br>
	 * Original signature : <code>void avdevice_register_all()</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:19</i>
	 */
	void avdevice_register_all();
	/**
	 * Audio input devices iterator.<br>
	 * If d is NULL, returns the first registered input audio/video device,<br>
	 * if d is non-NULL, returns the next registered input audio/video device after d<br>
	 * or NULL if d is the last one.<br>
	 * Original signature : <code>AVInputFormat* av_input_audio_device_next(AVInputFormat*)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:27</i>
	 */
	AVInputFormat av_input_audio_device_next(AVInputFormat d);
	/**
	 * Video input devices iterator.<br>
	 * If d is NULL, returns the first registered input audio/video device,<br>
	 * if d is non-NULL, returns the next registered input audio/video device after d<br>
	 * or NULL if d is the last one.<br>
	 * Original signature : <code>AVInputFormat* av_input_video_device_next(AVInputFormat*)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:35</i>
	 */
	AVInputFormat av_input_video_device_next(AVInputFormat d);
	/**
	 * Audio output devices iterator.<br>
	 * If d is NULL, returns the first registered output audio/video device,<br>
	 * if d is non-NULL, returns the next registered output audio/video device after d<br>
	 * or NULL if d is the last one.<br>
	 * Original signature : <code>AVOutputFormat* av_output_audio_device_next(AVOutputFormat*)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:43</i>
	 */
	AVOutputFormat av_output_audio_device_next(AVOutputFormat d);
	/**
	 * Video output devices iterator.<br>
	 * If d is NULL, returns the first registered output audio/video device,<br>
	 * if d is non-NULL, returns the next registered output audio/video device after d<br>
	 * or NULL if d is the last one.<br>
	 * Original signature : <code>AVOutputFormat* av_output_video_device_next(AVOutputFormat*)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:51</i>
	 */
	AVOutputFormat av_output_video_device_next(AVOutputFormat d);
	/**
	 * Send control message from application to device.<br>
	 * @param s         device context.<br>
	 * @param type      message type.<br>
	 * @param data      message data. Exact type depends on message type.<br>
	 * @param data_size size of message data.<br>
	 * @return >= 0 on success, negative on error.<br>
	 *         AVERROR(ENOSYS) when device doesn't implement handler of the message.<br>
	 * Original signature : <code>int avdevice_app_to_dev_control_message(AVFormatContext*, AVAppToDevMessageType, void*, size_t)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:97</i>
	 */
	int avdevice_app_to_dev_control_message(AVFormatContext s, int type, Pointer data, NativeSize data_size);
	/**
	 * Send control message from device to application.<br>
	 * @param s         device context.<br>
	 * @param type      message type.<br>
	 * @param data      message data. Can be NULL.<br>
	 * @param data_size size of message data.<br>
	 * @return >= 0 on success, negative on error.<br>
	 *         AVERROR(ENOSYS) when application doesn't implement handler of the message.<br>
	 * Original signature : <code>int avdevice_dev_to_app_control_message(AVFormatContext*, AVDevToAppMessageType, void*, size_t)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:108</i>
	 */
	int avdevice_dev_to_app_control_message(AVFormatContext s, int type, Pointer data, NativeSize data_size);
	/**
	 * Initialize capabilities probing API based on AVOption API.<br>
	 * avdevice_capabilities_free() must be called when query capabilities API is<br>
	 * not used anymore.<br>
	 * @param[out] caps      Device capabilities data. Pointer to a NULL pointer must be passed.<br>
	 * @param s              Context of the device.<br>
	 * @param device_options An AVDictionary filled with device-private options.<br>
	 *                       On return this parameter will be destroyed and replaced with a dict<br>
	 *                       containing options that were not found. May be NULL.<br>
	 *                       The same options must be passed later to avformat_write_header() for output<br>
	 *                       devices or avformat_open_input() for input devices, or at any other place<br>
	 *                       that affects device-private options.<br>
	 * @return >= 0 on success, negative otherwise.<br>
	 * Original signature : <code>int avdevice_capabilities_create(AVDeviceCapabilitiesQuery**, AVFormatContext*, AVDictionary**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:152</i><br>
	 * @deprecated use the safer method {@link #avdevice_capabilities_create(org.ffmpeg.avdevice57.AVDeviceCapabilitiesQuery.ByReference[], org.ffmpeg.avformat57.AVFormatContext, org.ffmpeg.avutil55.AVDictionary.ByReference[])} instead
	 */
	@Deprecated 
	int avdevice_capabilities_create(PointerByReference caps, AVFormatContext s, PointerByReference device_options);
	/**
	 * Initialize capabilities probing API based on AVOption API.<br>
	 * avdevice_capabilities_free() must be called when query capabilities API is<br>
	 * not used anymore.<br>
	 * @param[out] caps      Device capabilities data. Pointer to a NULL pointer must be passed.<br>
	 * @param s              Context of the device.<br>
	 * @param device_options An AVDictionary filled with device-private options.<br>
	 *                       On return this parameter will be destroyed and replaced with a dict<br>
	 *                       containing options that were not found. May be NULL.<br>
	 *                       The same options must be passed later to avformat_write_header() for output<br>
	 *                       devices or avformat_open_input() for input devices, or at any other place<br>
	 *                       that affects device-private options.<br>
	 * @return >= 0 on success, negative otherwise.<br>
	 * Original signature : <code>int avdevice_capabilities_create(AVDeviceCapabilitiesQuery**, AVFormatContext*, AVDictionary**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:152</i>
	 */
	int avdevice_capabilities_create(org.ffmpeg.avdevice57.AVDeviceCapabilitiesQuery.ByReference caps[], AVFormatContext s, AVDictionary.ByReference device_options[]);
	/**
	 * Free resources created by avdevice_capabilities_create()<br>
	 * @param caps Device capabilities data to be freed.<br>
	 * @param s    Context of the device.<br>
	 * Original signature : <code>void avdevice_capabilities_free(AVDeviceCapabilitiesQuery**, AVFormatContext*)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:159</i><br>
	 * @deprecated use the safer method {@link #avdevice_capabilities_free(org.ffmpeg.avdevice57.AVDeviceCapabilitiesQuery.ByReference[], org.ffmpeg.avformat57.AVFormatContext)} instead
	 */
	@Deprecated 
	void avdevice_capabilities_free(PointerByReference caps, AVFormatContext s);
	/**
	 * Free resources created by avdevice_capabilities_create()<br>
	 * @param caps Device capabilities data to be freed.<br>
	 * @param s    Context of the device.<br>
	 * Original signature : <code>void avdevice_capabilities_free(AVDeviceCapabilitiesQuery**, AVFormatContext*)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:159</i>
	 */
	void avdevice_capabilities_free(org.ffmpeg.avdevice57.AVDeviceCapabilitiesQuery.ByReference caps[], AVFormatContext s);
	/**
	 * List devices.<br>
	 * Returns available device names and their parameters.<br>
	 * @note: Some devices may accept system-dependent device names that cannot be<br>
	 *        autodetected. The list returned by this function cannot be assumed to<br>
	 *        be always completed.<br>
	 * @param s                device context.<br>
	 * @param[out] device_list list of autodetected devices.<br>
	 * @return count of autodetected devices, negative on error.<br>
	 * Original signature : <code>int avdevice_list_devices(AVFormatContext*, AVDeviceInfoList**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:182</i><br>
	 * @deprecated use the safer method {@link #avdevice_list_devices(org.ffmpeg.avformat57.AVFormatContext, org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference[])} instead
	 */
	@Deprecated 
	int avdevice_list_devices(AVFormatContext s, PointerByReference device_list);
	/**
	 * List devices.<br>
	 * Returns available device names and their parameters.<br>
	 * @note: Some devices may accept system-dependent device names that cannot be<br>
	 *        autodetected. The list returned by this function cannot be assumed to<br>
	 *        be always completed.<br>
	 * @param s                device context.<br>
	 * @param[out] device_list list of autodetected devices.<br>
	 * @return count of autodetected devices, negative on error.<br>
	 * Original signature : <code>int avdevice_list_devices(AVFormatContext*, AVDeviceInfoList**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:182</i>
	 */
	int avdevice_list_devices(AVFormatContext s, org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference device_list[]);
	/**
	 * Convenient function to free result of avdevice_list_devices().<br>
	 * @param devices device list to be freed.<br>
	 * Original signature : <code>void avdevice_free_list_devices(AVDeviceInfoList**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:188</i><br>
	 * @deprecated use the safer method {@link #avdevice_free_list_devices(org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference[])} instead
	 */
	@Deprecated 
	void avdevice_free_list_devices(PointerByReference device_list);
	/**
	 * Convenient function to free result of avdevice_list_devices().<br>
	 * @param devices device list to be freed.<br>
	 * Original signature : <code>void avdevice_free_list_devices(AVDeviceInfoList**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:188</i>
	 */
	void avdevice_free_list_devices(org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference device_list[]);
	/**
	 * List devices.<br>
	 * Returns available device names and their parameters.<br>
	 * These are convinient wrappers for avdevice_list_devices().<br>
	 * Device context is allocated and deallocated internally.<br>
	 * @param device           device format. May be NULL if device name is set.<br>
	 * @param device_name      device name. May be NULL if device format is set.<br>
	 * @param device_options   An AVDictionary filled with device-private options. May be NULL.<br>
	 *                         The same options must be passed later to avformat_write_header() for output<br>
	 *                         devices or avformat_open_input() for input devices, or at any other place<br>
	 *                         that affects device-private options.<br>
	 * @param[out] device_list list of autodetected devices<br>
	 * @return count of autodetected devices, negative on error.<br>
	 * @note device argument takes precedence over device_name when both are set.<br>
	 * Original signature : <code>int avdevice_list_input_sources(AVInputFormat*, const char*, AVDictionary*, AVDeviceInfoList**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:205</i><br>
	 * @deprecated use the safer methods {@link #avdevice_list_input_sources(org.ffmpeg.avformat57.AVInputFormat, String, org.ffmpeg.avutil55.AVDictionary, org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference[])} and {@link #avdevice_list_input_sources(org.ffmpeg.avformat57.AVInputFormat, Pointer, org.ffmpeg.avutil55.AVDictionary, org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference[])} instead
	 */
	@Deprecated 
	int avdevice_list_input_sources(AVInputFormat device, Pointer device_name, AVDictionary device_options, PointerByReference device_list);
	/**
	 * List devices.<br>
	 * Returns available device names and their parameters.<br>
	 * These are convinient wrappers for avdevice_list_devices().<br>
	 * Device context is allocated and deallocated internally.<br>
	 * @param device           device format. May be NULL if device name is set.<br>
	 * @param device_name      device name. May be NULL if device format is set.<br>
	 * @param device_options   An AVDictionary filled with device-private options. May be NULL.<br>
	 *                         The same options must be passed later to avformat_write_header() for output<br>
	 *                         devices or avformat_open_input() for input devices, or at any other place<br>
	 *                         that affects device-private options.<br>
	 * @param[out] device_list list of autodetected devices<br>
	 * @return count of autodetected devices, negative on error.<br>
	 * @note device argument takes precedence over device_name when both are set.<br>
	 * Original signature : <code>int avdevice_list_input_sources(AVInputFormat*, const char*, AVDictionary*, AVDeviceInfoList**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:205</i>
	 */
	int avdevice_list_input_sources(AVInputFormat device, String device_name, AVDictionary device_options, org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference device_list[]);
	/**
	 * List devices.<br>
	 * Returns available device names and their parameters.<br>
	 * These are convinient wrappers for avdevice_list_devices().<br>
	 * Device context is allocated and deallocated internally.<br>
	 * @param device           device format. May be NULL if device name is set.<br>
	 * @param device_name      device name. May be NULL if device format is set.<br>
	 * @param device_options   An AVDictionary filled with device-private options. May be NULL.<br>
	 *                         The same options must be passed later to avformat_write_header() for output<br>
	 *                         devices or avformat_open_input() for input devices, or at any other place<br>
	 *                         that affects device-private options.<br>
	 * @param[out] device_list list of autodetected devices<br>
	 * @return count of autodetected devices, negative on error.<br>
	 * @note device argument takes precedence over device_name when both are set.<br>
	 * Original signature : <code>int avdevice_list_input_sources(AVInputFormat*, const char*, AVDictionary*, AVDeviceInfoList**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:205</i>
	 */
	int avdevice_list_input_sources(AVInputFormat device, Pointer device_name, AVDictionary device_options, org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference device_list[]);
	/**
	 * Original signature : <code>int avdevice_list_output_sinks(AVOutputFormat*, const char*, AVDictionary*, AVDeviceInfoList**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:207</i><br>
	 * @deprecated use the safer methods {@link #avdevice_list_output_sinks(org.ffmpeg.avformat57.AVOutputFormat, String, org.ffmpeg.avutil55.AVDictionary, org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference[])} and {@link #avdevice_list_output_sinks(org.ffmpeg.avformat57.AVOutputFormat, Pointer, org.ffmpeg.avutil55.AVDictionary, org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference[])} instead
	 */
	@Deprecated 
	int avdevice_list_output_sinks(AVOutputFormat device, Pointer device_name, AVDictionary device_options, PointerByReference device_list);
	/**
	 * Original signature : <code>int avdevice_list_output_sinks(AVOutputFormat*, const char*, AVDictionary*, AVDeviceInfoList**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:207</i>
	 */
	int avdevice_list_output_sinks(AVOutputFormat device, String device_name, AVDictionary device_options, org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference device_list[]);
	/**
	 * Original signature : <code>int avdevice_list_output_sinks(AVOutputFormat*, const char*, AVDictionary*, AVDeviceInfoList**)</code><br>
	 * <i>native declaration : libavdevice\avdevice.h:207</i>
	 */
	int avdevice_list_output_sinks(AVOutputFormat device, Pointer device_name, AVDictionary device_options, org.ffmpeg.avdevice57.AVDeviceInfoList.ByReference device_list[]);
}
