package org.ffmpeg.avcodec57;
import com.ochafik.lang.jnaerator.runtime.NativeSize;
import com.ochafik.lang.jnaerator.runtime.NativeSizeByReference;
import com.sun.jna.*;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.ptr.ShortByReference;
import org.ffmpeg.avutil55.AVDictionary;
import org.ffmpeg.avutil55.AVFrame;
import org.ffmpeg.avutil55.AVRational.ByValue;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
/**
 * JNA Wrapper for library <b>avcodec-57</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Avcodec57Library extends Library {
	public static final String JNA_LIBRARY_NAME = "avcodec-57";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(Avcodec57Library.JNA_LIBRARY_NAME);
	public static final Avcodec57Library INSTANCE = (Avcodec57Library)Native.loadLibrary(Avcodec57Library.JNA_LIBRARY_NAME, Avcodec57Library.class);
	/**
	 * Identify the syntax and semantics of the bitstream.<br>
	 * The principle is roughly:<br>
	 * Two decoders with the same ID can decode the same streams.<br>
	 * Two encoders with the same ID can encode compatible streams.<br>
	 * There may be slight deviations from the principle due to implementation<br>
	 * details.<br>
	 * If you add a codec ID to this list, add it so that<br>
	 * 1. no value of an existing codec ID changes (that would break ABI),<br>
	 * 2. it is as close as possible to similar codecs<br>
	 * After adding new codec IDs, do not forget to add an entry to the codec<br>
	 * descriptor list and bump libavcodec minor version.<br>
	 * <i>native declaration : .\libavcodec\avcodec.h:462</i><br>
	 * enum values
	 */
	public static interface AVCodecID {
		/** <i>native declaration : .\libavcodec\avcodec.h:14</i> */
		public static final int AV_CODEC_ID_NONE = 0;
		/** <i>native declaration : .\libavcodec\avcodec.h:15</i> */
		public static final int AV_CODEC_ID_MPEG1VIDEO = 1;
		/**
		 * < preferred ID for MPEG-1/2 video decoding<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:17</i>
		 */
		public static final int AV_CODEC_ID_MPEG2VIDEO = 2;
		/** <i>native declaration : .\libavcodec\avcodec.h:18</i> */
		public static final int AV_CODEC_ID_MPEG2VIDEO_XVMC = 3;
		/** <i>native declaration : .\libavcodec\avcodec.h:19</i> */
		public static final int AV_CODEC_ID_H261 = 4;
		/** <i>native declaration : .\libavcodec\avcodec.h:20</i> */
		public static final int AV_CODEC_ID_H263 = 5;
		/** <i>native declaration : .\libavcodec\avcodec.h:21</i> */
		public static final int AV_CODEC_ID_RV10 = 6;
		/** <i>native declaration : .\libavcodec\avcodec.h:22</i> */
		public static final int AV_CODEC_ID_RV20 = 7;
		/** <i>native declaration : .\libavcodec\avcodec.h:23</i> */
		public static final int AV_CODEC_ID_MJPEG = 8;
		/** <i>native declaration : .\libavcodec\avcodec.h:24</i> */
		public static final int AV_CODEC_ID_MJPEGB = 9;
		/** <i>native declaration : .\libavcodec\avcodec.h:25</i> */
		public static final int AV_CODEC_ID_LJPEG = 10;
		/** <i>native declaration : .\libavcodec\avcodec.h:26</i> */
		public static final int AV_CODEC_ID_SP5X = 11;
		/** <i>native declaration : .\libavcodec\avcodec.h:27</i> */
		public static final int AV_CODEC_ID_JPEGLS = 12;
		/** <i>native declaration : .\libavcodec\avcodec.h:28</i> */
		public static final int AV_CODEC_ID_MPEG4 = 13;
		/** <i>native declaration : .\libavcodec\avcodec.h:29</i> */
		public static final int AV_CODEC_ID_RAWVIDEO = 14;
		/** <i>native declaration : .\libavcodec\avcodec.h:30</i> */
		public static final int AV_CODEC_ID_MSMPEG4V1 = 15;
		/** <i>native declaration : .\libavcodec\avcodec.h:31</i> */
		public static final int AV_CODEC_ID_MSMPEG4V2 = 16;
		/** <i>native declaration : .\libavcodec\avcodec.h:32</i> */
		public static final int AV_CODEC_ID_MSMPEG4V3 = 17;
		/** <i>native declaration : .\libavcodec\avcodec.h:33</i> */
		public static final int AV_CODEC_ID_WMV1 = 18;
		/** <i>native declaration : .\libavcodec\avcodec.h:34</i> */
		public static final int AV_CODEC_ID_WMV2 = 19;
		/** <i>native declaration : .\libavcodec\avcodec.h:35</i> */
		public static final int AV_CODEC_ID_H263P = 20;
		/** <i>native declaration : .\libavcodec\avcodec.h:36</i> */
		public static final int AV_CODEC_ID_H263I = 21;
		/** <i>native declaration : .\libavcodec\avcodec.h:37</i> */
		public static final int AV_CODEC_ID_FLV1 = 22;
		/** <i>native declaration : .\libavcodec\avcodec.h:38</i> */
		public static final int AV_CODEC_ID_SVQ1 = 23;
		/** <i>native declaration : .\libavcodec\avcodec.h:39</i> */
		public static final int AV_CODEC_ID_SVQ3 = 24;
		/** <i>native declaration : .\libavcodec\avcodec.h:40</i> */
		public static final int AV_CODEC_ID_DVVIDEO = 25;
		/** <i>native declaration : .\libavcodec\avcodec.h:41</i> */
		public static final int AV_CODEC_ID_HUFFYUV = 26;
		/** <i>native declaration : .\libavcodec\avcodec.h:42</i> */
		public static final int AV_CODEC_ID_CYUV = 27;
		/** <i>native declaration : .\libavcodec\avcodec.h:43</i> */
		public static final int AV_CODEC_ID_H264 = 28;
		/** <i>native declaration : .\libavcodec\avcodec.h:44</i> */
		public static final int AV_CODEC_ID_INDEO3 = 29;
		/** <i>native declaration : .\libavcodec\avcodec.h:45</i> */
		public static final int AV_CODEC_ID_VP3 = 30;
		/** <i>native declaration : .\libavcodec\avcodec.h:46</i> */
		public static final int AV_CODEC_ID_THEORA = 31;
		/** <i>native declaration : .\libavcodec\avcodec.h:47</i> */
		public static final int AV_CODEC_ID_ASV1 = 32;
		/** <i>native declaration : .\libavcodec\avcodec.h:48</i> */
		public static final int AV_CODEC_ID_ASV2 = 33;
		/** <i>native declaration : .\libavcodec\avcodec.h:49</i> */
		public static final int AV_CODEC_ID_FFV1 = 34;
		/** <i>native declaration : .\libavcodec\avcodec.h:50</i> */
		public static final int AV_CODEC_ID_4XM = 35;
		/** <i>native declaration : .\libavcodec\avcodec.h:51</i> */
		public static final int AV_CODEC_ID_VCR1 = 36;
		/** <i>native declaration : .\libavcodec\avcodec.h:52</i> */
		public static final int AV_CODEC_ID_CLJR = 37;
		/** <i>native declaration : .\libavcodec\avcodec.h:53</i> */
		public static final int AV_CODEC_ID_MDEC = 38;
		/** <i>native declaration : .\libavcodec\avcodec.h:54</i> */
		public static final int AV_CODEC_ID_ROQ = 39;
		/** <i>native declaration : .\libavcodec\avcodec.h:55</i> */
		public static final int AV_CODEC_ID_INTERPLAY_VIDEO = 40;
		/** <i>native declaration : .\libavcodec\avcodec.h:56</i> */
		public static final int AV_CODEC_ID_XAN_WC3 = 41;
		/** <i>native declaration : .\libavcodec\avcodec.h:57</i> */
		public static final int AV_CODEC_ID_XAN_WC4 = 42;
		/** <i>native declaration : .\libavcodec\avcodec.h:58</i> */
		public static final int AV_CODEC_ID_RPZA = 43;
		/** <i>native declaration : .\libavcodec\avcodec.h:59</i> */
		public static final int AV_CODEC_ID_CINEPAK = 44;
		/** <i>native declaration : .\libavcodec\avcodec.h:60</i> */
		public static final int AV_CODEC_ID_WS_VQA = 45;
		/** <i>native declaration : .\libavcodec\avcodec.h:61</i> */
		public static final int AV_CODEC_ID_MSRLE = 46;
		/** <i>native declaration : .\libavcodec\avcodec.h:62</i> */
		public static final int AV_CODEC_ID_MSVIDEO1 = 47;
		/** <i>native declaration : .\libavcodec\avcodec.h:63</i> */
		public static final int AV_CODEC_ID_IDCIN = 48;
		/** <i>native declaration : .\libavcodec\avcodec.h:64</i> */
		public static final int AV_CODEC_ID_8BPS = 49;
		/** <i>native declaration : .\libavcodec\avcodec.h:65</i> */
		public static final int AV_CODEC_ID_SMC = 50;
		/** <i>native declaration : .\libavcodec\avcodec.h:66</i> */
		public static final int AV_CODEC_ID_FLIC = 51;
		/** <i>native declaration : .\libavcodec\avcodec.h:67</i> */
		public static final int AV_CODEC_ID_TRUEMOTION1 = 52;
		/** <i>native declaration : .\libavcodec\avcodec.h:68</i> */
		public static final int AV_CODEC_ID_VMDVIDEO = 53;
		/** <i>native declaration : .\libavcodec\avcodec.h:69</i> */
		public static final int AV_CODEC_ID_MSZH = 54;
		/** <i>native declaration : .\libavcodec\avcodec.h:70</i> */
		public static final int AV_CODEC_ID_ZLIB = 55;
		/** <i>native declaration : .\libavcodec\avcodec.h:71</i> */
		public static final int AV_CODEC_ID_QTRLE = 56;
		/** <i>native declaration : .\libavcodec\avcodec.h:72</i> */
		public static final int AV_CODEC_ID_TSCC = 57;
		/** <i>native declaration : .\libavcodec\avcodec.h:73</i> */
		public static final int AV_CODEC_ID_ULTI = 58;
		/** <i>native declaration : .\libavcodec\avcodec.h:74</i> */
		public static final int AV_CODEC_ID_QDRAW = 59;
		/** <i>native declaration : .\libavcodec\avcodec.h:75</i> */
		public static final int AV_CODEC_ID_VIXL = 60;
		/** <i>native declaration : .\libavcodec\avcodec.h:76</i> */
		public static final int AV_CODEC_ID_QPEG = 61;
		/** <i>native declaration : .\libavcodec\avcodec.h:77</i> */
		public static final int AV_CODEC_ID_PNG = 62;
		/** <i>native declaration : .\libavcodec\avcodec.h:78</i> */
		public static final int AV_CODEC_ID_PPM = 63;
		/** <i>native declaration : .\libavcodec\avcodec.h:79</i> */
		public static final int AV_CODEC_ID_PBM = 64;
		/** <i>native declaration : .\libavcodec\avcodec.h:80</i> */
		public static final int AV_CODEC_ID_PGM = 65;
		/** <i>native declaration : .\libavcodec\avcodec.h:81</i> */
		public static final int AV_CODEC_ID_PGMYUV = 66;
		/** <i>native declaration : .\libavcodec\avcodec.h:82</i> */
		public static final int AV_CODEC_ID_PAM = 67;
		/** <i>native declaration : .\libavcodec\avcodec.h:83</i> */
		public static final int AV_CODEC_ID_FFVHUFF = 68;
		/** <i>native declaration : .\libavcodec\avcodec.h:84</i> */
		public static final int AV_CODEC_ID_RV30 = 69;
		/** <i>native declaration : .\libavcodec\avcodec.h:85</i> */
		public static final int AV_CODEC_ID_RV40 = 70;
		/** <i>native declaration : .\libavcodec\avcodec.h:86</i> */
		public static final int AV_CODEC_ID_VC1 = 71;
		/** <i>native declaration : .\libavcodec\avcodec.h:87</i> */
		public static final int AV_CODEC_ID_WMV3 = 72;
		/** <i>native declaration : .\libavcodec\avcodec.h:88</i> */
		public static final int AV_CODEC_ID_LOCO = 73;
		/** <i>native declaration : .\libavcodec\avcodec.h:89</i> */
		public static final int AV_CODEC_ID_WNV1 = 74;
		/** <i>native declaration : .\libavcodec\avcodec.h:90</i> */
		public static final int AV_CODEC_ID_AASC = 75;
		/** <i>native declaration : .\libavcodec\avcodec.h:91</i> */
		public static final int AV_CODEC_ID_INDEO2 = 76;
		/** <i>native declaration : .\libavcodec\avcodec.h:92</i> */
		public static final int AV_CODEC_ID_FRAPS = 77;
		/** <i>native declaration : .\libavcodec\avcodec.h:93</i> */
		public static final int AV_CODEC_ID_TRUEMOTION2 = 78;
		/** <i>native declaration : .\libavcodec\avcodec.h:94</i> */
		public static final int AV_CODEC_ID_BMP = 79;
		/** <i>native declaration : .\libavcodec\avcodec.h:95</i> */
		public static final int AV_CODEC_ID_CSCD = 80;
		/** <i>native declaration : .\libavcodec\avcodec.h:96</i> */
		public static final int AV_CODEC_ID_MMVIDEO = 81;
		/** <i>native declaration : .\libavcodec\avcodec.h:97</i> */
		public static final int AV_CODEC_ID_ZMBV = 82;
		/** <i>native declaration : .\libavcodec\avcodec.h:98</i> */
		public static final int AV_CODEC_ID_AVS = 83;
		/** <i>native declaration : .\libavcodec\avcodec.h:99</i> */
		public static final int AV_CODEC_ID_SMACKVIDEO = 84;
		/** <i>native declaration : .\libavcodec\avcodec.h:100</i> */
		public static final int AV_CODEC_ID_NUV = 85;
		/** <i>native declaration : .\libavcodec\avcodec.h:101</i> */
		public static final int AV_CODEC_ID_KMVC = 86;
		/** <i>native declaration : .\libavcodec\avcodec.h:102</i> */
		public static final int AV_CODEC_ID_FLASHSV = 87;
		/** <i>native declaration : .\libavcodec\avcodec.h:103</i> */
		public static final int AV_CODEC_ID_CAVS = 88;
		/** <i>native declaration : .\libavcodec\avcodec.h:104</i> */
		public static final int AV_CODEC_ID_JPEG2000 = 89;
		/** <i>native declaration : .\libavcodec\avcodec.h:105</i> */
		public static final int AV_CODEC_ID_VMNC = 90;
		/** <i>native declaration : .\libavcodec\avcodec.h:106</i> */
		public static final int AV_CODEC_ID_VP5 = 91;
		/** <i>native declaration : .\libavcodec\avcodec.h:107</i> */
		public static final int AV_CODEC_ID_VP6 = 92;
		/** <i>native declaration : .\libavcodec\avcodec.h:108</i> */
		public static final int AV_CODEC_ID_VP6F = 93;
		/** <i>native declaration : .\libavcodec\avcodec.h:109</i> */
		public static final int AV_CODEC_ID_TARGA = 94;
		/** <i>native declaration : .\libavcodec\avcodec.h:110</i> */
		public static final int AV_CODEC_ID_DSICINVIDEO = 95;
		/** <i>native declaration : .\libavcodec\avcodec.h:111</i> */
		public static final int AV_CODEC_ID_TIERTEXSEQVIDEO = 96;
		/** <i>native declaration : .\libavcodec\avcodec.h:112</i> */
		public static final int AV_CODEC_ID_TIFF = 97;
		/** <i>native declaration : .\libavcodec\avcodec.h:113</i> */
		public static final int AV_CODEC_ID_GIF = 98;
		/** <i>native declaration : .\libavcodec\avcodec.h:114</i> */
		public static final int AV_CODEC_ID_DXA = 99;
		/** <i>native declaration : .\libavcodec\avcodec.h:115</i> */
		public static final int AV_CODEC_ID_DNXHD = 100;
		/** <i>native declaration : .\libavcodec\avcodec.h:116</i> */
		public static final int AV_CODEC_ID_THP = 101;
		/** <i>native declaration : .\libavcodec\avcodec.h:117</i> */
		public static final int AV_CODEC_ID_SGI = 102;
		/** <i>native declaration : .\libavcodec\avcodec.h:118</i> */
		public static final int AV_CODEC_ID_C93 = 103;
		/** <i>native declaration : .\libavcodec\avcodec.h:119</i> */
		public static final int AV_CODEC_ID_BETHSOFTVID = 104;
		/** <i>native declaration : .\libavcodec\avcodec.h:120</i> */
		public static final int AV_CODEC_ID_PTX = 105;
		/** <i>native declaration : .\libavcodec\avcodec.h:121</i> */
		public static final int AV_CODEC_ID_TXD = 106;
		/** <i>native declaration : .\libavcodec\avcodec.h:122</i> */
		public static final int AV_CODEC_ID_VP6A = 107;
		/** <i>native declaration : .\libavcodec\avcodec.h:123</i> */
		public static final int AV_CODEC_ID_AMV = 108;
		/** <i>native declaration : .\libavcodec\avcodec.h:124</i> */
		public static final int AV_CODEC_ID_VB = 109;
		/** <i>native declaration : .\libavcodec\avcodec.h:125</i> */
		public static final int AV_CODEC_ID_PCX = 110;
		/** <i>native declaration : .\libavcodec\avcodec.h:126</i> */
		public static final int AV_CODEC_ID_SUNRAST = 111;
		/** <i>native declaration : .\libavcodec\avcodec.h:127</i> */
		public static final int AV_CODEC_ID_INDEO4 = 112;
		/** <i>native declaration : .\libavcodec\avcodec.h:128</i> */
		public static final int AV_CODEC_ID_INDEO5 = 113;
		/** <i>native declaration : .\libavcodec\avcodec.h:129</i> */
		public static final int AV_CODEC_ID_MIMIC = 114;
		/** <i>native declaration : .\libavcodec\avcodec.h:130</i> */
		public static final int AV_CODEC_ID_RL2 = 115;
		/** <i>native declaration : .\libavcodec\avcodec.h:131</i> */
		public static final int AV_CODEC_ID_ESCAPE124 = 116;
		/** <i>native declaration : .\libavcodec\avcodec.h:132</i> */
		public static final int AV_CODEC_ID_DIRAC = 117;
		/** <i>native declaration : .\libavcodec\avcodec.h:133</i> */
		public static final int AV_CODEC_ID_BFI = 118;
		/** <i>native declaration : .\libavcodec\avcodec.h:134</i> */
		public static final int AV_CODEC_ID_CMV = 119;
		/** <i>native declaration : .\libavcodec\avcodec.h:135</i> */
		public static final int AV_CODEC_ID_MOTIONPIXELS = 120;
		/** <i>native declaration : .\libavcodec\avcodec.h:136</i> */
		public static final int AV_CODEC_ID_TGV = 121;
		/** <i>native declaration : .\libavcodec\avcodec.h:137</i> */
		public static final int AV_CODEC_ID_TGQ = 122;
		/** <i>native declaration : .\libavcodec\avcodec.h:138</i> */
		public static final int AV_CODEC_ID_TQI = 123;
		/** <i>native declaration : .\libavcodec\avcodec.h:139</i> */
		public static final int AV_CODEC_ID_AURA = 124;
		/** <i>native declaration : .\libavcodec\avcodec.h:140</i> */
		public static final int AV_CODEC_ID_AURA2 = 125;
		/** <i>native declaration : .\libavcodec\avcodec.h:141</i> */
		public static final int AV_CODEC_ID_V210X = 126;
		/** <i>native declaration : .\libavcodec\avcodec.h:142</i> */
		public static final int AV_CODEC_ID_TMV = 127;
		/** <i>native declaration : .\libavcodec\avcodec.h:143</i> */
		public static final int AV_CODEC_ID_V210 = 128;
		/** <i>native declaration : .\libavcodec\avcodec.h:144</i> */
		public static final int AV_CODEC_ID_DPX = 129;
		/** <i>native declaration : .\libavcodec\avcodec.h:145</i> */
		public static final int AV_CODEC_ID_MAD = 130;
		/** <i>native declaration : .\libavcodec\avcodec.h:146</i> */
		public static final int AV_CODEC_ID_FRWU = 131;
		/** <i>native declaration : .\libavcodec\avcodec.h:147</i> */
		public static final int AV_CODEC_ID_FLASHSV2 = 132;
		/** <i>native declaration : .\libavcodec\avcodec.h:148</i> */
		public static final int AV_CODEC_ID_CDGRAPHICS = 133;
		/** <i>native declaration : .\libavcodec\avcodec.h:149</i> */
		public static final int AV_CODEC_ID_R210 = 134;
		/** <i>native declaration : .\libavcodec\avcodec.h:150</i> */
		public static final int AV_CODEC_ID_ANM = 135;
		/** <i>native declaration : .\libavcodec\avcodec.h:151</i> */
		public static final int AV_CODEC_ID_BINKVIDEO = 136;
		/** <i>native declaration : .\libavcodec\avcodec.h:152</i> */
		public static final int AV_CODEC_ID_IFF_ILBM = 137;
		/** <i>native declaration : .\libavcodec\avcodec.h:153</i> */
		public static final int AV_CODEC_ID_KGV1 = 138;
		/** <i>native declaration : .\libavcodec\avcodec.h:154</i> */
		public static final int AV_CODEC_ID_YOP = 139;
		/** <i>native declaration : .\libavcodec\avcodec.h:155</i> */
		public static final int AV_CODEC_ID_VP8 = 140;
		/** <i>native declaration : .\libavcodec\avcodec.h:156</i> */
		public static final int AV_CODEC_ID_PICTOR = 141;
		/** <i>native declaration : .\libavcodec\avcodec.h:157</i> */
		public static final int AV_CODEC_ID_ANSI = 142;
		/** <i>native declaration : .\libavcodec\avcodec.h:158</i> */
		public static final int AV_CODEC_ID_A64_MULTI = 143;
		/** <i>native declaration : .\libavcodec\avcodec.h:159</i> */
		public static final int AV_CODEC_ID_A64_MULTI5 = 144;
		/** <i>native declaration : .\libavcodec\avcodec.h:160</i> */
		public static final int AV_CODEC_ID_R10K = 145;
		/** <i>native declaration : .\libavcodec\avcodec.h:161</i> */
		public static final int AV_CODEC_ID_MXPEG = 146;
		/** <i>native declaration : .\libavcodec\avcodec.h:162</i> */
		public static final int AV_CODEC_ID_LAGARITH = 147;
		/** <i>native declaration : .\libavcodec\avcodec.h:163</i> */
		public static final int AV_CODEC_ID_PRORES = 148;
		/** <i>native declaration : .\libavcodec\avcodec.h:164</i> */
		public static final int AV_CODEC_ID_JV = 149;
		/** <i>native declaration : .\libavcodec\avcodec.h:165</i> */
		public static final int AV_CODEC_ID_DFA = 150;
		/** <i>native declaration : .\libavcodec\avcodec.h:166</i> */
		public static final int AV_CODEC_ID_WMV3IMAGE = 151;
		/** <i>native declaration : .\libavcodec\avcodec.h:167</i> */
		public static final int AV_CODEC_ID_VC1IMAGE = 152;
		/** <i>native declaration : .\libavcodec\avcodec.h:168</i> */
		public static final int AV_CODEC_ID_UTVIDEO = 153;
		/** <i>native declaration : .\libavcodec\avcodec.h:169</i> */
		public static final int AV_CODEC_ID_BMV_VIDEO = 154;
		/** <i>native declaration : .\libavcodec\avcodec.h:170</i> */
		public static final int AV_CODEC_ID_VBLE = 155;
		/** <i>native declaration : .\libavcodec\avcodec.h:171</i> */
		public static final int AV_CODEC_ID_DXTORY = 156;
		/** <i>native declaration : .\libavcodec\avcodec.h:172</i> */
		public static final int AV_CODEC_ID_V410 = 157;
		/** <i>native declaration : .\libavcodec\avcodec.h:173</i> */
		public static final int AV_CODEC_ID_XWD = 158;
		/** <i>native declaration : .\libavcodec\avcodec.h:174</i> */
		public static final int AV_CODEC_ID_CDXL = 159;
		/** <i>native declaration : .\libavcodec\avcodec.h:175</i> */
		public static final int AV_CODEC_ID_XBM = 160;
		/** <i>native declaration : .\libavcodec\avcodec.h:176</i> */
		public static final int AV_CODEC_ID_ZEROCODEC = 161;
		/** <i>native declaration : .\libavcodec\avcodec.h:177</i> */
		public static final int AV_CODEC_ID_MSS1 = 162;
		/** <i>native declaration : .\libavcodec\avcodec.h:178</i> */
		public static final int AV_CODEC_ID_MSA1 = 163;
		/** <i>native declaration : .\libavcodec\avcodec.h:179</i> */
		public static final int AV_CODEC_ID_TSCC2 = 164;
		/** <i>native declaration : .\libavcodec\avcodec.h:180</i> */
		public static final int AV_CODEC_ID_MTS2 = 165;
		/** <i>native declaration : .\libavcodec\avcodec.h:181</i> */
		public static final int AV_CODEC_ID_CLLC = 166;
		/** <i>native declaration : .\libavcodec\avcodec.h:182</i> */
		public static final int AV_CODEC_ID_MSS2 = 167;
		/** <i>native declaration : .\libavcodec\avcodec.h:183</i> */
		public static final int AV_CODEC_ID_VP9 = 168;
		/** <i>native declaration : .\libavcodec\avcodec.h:184</i> */
		public static final int AV_CODEC_ID_AIC = 169;
		/** <i>native declaration : .\libavcodec\avcodec.h:185</i> */
		public static final int AV_CODEC_ID_ESCAPE130 = 170;
		/** <i>native declaration : .\libavcodec\avcodec.h:186</i> */
		public static final int AV_CODEC_ID_G2M = 171;
		/** <i>native declaration : .\libavcodec\avcodec.h:187</i> */
		public static final int AV_CODEC_ID_WEBP = 172;
		/** <i>native declaration : .\libavcodec\avcodec.h:188</i> */
		public static final int AV_CODEC_ID_HNM4_VIDEO = 173;
		/** <i>native declaration : .\libavcodec\avcodec.h:189</i> */
		public static final int AV_CODEC_ID_HEVC = 174;
		/** <i>native declaration : .\libavcodec\avcodec.h:190</i> */
		public static final int AV_CODEC_ID_FIC = 175;
		/** <i>native declaration : .\libavcodec\avcodec.h:191</i> */
		public static final int AV_CODEC_ID_ALIAS_PIX = 176;
		/** <i>native declaration : .\libavcodec\avcodec.h:192</i> */
		public static final int AV_CODEC_ID_BRENDER_PIX = 177;
		/** <i>native declaration : .\libavcodec\avcodec.h:193</i> */
		public static final int AV_CODEC_ID_PAF_VIDEO = 178;
		/** <i>native declaration : .\libavcodec\avcodec.h:194</i> */
		public static final int AV_CODEC_ID_EXR = 179;
		/** <i>native declaration : .\libavcodec\avcodec.h:195</i> */
		public static final int AV_CODEC_ID_VP7 = 180;
		/** <i>native declaration : .\libavcodec\avcodec.h:196</i> */
		public static final int AV_CODEC_ID_SANM = 181;
		/** <i>native declaration : .\libavcodec\avcodec.h:197</i> */
		public static final int AV_CODEC_ID_SGIRLE = 182;
		/** <i>native declaration : .\libavcodec\avcodec.h:198</i> */
		public static final int AV_CODEC_ID_MVC1 = 183;
		/** <i>native declaration : .\libavcodec\avcodec.h:199</i> */
		public static final int AV_CODEC_ID_MVC2 = 184;
		/** <i>native declaration : .\libavcodec\avcodec.h:200</i> */
		public static final int AV_CODEC_ID_HQX = 185;
		/** <i>native declaration : .\libavcodec\avcodec.h:201</i> */
		public static final int AV_CODEC_ID_TDSC = 186;
		/** <i>native declaration : .\libavcodec\avcodec.h:202</i> */
		public static final int AV_CODEC_ID_HQ_HQA = 187;
		/** <i>native declaration : .\libavcodec\avcodec.h:203</i> */
		public static final int AV_CODEC_ID_HAP = 188;
		/** <i>native declaration : .\libavcodec\avcodec.h:204</i> */
		public static final int AV_CODEC_ID_DDS = 189;
		/** <i>native declaration : .\libavcodec\avcodec.h:205</i> */
		public static final int AV_CODEC_ID_DXV = 190;
		/** <i>native declaration : .\libavcodec\avcodec.h:206</i> */
		public static final int AV_CODEC_ID_SCREENPRESSO = 191;
		/** <i>native declaration : .\libavcodec\avcodec.h:207</i> */
		public static final int AV_CODEC_ID_RSCC = 192;
		/** <i>native declaration : .\libavcodec\avcodec.h:208</i> */
		public static final int AV_CODEC_ID_Y41P = 0x8000;
		/** <i>native declaration : .\libavcodec\avcodec.h:209</i> */
		public static final int AV_CODEC_ID_AVRP = (0x8000 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:210</i> */
		public static final int AV_CODEC_ID_012V = (0x8000 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:211</i> */
		public static final int AV_CODEC_ID_AVUI = (0x8000 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:212</i> */
		public static final int AV_CODEC_ID_AYUV = (0x8000 + 4);
		/** <i>native declaration : .\libavcodec\avcodec.h:213</i> */
		public static final int AV_CODEC_ID_TARGA_Y216 = (0x8000 + 5);
		/** <i>native declaration : .\libavcodec\avcodec.h:214</i> */
		public static final int AV_CODEC_ID_V308 = (0x8000 + 6);
		/** <i>native declaration : .\libavcodec\avcodec.h:215</i> */
		public static final int AV_CODEC_ID_V408 = (0x8000 + 7);
		/** <i>native declaration : .\libavcodec\avcodec.h:216</i> */
		public static final int AV_CODEC_ID_YUV4 = (0x8000 + 8);
		/** <i>native declaration : .\libavcodec\avcodec.h:217</i> */
		public static final int AV_CODEC_ID_AVRN = (0x8000 + 9);
		/** <i>native declaration : .\libavcodec\avcodec.h:218</i> */
		public static final int AV_CODEC_ID_CPIA = (0x8000 + 10);
		/** <i>native declaration : .\libavcodec\avcodec.h:219</i> */
		public static final int AV_CODEC_ID_XFACE = (0x8000 + 11);
		/** <i>native declaration : .\libavcodec\avcodec.h:220</i> */
		public static final int AV_CODEC_ID_SNOW = (0x8000 + 12);
		/** <i>native declaration : .\libavcodec\avcodec.h:221</i> */
		public static final int AV_CODEC_ID_SMVJPEG = (0x8000 + 13);
		/** <i>native declaration : .\libavcodec\avcodec.h:222</i> */
		public static final int AV_CODEC_ID_APNG = (0x8000 + 14);
		/** <i>native declaration : .\libavcodec\avcodec.h:223</i> */
		public static final int AV_CODEC_ID_DAALA = (0x8000 + 15);
		/** <i>native declaration : .\libavcodec\avcodec.h:224</i> */
		public static final int AV_CODEC_ID_CFHD = (0x8000 + 16);
		/** <i>native declaration : .\libavcodec\avcodec.h:225</i> */
		public static final int AV_CODEC_ID_TRUEMOTION2RT = (0x8000 + 17);
		/** <i>native declaration : .\libavcodec\avcodec.h:226</i> */
		public static final int AV_CODEC_ID_M101 = (0x8000 + 18);
		/** <i>native declaration : .\libavcodec\avcodec.h:227</i> */
		public static final int AV_CODEC_ID_MAGICYUV = (0x8000 + 19);
		/** <i>native declaration : .\libavcodec\avcodec.h:228</i> */
		public static final int AV_CODEC_ID_SHEERVIDEO = (0x8000 + 20);
		/** <i>native declaration : .\libavcodec\avcodec.h:229</i> */
		public static final int AV_CODEC_ID_YLC = (0x8000 + 21);
		/** <i>native declaration : .\libavcodec\avcodec.h:230</i> */
		public static final int AV_CODEC_ID_PSD = (0x8000 + 22);
		/** <i>native declaration : .\libavcodec\avcodec.h:231</i> */
		public static final int AV_CODEC_ID_PIXLET = (0x8000 + 23);
		/** <i>native declaration : .\libavcodec\avcodec.h:232</i> */
		public static final int AV_CODEC_ID_SPEEDHQ = (0x8000 + 24);
		/** <i>native declaration : .\libavcodec\avcodec.h:233</i> */
		public static final int AV_CODEC_ID_FMVC = (0x8000 + 25);
		/** <i>native declaration : .\libavcodec\avcodec.h:234</i> */
		public static final int AV_CODEC_ID_SCPR = (0x8000 + 26);
		/** <i>native declaration : .\libavcodec\avcodec.h:235</i> */
		public static final int AV_CODEC_ID_CLEARVIDEO = (0x8000 + 27);
		/** <i>native declaration : .\libavcodec\avcodec.h:236</i> */
		public static final int AV_CODEC_ID_XPM = (0x8000 + 28);
		/** <i>native declaration : .\libavcodec\avcodec.h:237</i> */
		public static final int AV_CODEC_ID_AV1 = (0x8000 + 29);
		/**
		 * < A dummy id pointing at the start of audio codecs<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:239</i>
		 */
		public static final int AV_CODEC_ID_FIRST_AUDIO = 0x10000;
		/** <i>native declaration : .\libavcodec\avcodec.h:240</i> */
		public static final int AV_CODEC_ID_PCM_S16LE = 0x10000;
		/** <i>native declaration : .\libavcodec\avcodec.h:241</i> */
		public static final int AV_CODEC_ID_PCM_S16BE = (0x10000 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:242</i> */
		public static final int AV_CODEC_ID_PCM_U16LE = (0x10000 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:243</i> */
		public static final int AV_CODEC_ID_PCM_U16BE = (0x10000 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:244</i> */
		public static final int AV_CODEC_ID_PCM_S8 = (0x10000 + 4);
		/** <i>native declaration : .\libavcodec\avcodec.h:245</i> */
		public static final int AV_CODEC_ID_PCM_U8 = (0x10000 + 5);
		/** <i>native declaration : .\libavcodec\avcodec.h:246</i> */
		public static final int AV_CODEC_ID_PCM_MULAW = (0x10000 + 6);
		/** <i>native declaration : .\libavcodec\avcodec.h:247</i> */
		public static final int AV_CODEC_ID_PCM_ALAW = (0x10000 + 7);
		/** <i>native declaration : .\libavcodec\avcodec.h:248</i> */
		public static final int AV_CODEC_ID_PCM_S32LE = (0x10000 + 8);
		/** <i>native declaration : .\libavcodec\avcodec.h:249</i> */
		public static final int AV_CODEC_ID_PCM_S32BE = (0x10000 + 9);
		/** <i>native declaration : .\libavcodec\avcodec.h:250</i> */
		public static final int AV_CODEC_ID_PCM_U32LE = (0x10000 + 10);
		/** <i>native declaration : .\libavcodec\avcodec.h:251</i> */
		public static final int AV_CODEC_ID_PCM_U32BE = (0x10000 + 11);
		/** <i>native declaration : .\libavcodec\avcodec.h:252</i> */
		public static final int AV_CODEC_ID_PCM_S24LE = (0x10000 + 12);
		/** <i>native declaration : .\libavcodec\avcodec.h:253</i> */
		public static final int AV_CODEC_ID_PCM_S24BE = (0x10000 + 13);
		/** <i>native declaration : .\libavcodec\avcodec.h:254</i> */
		public static final int AV_CODEC_ID_PCM_U24LE = (0x10000 + 14);
		/** <i>native declaration : .\libavcodec\avcodec.h:255</i> */
		public static final int AV_CODEC_ID_PCM_U24BE = (0x10000 + 15);
		/** <i>native declaration : .\libavcodec\avcodec.h:256</i> */
		public static final int AV_CODEC_ID_PCM_S24DAUD = (0x10000 + 16);
		/** <i>native declaration : .\libavcodec\avcodec.h:257</i> */
		public static final int AV_CODEC_ID_PCM_ZORK = (0x10000 + 17);
		/** <i>native declaration : .\libavcodec\avcodec.h:258</i> */
		public static final int AV_CODEC_ID_PCM_S16LE_PLANAR = (0x10000 + 18);
		/** <i>native declaration : .\libavcodec\avcodec.h:259</i> */
		public static final int AV_CODEC_ID_PCM_DVD = (0x10000 + 19);
		/** <i>native declaration : .\libavcodec\avcodec.h:260</i> */
		public static final int AV_CODEC_ID_PCM_F32BE = (0x10000 + 20);
		/** <i>native declaration : .\libavcodec\avcodec.h:261</i> */
		public static final int AV_CODEC_ID_PCM_F32LE = (0x10000 + 21);
		/** <i>native declaration : .\libavcodec\avcodec.h:262</i> */
		public static final int AV_CODEC_ID_PCM_F64BE = (0x10000 + 22);
		/** <i>native declaration : .\libavcodec\avcodec.h:263</i> */
		public static final int AV_CODEC_ID_PCM_F64LE = (0x10000 + 23);
		/** <i>native declaration : .\libavcodec\avcodec.h:264</i> */
		public static final int AV_CODEC_ID_PCM_BLURAY = (0x10000 + 24);
		/** <i>native declaration : .\libavcodec\avcodec.h:265</i> */
		public static final int AV_CODEC_ID_PCM_LXF = (0x10000 + 25);
		/** <i>native declaration : .\libavcodec\avcodec.h:266</i> */
		public static final int AV_CODEC_ID_S302M = (0x10000 + 26);
		/** <i>native declaration : .\libavcodec\avcodec.h:267</i> */
		public static final int AV_CODEC_ID_PCM_S8_PLANAR = (0x10000 + 27);
		/** <i>native declaration : .\libavcodec\avcodec.h:268</i> */
		public static final int AV_CODEC_ID_PCM_S24LE_PLANAR = (0x10000 + 28);
		/** <i>native declaration : .\libavcodec\avcodec.h:269</i> */
		public static final int AV_CODEC_ID_PCM_S32LE_PLANAR = (0x10000 + 29);
		/** <i>native declaration : .\libavcodec\avcodec.h:270</i> */
		public static final int AV_CODEC_ID_PCM_S16BE_PLANAR = (0x10000 + 30);
		/** <i>native declaration : .\libavcodec\avcodec.h:271</i> */
		public static final int AV_CODEC_ID_PCM_S64LE = 0x10800;
		/** <i>native declaration : .\libavcodec\avcodec.h:272</i> */
		public static final int AV_CODEC_ID_PCM_S64BE = (0x10800 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:273</i> */
		public static final int AV_CODEC_ID_PCM_F16LE = (0x10800 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:274</i> */
		public static final int AV_CODEC_ID_PCM_F24LE = (0x10800 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:275</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_QT = 0x11000;
		/** <i>native declaration : .\libavcodec\avcodec.h:276</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_WAV = (0x11000 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:277</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_DK3 = (0x11000 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:278</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_DK4 = (0x11000 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:279</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_WS = (0x11000 + 4);
		/** <i>native declaration : .\libavcodec\avcodec.h:280</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_SMJPEG = (0x11000 + 5);
		/** <i>native declaration : .\libavcodec\avcodec.h:281</i> */
		public static final int AV_CODEC_ID_ADPCM_MS = (0x11000 + 6);
		/** <i>native declaration : .\libavcodec\avcodec.h:282</i> */
		public static final int AV_CODEC_ID_ADPCM_4XM = (0x11000 + 7);
		/** <i>native declaration : .\libavcodec\avcodec.h:283</i> */
		public static final int AV_CODEC_ID_ADPCM_XA = (0x11000 + 8);
		/** <i>native declaration : .\libavcodec\avcodec.h:284</i> */
		public static final int AV_CODEC_ID_ADPCM_ADX = (0x11000 + 9);
		/** <i>native declaration : .\libavcodec\avcodec.h:285</i> */
		public static final int AV_CODEC_ID_ADPCM_EA = (0x11000 + 10);
		/** <i>native declaration : .\libavcodec\avcodec.h:286</i> */
		public static final int AV_CODEC_ID_ADPCM_G726 = (0x11000 + 11);
		/** <i>native declaration : .\libavcodec\avcodec.h:287</i> */
		public static final int AV_CODEC_ID_ADPCM_CT = (0x11000 + 12);
		/** <i>native declaration : .\libavcodec\avcodec.h:288</i> */
		public static final int AV_CODEC_ID_ADPCM_SWF = (0x11000 + 13);
		/** <i>native declaration : .\libavcodec\avcodec.h:289</i> */
		public static final int AV_CODEC_ID_ADPCM_YAMAHA = (0x11000 + 14);
		/** <i>native declaration : .\libavcodec\avcodec.h:290</i> */
		public static final int AV_CODEC_ID_ADPCM_SBPRO_4 = (0x11000 + 15);
		/** <i>native declaration : .\libavcodec\avcodec.h:291</i> */
		public static final int AV_CODEC_ID_ADPCM_SBPRO_3 = (0x11000 + 16);
		/** <i>native declaration : .\libavcodec\avcodec.h:292</i> */
		public static final int AV_CODEC_ID_ADPCM_SBPRO_2 = (0x11000 + 17);
		/** <i>native declaration : .\libavcodec\avcodec.h:293</i> */
		public static final int AV_CODEC_ID_ADPCM_THP = (0x11000 + 18);
		/** <i>native declaration : .\libavcodec\avcodec.h:294</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_AMV = (0x11000 + 19);
		/** <i>native declaration : .\libavcodec\avcodec.h:295</i> */
		public static final int AV_CODEC_ID_ADPCM_EA_R1 = (0x11000 + 20);
		/** <i>native declaration : .\libavcodec\avcodec.h:296</i> */
		public static final int AV_CODEC_ID_ADPCM_EA_R3 = (0x11000 + 21);
		/** <i>native declaration : .\libavcodec\avcodec.h:297</i> */
		public static final int AV_CODEC_ID_ADPCM_EA_R2 = (0x11000 + 22);
		/** <i>native declaration : .\libavcodec\avcodec.h:298</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_EA_SEAD = (0x11000 + 23);
		/** <i>native declaration : .\libavcodec\avcodec.h:299</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_EA_EACS = (0x11000 + 24);
		/** <i>native declaration : .\libavcodec\avcodec.h:300</i> */
		public static final int AV_CODEC_ID_ADPCM_EA_XAS = (0x11000 + 25);
		/** <i>native declaration : .\libavcodec\avcodec.h:301</i> */
		public static final int AV_CODEC_ID_ADPCM_EA_MAXIS_XA = (0x11000 + 26);
		/** <i>native declaration : .\libavcodec\avcodec.h:302</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_ISS = (0x11000 + 27);
		/** <i>native declaration : .\libavcodec\avcodec.h:303</i> */
		public static final int AV_CODEC_ID_ADPCM_G722 = (0x11000 + 28);
		/** <i>native declaration : .\libavcodec\avcodec.h:304</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_APC = (0x11000 + 29);
		/** <i>native declaration : .\libavcodec\avcodec.h:305</i> */
		public static final int AV_CODEC_ID_ADPCM_VIMA = (0x11000 + 30);
		/** <i>native declaration : .\libavcodec\avcodec.h:306</i> */
		public static final int AV_CODEC_ID_VIMA = (int) AVCodecID.AV_CODEC_ID_ADPCM_VIMA;
		/** <i>native declaration : .\libavcodec\avcodec.h:307</i> */
		public static final int AV_CODEC_ID_ADPCM_AFC = 0x11800;
		/** <i>native declaration : .\libavcodec\avcodec.h:308</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_OKI = (0x11800 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:309</i> */
		public static final int AV_CODEC_ID_ADPCM_DTK = (0x11800 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:310</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_RAD = (0x11800 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:311</i> */
		public static final int AV_CODEC_ID_ADPCM_G726LE = (0x11800 + 4);
		/** <i>native declaration : .\libavcodec\avcodec.h:312</i> */
		public static final int AV_CODEC_ID_ADPCM_THP_LE = (0x11800 + 5);
		/** <i>native declaration : .\libavcodec\avcodec.h:313</i> */
		public static final int AV_CODEC_ID_ADPCM_PSX = (0x11800 + 6);
		/** <i>native declaration : .\libavcodec\avcodec.h:314</i> */
		public static final int AV_CODEC_ID_ADPCM_AICA = (0x11800 + 7);
		/** <i>native declaration : .\libavcodec\avcodec.h:315</i> */
		public static final int AV_CODEC_ID_ADPCM_IMA_DAT4 = (0x11800 + 8);
		/** <i>native declaration : .\libavcodec\avcodec.h:316</i> */
		public static final int AV_CODEC_ID_ADPCM_MTAF = (0x11800 + 9);
		/** <i>native declaration : .\libavcodec\avcodec.h:317</i> */
		public static final int AV_CODEC_ID_AMR_NB = 0x12000;
		/** <i>native declaration : .\libavcodec\avcodec.h:318</i> */
		public static final int AV_CODEC_ID_AMR_WB = (0x12000 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:319</i> */
		public static final int AV_CODEC_ID_RA_144 = 0x13000;
		/** <i>native declaration : .\libavcodec\avcodec.h:320</i> */
		public static final int AV_CODEC_ID_RA_288 = (0x13000 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:321</i> */
		public static final int AV_CODEC_ID_ROQ_DPCM = 0x14000;
		/** <i>native declaration : .\libavcodec\avcodec.h:322</i> */
		public static final int AV_CODEC_ID_INTERPLAY_DPCM = (0x14000 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:323</i> */
		public static final int AV_CODEC_ID_XAN_DPCM = (0x14000 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:324</i> */
		public static final int AV_CODEC_ID_SOL_DPCM = (0x14000 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:325</i> */
		public static final int AV_CODEC_ID_SDX2_DPCM = 0x14800;
		/** <i>native declaration : .\libavcodec\avcodec.h:326</i> */
		public static final int AV_CODEC_ID_MP2 = 0x15000;
		/**
		 * < preferred ID for decoding MPEG audio layer 1, 2 or 3<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:328</i>
		 */
		public static final int AV_CODEC_ID_MP3 = (0x15000 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:329</i> */
		public static final int AV_CODEC_ID_AAC = (0x15000 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:330</i> */
		public static final int AV_CODEC_ID_AC3 = (0x15000 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:331</i> */
		public static final int AV_CODEC_ID_DTS = (0x15000 + 4);
		/** <i>native declaration : .\libavcodec\avcodec.h:332</i> */
		public static final int AV_CODEC_ID_VORBIS = (0x15000 + 5);
		/** <i>native declaration : .\libavcodec\avcodec.h:333</i> */
		public static final int AV_CODEC_ID_DVAUDIO = (0x15000 + 6);
		/** <i>native declaration : .\libavcodec\avcodec.h:334</i> */
		public static final int AV_CODEC_ID_WMAV1 = (0x15000 + 7);
		/** <i>native declaration : .\libavcodec\avcodec.h:335</i> */
		public static final int AV_CODEC_ID_WMAV2 = (0x15000 + 8);
		/** <i>native declaration : .\libavcodec\avcodec.h:336</i> */
		public static final int AV_CODEC_ID_MACE3 = (0x15000 + 9);
		/** <i>native declaration : .\libavcodec\avcodec.h:337</i> */
		public static final int AV_CODEC_ID_MACE6 = (0x15000 + 10);
		/** <i>native declaration : .\libavcodec\avcodec.h:338</i> */
		public static final int AV_CODEC_ID_VMDAUDIO = (0x15000 + 11);
		/** <i>native declaration : .\libavcodec\avcodec.h:339</i> */
		public static final int AV_CODEC_ID_FLAC = (0x15000 + 12);
		/** <i>native declaration : .\libavcodec\avcodec.h:340</i> */
		public static final int AV_CODEC_ID_MP3ADU = (0x15000 + 13);
		/** <i>native declaration : .\libavcodec\avcodec.h:341</i> */
		public static final int AV_CODEC_ID_MP3ON4 = (0x15000 + 14);
		/** <i>native declaration : .\libavcodec\avcodec.h:342</i> */
		public static final int AV_CODEC_ID_SHORTEN = (0x15000 + 15);
		/** <i>native declaration : .\libavcodec\avcodec.h:343</i> */
		public static final int AV_CODEC_ID_ALAC = (0x15000 + 16);
		/** <i>native declaration : .\libavcodec\avcodec.h:344</i> */
		public static final int AV_CODEC_ID_WESTWOOD_SND1 = (0x15000 + 17);
		/**
		 * < as in Berlin toast format<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:346</i>
		 */
		public static final int AV_CODEC_ID_GSM = (0x15000 + 18);
		/** <i>native declaration : .\libavcodec\avcodec.h:347</i> */
		public static final int AV_CODEC_ID_QDM2 = (0x15000 + 19);
		/** <i>native declaration : .\libavcodec\avcodec.h:348</i> */
		public static final int AV_CODEC_ID_COOK = (0x15000 + 20);
		/** <i>native declaration : .\libavcodec\avcodec.h:349</i> */
		public static final int AV_CODEC_ID_TRUESPEECH = (0x15000 + 21);
		/** <i>native declaration : .\libavcodec\avcodec.h:350</i> */
		public static final int AV_CODEC_ID_TTA = (0x15000 + 22);
		/** <i>native declaration : .\libavcodec\avcodec.h:351</i> */
		public static final int AV_CODEC_ID_SMACKAUDIO = (0x15000 + 23);
		/** <i>native declaration : .\libavcodec\avcodec.h:352</i> */
		public static final int AV_CODEC_ID_QCELP = (0x15000 + 24);
		/** <i>native declaration : .\libavcodec\avcodec.h:353</i> */
		public static final int AV_CODEC_ID_WAVPACK = (0x15000 + 25);
		/** <i>native declaration : .\libavcodec\avcodec.h:354</i> */
		public static final int AV_CODEC_ID_DSICINAUDIO = (0x15000 + 26);
		/** <i>native declaration : .\libavcodec\avcodec.h:355</i> */
		public static final int AV_CODEC_ID_IMC = (0x15000 + 27);
		/** <i>native declaration : .\libavcodec\avcodec.h:356</i> */
		public static final int AV_CODEC_ID_MUSEPACK7 = (0x15000 + 28);
		/** <i>native declaration : .\libavcodec\avcodec.h:357</i> */
		public static final int AV_CODEC_ID_MLP = (0x15000 + 29);
		/**
		 * as found in WAV<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:358</i>
		 */
		public static final int AV_CODEC_ID_GSM_MS = (0x15000 + 30);
		/** <i>native declaration : .\libavcodec\avcodec.h:359</i> */
		public static final int AV_CODEC_ID_ATRAC3 = (0x15000 + 31);
		/** <i>native declaration : .\libavcodec\avcodec.h:360</i> */
		public static final int AV_CODEC_ID_VOXWARE = (0x15000 + 32);
		/** <i>native declaration : .\libavcodec\avcodec.h:361</i> */
		public static final int AV_CODEC_ID_APE = (0x15000 + 33);
		/** <i>native declaration : .\libavcodec\avcodec.h:362</i> */
		public static final int AV_CODEC_ID_NELLYMOSER = (0x15000 + 34);
		/** <i>native declaration : .\libavcodec\avcodec.h:363</i> */
		public static final int AV_CODEC_ID_MUSEPACK8 = (0x15000 + 35);
		/** <i>native declaration : .\libavcodec\avcodec.h:364</i> */
		public static final int AV_CODEC_ID_SPEEX = (0x15000 + 36);
		/** <i>native declaration : .\libavcodec\avcodec.h:365</i> */
		public static final int AV_CODEC_ID_WMAVOICE = (0x15000 + 37);
		/** <i>native declaration : .\libavcodec\avcodec.h:366</i> */
		public static final int AV_CODEC_ID_WMAPRO = (0x15000 + 38);
		/** <i>native declaration : .\libavcodec\avcodec.h:367</i> */
		public static final int AV_CODEC_ID_WMALOSSLESS = (0x15000 + 39);
		/** <i>native declaration : .\libavcodec\avcodec.h:368</i> */
		public static final int AV_CODEC_ID_ATRAC3P = (0x15000 + 40);
		/** <i>native declaration : .\libavcodec\avcodec.h:369</i> */
		public static final int AV_CODEC_ID_EAC3 = (0x15000 + 41);
		/** <i>native declaration : .\libavcodec\avcodec.h:370</i> */
		public static final int AV_CODEC_ID_SIPR = (0x15000 + 42);
		/** <i>native declaration : .\libavcodec\avcodec.h:371</i> */
		public static final int AV_CODEC_ID_MP1 = (0x15000 + 43);
		/** <i>native declaration : .\libavcodec\avcodec.h:372</i> */
		public static final int AV_CODEC_ID_TWINVQ = (0x15000 + 44);
		/** <i>native declaration : .\libavcodec\avcodec.h:373</i> */
		public static final int AV_CODEC_ID_TRUEHD = (0x15000 + 45);
		/** <i>native declaration : .\libavcodec\avcodec.h:374</i> */
		public static final int AV_CODEC_ID_MP4ALS = (0x15000 + 46);
		/** <i>native declaration : .\libavcodec\avcodec.h:375</i> */
		public static final int AV_CODEC_ID_ATRAC1 = (0x15000 + 47);
		/** <i>native declaration : .\libavcodec\avcodec.h:376</i> */
		public static final int AV_CODEC_ID_BINKAUDIO_RDFT = (0x15000 + 48);
		/** <i>native declaration : .\libavcodec\avcodec.h:377</i> */
		public static final int AV_CODEC_ID_BINKAUDIO_DCT = (0x15000 + 49);
		/** <i>native declaration : .\libavcodec\avcodec.h:378</i> */
		public static final int AV_CODEC_ID_AAC_LATM = (0x15000 + 50);
		/** <i>native declaration : .\libavcodec\avcodec.h:379</i> */
		public static final int AV_CODEC_ID_QDMC = (0x15000 + 51);
		/** <i>native declaration : .\libavcodec\avcodec.h:380</i> */
		public static final int AV_CODEC_ID_CELT = (0x15000 + 52);
		/** <i>native declaration : .\libavcodec\avcodec.h:381</i> */
		public static final int AV_CODEC_ID_G723_1 = (0x15000 + 53);
		/** <i>native declaration : .\libavcodec\avcodec.h:382</i> */
		public static final int AV_CODEC_ID_G729 = (0x15000 + 54);
		/** <i>native declaration : .\libavcodec\avcodec.h:383</i> */
		public static final int AV_CODEC_ID_8SVX_EXP = (0x15000 + 55);
		/** <i>native declaration : .\libavcodec\avcodec.h:384</i> */
		public static final int AV_CODEC_ID_8SVX_FIB = (0x15000 + 56);
		/** <i>native declaration : .\libavcodec\avcodec.h:385</i> */
		public static final int AV_CODEC_ID_BMV_AUDIO = (0x15000 + 57);
		/** <i>native declaration : .\libavcodec\avcodec.h:386</i> */
		public static final int AV_CODEC_ID_RALF = (0x15000 + 58);
		/** <i>native declaration : .\libavcodec\avcodec.h:387</i> */
		public static final int AV_CODEC_ID_IAC = (0x15000 + 59);
		/** <i>native declaration : .\libavcodec\avcodec.h:388</i> */
		public static final int AV_CODEC_ID_ILBC = (0x15000 + 60);
		/** <i>native declaration : .\libavcodec\avcodec.h:389</i> */
		public static final int AV_CODEC_ID_OPUS = (0x15000 + 61);
		/** <i>native declaration : .\libavcodec\avcodec.h:390</i> */
		public static final int AV_CODEC_ID_COMFORT_NOISE = (0x15000 + 62);
		/** <i>native declaration : .\libavcodec\avcodec.h:391</i> */
		public static final int AV_CODEC_ID_TAK = (0x15000 + 63);
		/** <i>native declaration : .\libavcodec\avcodec.h:392</i> */
		public static final int AV_CODEC_ID_METASOUND = (0x15000 + 64);
		/** <i>native declaration : .\libavcodec\avcodec.h:393</i> */
		public static final int AV_CODEC_ID_PAF_AUDIO = (0x15000 + 65);
		/** <i>native declaration : .\libavcodec\avcodec.h:394</i> */
		public static final int AV_CODEC_ID_ON2AVC = (0x15000 + 66);
		/** <i>native declaration : .\libavcodec\avcodec.h:395</i> */
		public static final int AV_CODEC_ID_DSS_SP = (0x15000 + 67);
		/** <i>native declaration : .\libavcodec\avcodec.h:396</i> */
		public static final int AV_CODEC_ID_FFWAVESYNTH = 0x15800;
		/** <i>native declaration : .\libavcodec\avcodec.h:397</i> */
		public static final int AV_CODEC_ID_SONIC = (0x15800 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:398</i> */
		public static final int AV_CODEC_ID_SONIC_LS = (0x15800 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:399</i> */
		public static final int AV_CODEC_ID_EVRC = (0x15800 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:400</i> */
		public static final int AV_CODEC_ID_SMV = (0x15800 + 4);
		/** <i>native declaration : .\libavcodec\avcodec.h:401</i> */
		public static final int AV_CODEC_ID_DSD_LSBF = (0x15800 + 5);
		/** <i>native declaration : .\libavcodec\avcodec.h:402</i> */
		public static final int AV_CODEC_ID_DSD_MSBF = (0x15800 + 6);
		/** <i>native declaration : .\libavcodec\avcodec.h:403</i> */
		public static final int AV_CODEC_ID_DSD_LSBF_PLANAR = (0x15800 + 7);
		/** <i>native declaration : .\libavcodec\avcodec.h:404</i> */
		public static final int AV_CODEC_ID_DSD_MSBF_PLANAR = (0x15800 + 8);
		/** <i>native declaration : .\libavcodec\avcodec.h:405</i> */
		public static final int AV_CODEC_ID_4GV = (0x15800 + 9);
		/** <i>native declaration : .\libavcodec\avcodec.h:406</i> */
		public static final int AV_CODEC_ID_INTERPLAY_ACM = (0x15800 + 10);
		/** <i>native declaration : .\libavcodec\avcodec.h:407</i> */
		public static final int AV_CODEC_ID_XMA1 = (0x15800 + 11);
		/** <i>native declaration : .\libavcodec\avcodec.h:408</i> */
		public static final int AV_CODEC_ID_XMA2 = (0x15800 + 12);
		/** <i>native declaration : .\libavcodec\avcodec.h:409</i> */
		public static final int AV_CODEC_ID_DST = (0x15800 + 13);
		/** <i>native declaration : .\libavcodec\avcodec.h:410</i> */
		public static final int AV_CODEC_ID_ATRAC3AL = (0x15800 + 14);
		/** <i>native declaration : .\libavcodec\avcodec.h:411</i> */
		public static final int AV_CODEC_ID_ATRAC3PAL = (0x15800 + 15);
		/**
		 * < A dummy ID pointing at the start of subtitle codecs.<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:413</i>
		 */
		public static final int AV_CODEC_ID_FIRST_SUBTITLE = 0x17000;
		/** <i>native declaration : .\libavcodec\avcodec.h:414</i> */
		public static final int AV_CODEC_ID_DVD_SUBTITLE = 0x17000;
		/** <i>native declaration : .\libavcodec\avcodec.h:415</i> */
		public static final int AV_CODEC_ID_DVB_SUBTITLE = (0x17000 + 1);
		/**
		 * < raw UTF-8 text<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:417</i>
		 */
		public static final int AV_CODEC_ID_TEXT = (0x17000 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:418</i> */
		public static final int AV_CODEC_ID_XSUB = (0x17000 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:419</i> */
		public static final int AV_CODEC_ID_SSA = (0x17000 + 4);
		/** <i>native declaration : .\libavcodec\avcodec.h:420</i> */
		public static final int AV_CODEC_ID_MOV_TEXT = (0x17000 + 5);
		/** <i>native declaration : .\libavcodec\avcodec.h:421</i> */
		public static final int AV_CODEC_ID_HDMV_PGS_SUBTITLE = (0x17000 + 6);
		/** <i>native declaration : .\libavcodec\avcodec.h:422</i> */
		public static final int AV_CODEC_ID_DVB_TELETEXT = (0x17000 + 7);
		/** <i>native declaration : .\libavcodec\avcodec.h:423</i> */
		public static final int AV_CODEC_ID_SRT = (0x17000 + 8);
		/** <i>native declaration : .\libavcodec\avcodec.h:424</i> */
		public static final int AV_CODEC_ID_MICRODVD = 0x17800;
		/** <i>native declaration : .\libavcodec\avcodec.h:425</i> */
		public static final int AV_CODEC_ID_EIA_608 = (0x17800 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:426</i> */
		public static final int AV_CODEC_ID_JACOSUB = (0x17800 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:427</i> */
		public static final int AV_CODEC_ID_SAMI = (0x17800 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:428</i> */
		public static final int AV_CODEC_ID_REALTEXT = (0x17800 + 4);
		/** <i>native declaration : .\libavcodec\avcodec.h:429</i> */
		public static final int AV_CODEC_ID_STL = (0x17800 + 5);
		/** <i>native declaration : .\libavcodec\avcodec.h:430</i> */
		public static final int AV_CODEC_ID_SUBVIEWER1 = (0x17800 + 6);
		/** <i>native declaration : .\libavcodec\avcodec.h:431</i> */
		public static final int AV_CODEC_ID_SUBVIEWER = (0x17800 + 7);
		/** <i>native declaration : .\libavcodec\avcodec.h:432</i> */
		public static final int AV_CODEC_ID_SUBRIP = (0x17800 + 8);
		/** <i>native declaration : .\libavcodec\avcodec.h:433</i> */
		public static final int AV_CODEC_ID_WEBVTT = (0x17800 + 9);
		/** <i>native declaration : .\libavcodec\avcodec.h:434</i> */
		public static final int AV_CODEC_ID_MPL2 = (0x17800 + 10);
		/** <i>native declaration : .\libavcodec\avcodec.h:435</i> */
		public static final int AV_CODEC_ID_VPLAYER = (0x17800 + 11);
		/** <i>native declaration : .\libavcodec\avcodec.h:436</i> */
		public static final int AV_CODEC_ID_PJS = (0x17800 + 12);
		/** <i>native declaration : .\libavcodec\avcodec.h:437</i> */
		public static final int AV_CODEC_ID_ASS = (0x17800 + 13);
		/** <i>native declaration : .\libavcodec\avcodec.h:438</i> */
		public static final int AV_CODEC_ID_HDMV_TEXT_SUBTITLE = (0x17800 + 14);
		/**
		 * < A dummy ID pointing at the start of various fake codecs.<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:440</i>
		 */
		public static final int AV_CODEC_ID_FIRST_UNKNOWN = 0x18000;
		/** <i>native declaration : .\libavcodec\avcodec.h:441</i> */
		public static final int AV_CODEC_ID_TTF = 0x18000;
		/**
		 * < Contain timestamp estimated through PCR of program stream.<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:443</i>
		 */
		public static final int AV_CODEC_ID_SCTE_35 = (0x18000 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:444</i> */
		public static final int AV_CODEC_ID_BINTEXT = 0x18800;
		/** <i>native declaration : .\libavcodec\avcodec.h:445</i> */
		public static final int AV_CODEC_ID_XBIN = (0x18800 + 1);
		/** <i>native declaration : .\libavcodec\avcodec.h:446</i> */
		public static final int AV_CODEC_ID_IDF = (0x18800 + 2);
		/** <i>native declaration : .\libavcodec\avcodec.h:447</i> */
		public static final int AV_CODEC_ID_OTF = (0x18800 + 3);
		/** <i>native declaration : .\libavcodec\avcodec.h:448</i> */
		public static final int AV_CODEC_ID_SMPTE_KLV = (0x18800 + 4);
		/** <i>native declaration : .\libavcodec\avcodec.h:449</i> */
		public static final int AV_CODEC_ID_DVD_NAV = (0x18800 + 5);
		/** <i>native declaration : .\libavcodec\avcodec.h:450</i> */
		public static final int AV_CODEC_ID_TIMED_ID3 = (0x18800 + 6);
		/** <i>native declaration : .\libavcodec\avcodec.h:451</i> */
		public static final int AV_CODEC_ID_BIN_DATA = (0x18800 + 7);
		/**
		 * < codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:453</i>
		 */
		public static final int AV_CODEC_ID_PROBE = 0x19000;
		/**
		 * < _FAKE_ codec to indicate a raw MPEG-2 TS<br>
		 * stream (only used by libavformat)<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:455</i>
		 */
		public static final int AV_CODEC_ID_MPEG2TS = 0x20000;
		/**
		 * < _FAKE_ codec to indicate a MPEG-4 Systems<br>
		 * stream (only used by libavformat)<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:457</i>
		 */
		public static final int AV_CODEC_ID_MPEG4SYSTEMS = 0x20001;
		/**
		 * < Dummy codec for streams containing only metadata information.<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:459</i>
		 */
		public static final int AV_CODEC_ID_FFMETADATA = 0x21000;
		/**
		 * < Passthrough codec, AVFrames wrapped in AVPacket<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:461</i>
		 */
		public static final int AV_CODEC_ID_WRAPPED_AVFRAME = 0x21001;
	};
	/**
	 * @ingroup lavc_encoding<br>
	 * motion estimation type.<br>
	 * @deprecated use codec private option instead<br>
	 * <i>native declaration : .\libavcodec\avcodec.h:504</i><br>
	 * enum values
	 */
	public static interface Motion_Est_ID {
		/**
		 * < no search, that is use 0,0 vector whenever one is needed<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:488</i>
		 */
		public static final int ME_ZERO = 1;
		/** <i>native declaration : .\libavcodec\avcodec.h:489</i> */
		public static final int ME_FULL = 2;
		/** <i>native declaration : .\libavcodec\avcodec.h:490</i> */
		public static final int ME_LOG = 3;
		/** <i>native declaration : .\libavcodec\avcodec.h:491</i> */
		public static final int ME_PHODS = 4;
		/**
		 * < enhanced predictive zonal search<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:493</i>
		 */
		public static final int ME_EPZS = 5;
		/**
		 * < reserved for experiments<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:495</i>
		 */
		public static final int ME_X1 = 6;
		/**
		 * < hexagon based search<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:497</i>
		 */
		public static final int ME_HEX = 7;
		/**
		 * < uneven multi-hexagon search<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:499</i>
		 */
		public static final int ME_UMH = 8;
		/**
		 * < transformed exhaustive search algorithm<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:501</i>
		 */
		public static final int ME_TESA = 9;
		/**
		 * < iterative search<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:503</i>
		 */
		public static final int ME_ITER = 50;
	};
	/**
	 * @ingroup lavc_decoding<br>
	 * <i>native declaration : .\libavcodec\avcodec.h:521</i><br>
	 * enum values
	 */
	public static interface AVDiscard {
		/**
		 * < discard nothing<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:508</i>
		 */
		public static final int AVDISCARD_NONE = -16;
		/**
		 * < discard useless packets like 0 size packets in avi<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:510</i>
		 */
		public static final int AVDISCARD_DEFAULT = 0;
		/**
		 * < discard all non reference<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:512</i>
		 */
		public static final int AVDISCARD_NONREF = 8;
		/**
		 * < discard all bidirectional frames<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:514</i>
		 */
		public static final int AVDISCARD_BIDIR = 16;
		/**
		 * < discard all non intra frames<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:516</i>
		 */
		public static final int AVDISCARD_NONINTRA = 24;
		/**
		 * < discard all frames except keyframes<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:518</i>
		 */
		public static final int AVDISCARD_NONKEY = 32;
		/**
		 * < discard all<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:520</i>
		 */
		public static final int AVDISCARD_ALL = 48;
	};
	/**
	 * <i>native declaration : .\libavcodec\avcodec.h:534</i><br>
	 * enum values
	 */
	public static interface AVAudioServiceType {
		/** <i>native declaration : .\libavcodec\avcodec.h:523</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_MAIN = 0;
		/** <i>native declaration : .\libavcodec\avcodec.h:524</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_EFFECTS = 1;
		/** <i>native declaration : .\libavcodec\avcodec.h:525</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2;
		/** <i>native declaration : .\libavcodec\avcodec.h:526</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3;
		/** <i>native declaration : .\libavcodec\avcodec.h:527</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4;
		/** <i>native declaration : .\libavcodec\avcodec.h:528</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5;
		/** <i>native declaration : .\libavcodec\avcodec.h:529</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6;
		/** <i>native declaration : .\libavcodec\avcodec.h:530</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7;
		/** <i>native declaration : .\libavcodec\avcodec.h:531</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_KARAOKE = 8;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:533</i>
		 */
		public static final int AV_AUDIO_SERVICE_TYPE_NB = 9;
	};
	/**
	 * @defgroup lavc_packet AVPacket<br>
	 * Types and functions for working with AVPacket.<br>
	 * @{<br>
	 * <i>native declaration : .\libavcodec\avcodec.h:594</i><br>
	 * enum values
	 */
	public static interface AVPacketSideDataType {
		/** <i>native declaration : .\libavcodec\avcodec.h:572</i> */
		public static final int AV_PKT_DATA_PALETTE = 0;
		/** <i>native declaration : .\libavcodec\avcodec.h:573</i> */
		public static final int AV_PKT_DATA_NEW_EXTRADATA = 1;
		/** <i>native declaration : .\libavcodec\avcodec.h:574</i> */
		public static final int AV_PKT_DATA_PARAM_CHANGE = 2;
		/** <i>native declaration : .\libavcodec\avcodec.h:575</i> */
		public static final int AV_PKT_DATA_H263_MB_INFO = 3;
		/** <i>native declaration : .\libavcodec\avcodec.h:576</i> */
		public static final int AV_PKT_DATA_REPLAYGAIN = 4;
		/** <i>native declaration : .\libavcodec\avcodec.h:577</i> */
		public static final int AV_PKT_DATA_DISPLAYMATRIX = 5;
		/** <i>native declaration : .\libavcodec\avcodec.h:578</i> */
		public static final int AV_PKT_DATA_STEREO3D = 6;
		/** <i>native declaration : .\libavcodec\avcodec.h:579</i> */
		public static final int AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7;
		/** <i>native declaration : .\libavcodec\avcodec.h:580</i> */
		public static final int AV_PKT_DATA_QUALITY_STATS = 8;
		/** <i>native declaration : .\libavcodec\avcodec.h:581</i> */
		public static final int AV_PKT_DATA_FALLBACK_TRACK = 9;
		/** <i>native declaration : .\libavcodec\avcodec.h:582</i> */
		public static final int AV_PKT_DATA_CPB_PROPERTIES = 10;
		/** <i>native declaration : .\libavcodec\avcodec.h:583</i> */
		public static final int AV_PKT_DATA_SKIP_SAMPLES = 70;
		/** <i>native declaration : .\libavcodec\avcodec.h:584</i> */
		public static final int AV_PKT_DATA_JP_DUALMONO = 71;
		/** <i>native declaration : .\libavcodec\avcodec.h:585</i> */
		public static final int AV_PKT_DATA_STRINGS_METADATA = 72;
		/** <i>native declaration : .\libavcodec\avcodec.h:586</i> */
		public static final int AV_PKT_DATA_SUBTITLE_POSITION = 73;
		/** <i>native declaration : .\libavcodec\avcodec.h:587</i> */
		public static final int AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 74;
		/** <i>native declaration : .\libavcodec\avcodec.h:588</i> */
		public static final int AV_PKT_DATA_WEBVTT_IDENTIFIER = 75;
		/** <i>native declaration : .\libavcodec\avcodec.h:589</i> */
		public static final int AV_PKT_DATA_WEBVTT_SETTINGS = 76;
		/** <i>native declaration : .\libavcodec\avcodec.h:590</i> */
		public static final int AV_PKT_DATA_METADATA_UPDATE = 77;
		/** <i>native declaration : .\libavcodec\avcodec.h:591</i> */
		public static final int AV_PKT_DATA_MPEGTS_STREAM_ID = 78;
		/** <i>native declaration : .\libavcodec\avcodec.h:592</i> */
		public static final int AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 79;
		/** <i>native declaration : .\libavcodec\avcodec.h:593</i> */
		public static final int AV_PKT_DATA_SPHERICAL = 80;
	};
	/**
	 * Flag is used to discard packets which are required to maintain valid<br>
	 * decoder state but are not required for output and should be dropped<br>
	 * after decoding.<br>
	 * <i>native declaration : .\libavcodec\avcodec.h:649</i><br>
	 * enum values
	 */
	public static interface AVSideDataParamChangeFlags {
		/** <i>native declaration : .\libavcodec\avcodec.h:645</i> */
		public static final int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 0x0001;
		/** <i>native declaration : .\libavcodec\avcodec.h:646</i> */
		public static final int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 0x0002;
		/** <i>native declaration : .\libavcodec\avcodec.h:647</i> */
		public static final int AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 0x0004;
		/** <i>native declaration : .\libavcodec\avcodec.h:648</i> */
		public static final int AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 0x0008;
	};
	/**
	 * <i>native declaration : .\libavcodec\avcodec.h:665</i><br>
	 * enum values
	 */
	public static interface AVFieldOrder {
		/** <i>native declaration : .\libavcodec\avcodec.h:655</i> */
		public static final int AV_FIELD_UNKNOWN = 0;
		/** <i>native declaration : .\libavcodec\avcodec.h:656</i> */
		public static final int AV_FIELD_PROGRESSIVE = 1;
		/**
		 * < Top coded_first, top displayed first<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:658</i>
		 */
		public static final int AV_FIELD_TT = 2;
		/**
		 * < Bottom coded first, bottom displayed first<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:660</i>
		 */
		public static final int AV_FIELD_BB = 3;
		/**
		 * < Top coded first, bottom displayed first<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:662</i>
		 */
		public static final int AV_FIELD_TB = 4;
		/**
		 * < Bottom coded first, top displayed first<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:664</i>
		 */
		public static final int AV_FIELD_BT = 5;
	};
	/**
	 * @}<br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1089</i><br>
	 * enum values
	 */
	public static interface AVSubtitleType {
		/** <i>native declaration : .\libavcodec\avcodec.h:1084</i> */
		public static final int SUBTITLE_NONE = 0;
		/**
		 * < A bitmap, pict will be set<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:1086</i>
		 */
		public static final int SUBTITLE_BITMAP = 1;
		/** <i>native declaration : .\libavcodec\avcodec.h:1087</i> */
		public static final int SUBTITLE_TEXT = 2;
		/** <i>native declaration : .\libavcodec\avcodec.h:1088</i> */
		public static final int SUBTITLE_ASS = 3;
	};
	/**
	 * @defgroup lavc_parsing Frame parsing<br>
	 * @{<br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1894</i><br>
	 * enum values
	 */
	public static interface AVPictureStructure {
		/**
		 * < unknown<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:1887</i>
		 */
		public static final int AV_PICTURE_STRUCTURE_UNKNOWN = 0;
		/**
		 * < coded as top field<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:1889</i>
		 */
		public static final int AV_PICTURE_STRUCTURE_TOP_FIELD = 1;
		/**
		 * < coded as bottom field<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:1891</i>
		 */
		public static final int AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2;
		/**
		 * < coded as frame<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:1893</i>
		 */
		public static final int AV_PICTURE_STRUCTURE_FRAME = 3;
	};
	/**
	 * Lock operation used by lockmgr<br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2692</i><br>
	 * enum values
	 */
	public static interface AVLockOp {
		/**
		 * < Create a mutex<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:2685</i>
		 */
		public static final int AV_LOCK_CREATE = 0;
		/**
		 * < Lock the mutex<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:2687</i>
		 */
		public static final int AV_LOCK_OBTAIN = 1;
		/**
		 * < Unlock the mutex<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:2689</i>
		 */
		public static final int AV_LOCK_RELEASE = 2;
		/**
		 * < Free mutex resources<br>
		 * <i>native declaration : .\libavcodec\avcodec.h:2691</i>
		 */
		public static final int AV_LOCK_DESTROY = 3;
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil\rational.h:0</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final int LIBAVCODEC_VERSION_MAJOR = (int)57;
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final int LIBAVCODEC_VERSION_MINOR = (int)89;
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final int LIBAVCODEC_VERSION_MICRO = (int)100;
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final int LIBAVCODEC_VERSION_INT = (int)((57) << 16 | (89) << 8 | (100));
	/**
	 * define<br>
	 * Conversion Error : 57.89.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : .\libavcodec\version.h:0</i><br>
	 * 57.89.
	 */
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final int LIBAVCODEC_BUILD = (int)((57) << 16 | (89) << 8 | (100));
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final String LIBAVCODEC_IDENT = (String)"Lavc57.89.100";
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_VIMA_DECODER = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_AUDIO_CONVERT = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_AVCODEC_RESAMPLE = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_GETCHROMA = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_MISSING_SAMPLE = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_LOWRES = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_CAP_VDPAU = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_BUFS_VDPAU = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_VOXWARE = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_SET_DIMENSIONS = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_DEBUG_MV = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_AC_VLC = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_OLD_MSMPEG4 = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_ASPECT_EXTENDED = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_ARCH_ALPHA = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_ERROR_RATE = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_QSCALE_TYPE = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_MB_TYPE = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_MAX_BFRAMES = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_NEG_LINESIZES = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_EMU_EDGE = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_ARCH_SH4 = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_ARCH_SPARC = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_UNUSED_MEMBERS = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_IDCT_XVIDMMX = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_INPUT_PRESERVED = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_NORMALIZE_AQP = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_GMC = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_MV0 = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_CODEC_NAME = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_AFD = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_VISMV = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_AUDIOENC_DELAY = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_VAAPI_CONTEXT = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_MERGE_SD = (boolean)(57 < 58);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_AVCTX_TIMEBASE = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_MPV_OPT = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_STREAM_CODEC_TAG = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_QUANT_BIAS = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_RC_STRATEGY = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_CODED_FRAME = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_MOTION_EST = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_WITHOUT_PREFIX = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_SIDEDATA_ONLY_PKT = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_VDPAU_PROFILE = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_CONVERGENCE_DURATION = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_AVPICTURE = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_AVPACKET_OLD_API = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_RTP_CALLBACK = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_VBV_DELAY = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_CODER_TYPE = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_STAT_BITS = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_PRIVATE_OPT = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_ASS_TIMING = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_OLD_BSF = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_COPY_CONTEXT = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_GET_CONTEXT_DEFAULTS = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_NVENC_OLD_NAME = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_STRUCT_VAAPI_CONTEXT = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_MERGE_SD_API = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\version.h</i> */
	public static final boolean FF_API_TAG_STRING = (boolean)(57 < 59);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_PROP_INTRA_ONLY = (int)(1 << 0);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_PROP_LOSSY = (int)(1 << 1);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_PROP_LOSSLESS = (int)(1 << 2);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_PROP_REORDER = (int)(1 << 3);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_PROP_BITMAP_SUB = (int)(1 << 16);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_PROP_TEXT_SUB = (int)(1 << 17);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_INPUT_BUFFER_PADDING_SIZE = (int)32;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_INPUT_BUFFER_MIN_SIZE = (int)16384;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_INPUT_BUFFER_PADDING_SIZE = (int)32;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_MIN_BUFFER_SIZE = (int)16384;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_MAX_B_FRAMES = (int)16;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_UNALIGNED = (int)(1 << 0);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_QSCALE = (int)(1 << 1);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_4MV = (int)(1 << 2);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_OUTPUT_CORRUPT = (int)(1 << 3);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_QPEL = (int)(1 << 4);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_PASS1 = (int)(1 << 9);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_PASS2 = (int)(1 << 10);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_LOOP_FILTER = (int)(1 << 11);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_GRAY = (int)(1 << 13);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_PSNR = (int)(1 << 15);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_TRUNCATED = (int)(1 << 16);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_INTERLACED_DCT = (int)(1 << 18);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_LOW_DELAY = (int)(1 << 19);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_GLOBAL_HEADER = (int)(1 << 22);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_BITEXACT = (int)(1 << 23);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_AC_PRED = (int)(1 << 24);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_INTERLACED_ME = (int)(1 << 29);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG_CLOSED_GOP = (int)(1 << 31);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_FAST = (int)(1 << 0);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_NO_OUTPUT = (int)(1 << 2);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_LOCAL_HEADER = (int)(1 << 3);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_DROP_FRAME_TIMECODE = (int)(1 << 13);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_CHUNKS = (int)(1 << 15);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_IGNORE_CROP = (int)(1 << 16);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_SHOW_ALL = (int)(1 << 22);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_EXPORT_MVS = (int)(1 << 28);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_SKIP_MANUAL = (int)(1 << 29);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_RO_FLUSH_NOOP = (int)(1 << 30);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_DRAW_HORIZ_BAND = (int)(1 << 0);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_DR1 = (int)(1 << 1);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_TRUNCATED = (int)(1 << 3);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_DELAY = (int)(1 << 5);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_SMALL_LAST_FRAME = (int)(1 << 6);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_HWACCEL_VDPAU = (int)(1 << 7);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_SUBFRAMES = (int)(1 << 8);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_EXPERIMENTAL = (int)(1 << 9);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_CHANNEL_CONF = (int)(1 << 10);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_FRAME_THREADS = (int)(1 << 12);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_SLICE_THREADS = (int)(1 << 13);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_PARAM_CHANGE = (int)(1 << 14);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_AUTO_THREADS = (int)(1 << 15);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_VARIABLE_FRAME_SIZE = (int)(1 << 16);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_AVOID_PROBING = (int)(1 << 17);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_INTRA_ONLY = (int)0x40000000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_CODEC_CAP_LOSSLESS = (int)0x80000000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_UNALIGNED = (int)(1 << 0);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_QSCALE = (int)(1 << 1);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_4MV = (int)(1 << 2);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_OUTPUT_CORRUPT = (int)(1 << 3);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_QPEL = (int)(1 << 4);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_GMC = (int)0x0020;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_MV0 = (int)0x0040;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_INPUT_PRESERVED = (int)0x0100;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_PASS1 = (int)(1 << 9);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_PASS2 = (int)(1 << 10);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_GRAY = (int)(1 << 13);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_EMU_EDGE = (int)0x4000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_PSNR = (int)(1 << 15);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_TRUNCATED = (int)(1 << 16);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_NORMALIZE_AQP = (int)0x00020000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_INTERLACED_DCT = (int)(1 << 18);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_LOW_DELAY = (int)(1 << 19);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_GLOBAL_HEADER = (int)(1 << 22);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_BITEXACT = (int)(1 << 23);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_AC_PRED = (int)(1 << 24);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_LOOP_FILTER = (int)(1 << 11);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_INTERLACED_ME = (int)(1 << 29);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG_CLOSED_GOP = (int)(1 << 31);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG2_FAST = (int)(1 << 0);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG2_NO_OUTPUT = (int)(1 << 2);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG2_LOCAL_HEADER = (int)(1 << 3);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG2_DROP_FRAME_TIMECODE = (int)(1 << 13);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG2_IGNORE_CROP = (int)(1 << 16);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG2_CHUNKS = (int)(1 << 15);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG2_SHOW_ALL = (int)(1 << 22);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG2_EXPORT_MVS = (int)(1 << 28);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_FLAG2_SKIP_MANUAL = (int)(1 << 29);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_DRAW_HORIZ_BAND = (int)(1 << 0);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_DR1 = (int)(1 << 1);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_TRUNCATED = (int)(1 << 3);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_HWACCEL = (int)0x0010;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_DELAY = (int)(1 << 5);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_SMALL_LAST_FRAME = (int)(1 << 6);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_HWACCEL_VDPAU = (int)(1 << 7);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_SUBFRAMES = (int)(1 << 8);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_EXPERIMENTAL = (int)(1 << 9);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_CHANNEL_CONF = (int)(1 << 10);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_NEG_LINESIZES = (int)0x0800;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_FRAME_THREADS = (int)(1 << 12);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_SLICE_THREADS = (int)(1 << 13);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_PARAM_CHANGE = (int)(1 << 14);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_AUTO_THREADS = (int)(1 << 15);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_VARIABLE_FRAME_SIZE = (int)(1 << 16);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_INTRA_ONLY = (int)0x40000000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int CODEC_CAP_LOSSLESS = (int)0x80000000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int HWACCEL_CODEC_CAP_EXPERIMENTAL = (int)0x0200;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_INTRA4x4 = (int)0x0001;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_INTRA16x16 = (int)0x0002;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_INTRA_PCM = (int)0x0004;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_16x16 = (int)0x0008;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_16x8 = (int)0x0010;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_8x16 = (int)0x0020;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_8x8 = (int)0x0040;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_INTERLACED = (int)0x0080;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_DIRECT2 = (int)0x0100;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_ACPRED = (int)0x0200;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_GMC = (int)0x0400;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_SKIP = (int)0x0800;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_P0L0 = (int)0x1000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_P1L0 = (int)0x2000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_P0L1 = (int)0x4000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_P1L1 = (int)0x8000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_L0 = (int)(0x1000 | 0x2000);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_L1 = (int)(0x4000 | 0x8000);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_L0L1 = (int)((0x1000 | 0x2000) | (0x4000 | 0x8000));
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_QUANT = (int)0x00010000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int MB_TYPE_CBP = (int)0x00020000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_QSCALE_TYPE_MPEG1 = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_QSCALE_TYPE_MPEG2 = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_QSCALE_TYPE_H264 = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_QSCALE_TYPE_VP56 = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_GET_BUFFER_FLAG_REF = (int)(1 << 0);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_PKT_FLAG_KEY = (int)0x0001;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_PKT_FLAG_CORRUPT = (int)0x0002;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_PKT_FLAG_DISCARD = (int)0x0004;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_COMPRESSION_DEFAULT = (int)-1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_ASPECT_EXTENDED = (int)15;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_RC_STRATEGY_XVID = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PRED_LEFT = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PRED_PLANE = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PRED_MEDIAN = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_SAD = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_SSE = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_SATD = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_DCT = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_PSNR = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_BIT = (int)5;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_RD = (int)6;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_ZERO = (int)7;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_VSAD = (int)8;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_VSSE = (int)9;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_NSSE = (int)10;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_W53 = (int)11;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_W97 = (int)12;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_DCTMAX = (int)13;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_DCT264 = (int)14;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_MEDIAN_SAD = (int)15;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CMP_CHROMA = (int)256;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DTG_AFD_SAME = (int)8;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DTG_AFD_4_3 = (int)9;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DTG_AFD_16_9 = (int)10;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DTG_AFD_14_9 = (int)11;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DTG_AFD_4_3_SP_14_9 = (int)13;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DTG_AFD_16_9_SP_14_9 = (int)14;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DTG_AFD_SP_4_3 = (int)15;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEFAULT_QUANT_BIAS = (int)999999;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int SLICE_FLAG_CODED_ORDER = (int)0x0001;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int SLICE_FLAG_ALLOW_FIELD = (int)0x0002;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int SLICE_FLAG_ALLOW_PLANE = (int)0x0004;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_MB_DECISION_SIMPLE = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_MB_DECISION_BITS = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_MB_DECISION_RD = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CODER_TYPE_VLC = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CODER_TYPE_AC = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CODER_TYPE_RAW = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CODER_TYPE_RLE = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CODER_TYPE_DEFLATE = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_AUTODETECT = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_OLD_MSMPEG4 = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_XVID_ILACE = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_UMP4 = (int)8;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_NO_PADDING = (int)16;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_AMV = (int)32;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_AC_VLC = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_QPEL_CHROMA = (int)64;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_STD_QPEL = (int)128;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_QPEL_CHROMA2 = (int)256;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_DIRECT_BLOCKSIZE = (int)512;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_EDGE = (int)1024;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_HPEL_CHROMA = (int)2048;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_DC_CLIP = (int)4096;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_MS = (int)8192;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_TRUNCATED = (int)16384;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_BUG_IEDGE = (int)32768;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_COMPLIANCE_VERY_STRICT = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_COMPLIANCE_STRICT = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_COMPLIANCE_NORMAL = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_COMPLIANCE_UNOFFICIAL = (int)-1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_COMPLIANCE_EXPERIMENTAL = (int)-2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_EC_GUESS_MVS = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_EC_DEBLOCK = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_EC_FAVOR_INTER = (int)256;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_PICT_INFO = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_RC = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_BITSTREAM = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_MB_TYPE = (int)8;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_QP = (int)16;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_MV = (int)32;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_DCT_COEFF = (int)0x00000040;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_SKIP = (int)0x00000080;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_STARTCODE = (int)0x00000100;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_PTS = (int)0x00000200;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_ER = (int)0x00000400;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_MMCO = (int)0x00000800;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_BUGS = (int)0x00001000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_VIS_QP = (int)0x00002000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MB_TYPE = (int)0x00004000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_BUFFERS = (int)0x00008000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_THREADS = (int)0x00010000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_GREEN_MD = (int)0x00800000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_NOMC = (int)0x01000000;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MV_P_FOR = (int)0x00000001;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MV_B_FOR = (int)0x00000002;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MV_B_BACK = (int)0x00000004;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_EF_CRCCHECK = (int)(1 << 0);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_EF_BITSTREAM = (int)(1 << 1);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_EF_BUFFER = (int)(1 << 2);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_EF_EXPLODE = (int)(1 << 3);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_EF_IGNORE_ERR = (int)(1 << 15);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_EF_CAREFUL = (int)(1 << 16);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_EF_COMPLIANT = (int)(1 << 17);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_EF_AGGRESSIVE = (int)(1 << 18);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DCT_AUTO = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DCT_FASTINT = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DCT_INT = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DCT_MMX = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DCT_ALTIVEC = (int)5;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_DCT_FAAN = (int)6;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_AUTO = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_INT = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_SIMPLE = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEMMX = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_ARM = (int)7;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_ALTIVEC = (int)8;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_SH4 = (int)9;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEARM = (int)10;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_IPP = (int)13;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_XVID = (int)14;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_XVIDMMX = (int)14;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEARMV5TE = (int)16;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEARMV6 = (int)17;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEVIS = (int)18;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_FAAN = (int)20;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_SIMPLENEON = (int)22;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEALPHA = (int)23;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEAUTO = (int)128;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_THREAD_FRAME = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_THREAD_SLICE = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_UNKNOWN = (int)-99;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_RESERVED = (int)-100;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_AAC_MAIN = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_AAC_LOW = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_AAC_SSR = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_AAC_LTP = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_AAC_HE = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_AAC_HE_V2 = (int)28;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_AAC_LD = (int)22;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_AAC_ELD = (int)38;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_AAC_LOW = (int)128;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_AAC_HE = (int)131;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DNXHD = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DNXHR_LB = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DNXHR_SQ = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DNXHR_HQ = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DNXHR_HQX = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DNXHR_444 = (int)5;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DTS = (int)20;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DTS_ES = (int)30;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DTS_96_24 = (int)40;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DTS_HD_HRA = (int)50;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DTS_HD_MA = (int)60;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_DTS_EXPRESS = (int)70;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_422 = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_HIGH = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_SS = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_SNR_SCALABLE = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_MAIN = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_SIMPLE = (int)5;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_CONSTRAINED = (int)(1 << 9);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_INTRA = (int)(1 << 11);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_BASELINE = (int)66;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_CONSTRAINED_BASELINE = (int)(66 | (1 << 9));
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_MAIN = (int)77;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_EXTENDED = (int)88;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH = (int)100;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_10 = (int)110;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_10_INTRA = (int)(110 | (1 << 11));
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_MULTIVIEW_HIGH = (int)118;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_422 = (int)122;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_422_INTRA = (int)(122 | (1 << 11));
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_STEREO_HIGH = (int)128;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_444 = (int)144;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_444_PREDICTIVE = (int)244;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_444_INTRA = (int)(244 | (1 << 11));
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_H264_CAVLC_444 = (int)44;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_VC1_SIMPLE = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_VC1_MAIN = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_VC1_COMPLEX = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_VC1_ADVANCED = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE_SCALABLE = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_CORE = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_MAIN = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_N_BIT = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SCALABLE_TEXTURE = (int)5;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = (int)6;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = (int)7;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_HYBRID = (int)8;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = (int)9;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_CORE_SCALABLE = (int)10;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_CODING = (int)11;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_CORE = (int)12;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = (int)13;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE_STUDIO = (int)14;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_SIMPLE = (int)15;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = (int)32768;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_JPEG2000_DCINEMA_2K = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_JPEG2000_DCINEMA_4K = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_VP9_0 = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_VP9_1 = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_VP9_2 = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_VP9_3 = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_HEVC_MAIN = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_HEVC_MAIN_10 = (int)2;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_HEVC_MAIN_STILL_PICTURE = (int)3;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_PROFILE_HEVC_REXT = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_LEVEL_UNKNOWN = (int)-99;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_SUB_CHARENC_MODE_DO_NOTHING = (int)-1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_SUB_CHARENC_MODE_AUTOMATIC = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_SUB_CHARENC_MODE_PRE_DECODER = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CODEC_PROPERTY_LOSSLESS = (int)0x00000001;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_CODEC_PROPERTY_CLOSED_CAPTIONS = (int)0x00000002;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_SUB_TEXT_FMT_ASS = (int)0;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS = (int)1;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_HWACCEL_FLAG_IGNORE_LEVEL = (int)(1 << 0);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH = (int)(1 << 1);
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_SUBTITLE_FLAG_FORCED = (int)0x00000001;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int AV_PARSER_PTS_NB = (int)4;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int PARSER_FLAG_COMPLETE_FRAMES = (int)0x0001;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int PARSER_FLAG_ONCE = (int)0x0002;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int PARSER_FLAG_FETCHED_OFFSET = (int)0x0004;
	/** <i>native declaration : .\libavcodec\avcodec.h</i> */
	public static final int PARSER_FLAG_USE_CODEC_TS = (int)0x1000;
	/** <i>native declaration : .\libavcodec\avcodec.h:2819</i> */
	public interface avcodec_default_execute_func_callback extends Callback {
		int apply(AVCodecContext c2, Pointer arg2);
	};
	/** <i>native declaration : .\libavcodec\avcodec.h:2820</i> */
	public interface avcodec_default_execute2_func_callback extends Callback {
		int apply(AVCodecContext c2, Pointer arg2, int int1, int int2);
	};
	/**
	 * Original signature : <code>AVRational av_codec_get_pkt_timebase(const AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:939</i>
	 */
	ByValue av_codec_get_pkt_timebase(AVCodecContext avctx);
	/**
	 * Original signature : <code>void av_codec_set_pkt_timebase(AVCodecContext*, AVRational)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:941</i>
	 */
	void av_codec_set_pkt_timebase(AVCodecContext avctx, ByValue val);
	/**
	 * Original signature : <code>AVCodecDescriptor* av_codec_get_codec_descriptor(const AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:943</i>
	 */
	AVCodecDescriptor av_codec_get_codec_descriptor(AVCodecContext avctx);
	/**
	 * Original signature : <code>void av_codec_set_codec_descriptor(AVCodecContext*, const AVCodecDescriptor*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:945</i>
	 */
	void av_codec_set_codec_descriptor(AVCodecContext avctx, AVCodecDescriptor desc);
	/**
	 * Original signature : <code>int av_codec_get_codec_properties(const AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:947</i>
	 */
	int av_codec_get_codec_properties(AVCodecContext avctx);
	/**
	 * Original signature : <code>int av_codec_get_lowres(const AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:949</i>
	 */
	int av_codec_get_lowres(AVCodecContext avctx);
	/**
	 * Original signature : <code>void av_codec_set_lowres(AVCodecContext*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:951</i>
	 */
	void av_codec_set_lowres(AVCodecContext avctx, int val);
	/**
	 * Original signature : <code>int av_codec_get_seek_preroll(const AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:953</i>
	 */
	int av_codec_get_seek_preroll(AVCodecContext avctx);
	/**
	 * Original signature : <code>void av_codec_set_seek_preroll(AVCodecContext*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:955</i>
	 */
	void av_codec_set_seek_preroll(AVCodecContext avctx, int val);
	/**
	 * Original signature : <code>uint16_t* av_codec_get_chroma_intra_matrix(const AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:957</i>
	 */
	ShortByReference av_codec_get_chroma_intra_matrix(AVCodecContext avctx);
	/**
	 * Original signature : <code>void av_codec_set_chroma_intra_matrix(AVCodecContext*, uint16_t*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:959</i><br>
	 * @deprecated use the safer methods {@link #av_codec_set_chroma_intra_matrix(org.ffmpeg.avcodec57.AVCodecContext, ShortBuffer)} and {@link #av_codec_set_chroma_intra_matrix(org.ffmpeg.avcodec57.AVCodecContext, ShortByReference)} instead
	 */
	@Deprecated 
	void av_codec_set_chroma_intra_matrix(AVCodecContext avctx, ShortByReference val);
	/**
	 * Original signature : <code>void av_codec_set_chroma_intra_matrix(AVCodecContext*, uint16_t*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:959</i>
	 */
	void av_codec_set_chroma_intra_matrix(AVCodecContext avctx, ShortBuffer val);
	/**
	 * Original signature : <code>int av_codec_get_max_lowres(const AVCodec*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1033</i>
	 */
	int av_codec_get_max_lowres(AVCodec codec);
	/**
	 * If c is NULL, returns the first registered codec,<br>
	 * if c is non-NULL, returns the next registered codec after c,<br>
	 * or NULL if c is the last one.<br>
	 * Original signature : <code>AVCodec* av_codec_next(const AVCodec*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1180</i>
	 */
	AVCodec av_codec_next(AVCodec c);
	/**
	 * Return the LIBAVCODEC_VERSION_INT constant.<br>
	 * Original signature : <code>int avcodec_version()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1185</i>
	 */
	int avcodec_version();
	/**
	 * Return the libavcodec build-time configuration.<br>
	 * Original signature : <code>char* avcodec_configuration()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1190</i>
	 */
	String avcodec_configuration();
	/**
	 * Return the libavcodec license.<br>
	 * Original signature : <code>char* avcodec_license()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1195</i>
	 */
	String avcodec_license();
	/**
	 * Register the codec codec and initialize libavcodec.<br>
	 * @warning either this function or avcodec_register_all() must be called<br>
	 * before any other libavcodec functions.<br>
	 * @see avcodec_register_all()<br>
	 * Original signature : <code>void avcodec_register(AVCodec*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1203</i>
	 */
	void avcodec_register(AVCodec codec);
	/**
	 * Register all the codecs, parsers and bitstream filters which were enabled at<br>
	 * configuration time. If you do not call this function you can select exactly<br>
	 * which formats you want to support, by using the individual registration<br>
	 * functions.<br>
	 * @see avcodec_register<br>
	 * @see av_register_codec_parser<br>
	 * @see av_register_bitstream_filter<br>
	 * Original signature : <code>void avcodec_register_all()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1214</i>
	 */
	void avcodec_register_all();
	/**
	 * Allocate an AVCodecContext and set its fields to default values. The<br>
	 * resulting struct should be freed with avcodec_free_context().<br>
	 * @param codec if non-NULL, allocate private data and initialize defaults<br>
	 *              for the given codec. It is illegal to then call avcodec_open2()<br>
	 *              with a different codec.<br>
	 *              If NULL, then the codec-specific defaults won't be initialized,<br>
	 *              which may result in suboptimal default settings (this is<br>
	 *              important mainly for encoders, e.g. libx264).<br>
	 * @return An AVCodecContext filled with default values or NULL on failure.<br>
	 * Original signature : <code>AVCodecContext* avcodec_alloc_context3(const AVCodec*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1227</i>
	 */
	AVCodecContext avcodec_alloc_context3(AVCodec codec);
	/**
	 * Free the codec context and everything associated with it and write NULL to<br>
	 * the provided pointer.<br>
	 * Original signature : <code>void avcodec_free_context(AVCodecContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1233</i><br>
	 * @deprecated use the safer method {@link #avcodec_free_context(org.ffmpeg.avcodec57.AVCodecContext.ByReference[])} instead
	 */
	@Deprecated 
	void avcodec_free_context(PointerByReference avctx);
	/**
	 * Free the codec context and everything associated with it and write NULL to<br>
	 * the provided pointer.<br>
	 * Original signature : <code>void avcodec_free_context(AVCodecContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1233</i>
	 */
	void avcodec_free_context(AVCodecContext.ByReference avctx[]);
	/**
	 * @deprecated This function should not be used, as closing and opening a codec<br>
	 * context multiple time is not supported. A new codec context should be<br>
	 * allocated for each new use.<br>
	 * Original signature : <code>int avcodec_get_context_defaults3(AVCodecContext*, const AVCodec*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1240</i>
	 */
	int avcodec_get_context_defaults3(AVCodecContext s, AVCodec codec);
	/**
	 * Get the Pointer for AVCodecContext. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * @see av_opt_find().<br>
	 * Original signature : <code>Pointer* avcodec_get_class()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1247</i>
	 */
	Pointer avcodec_get_class();
	/**
	 * Get the Pointer for AVFrame. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * @see av_opt_find().<br>
	 * Original signature : <code>Pointer* avcodec_get_frame_class()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1254</i>
	 */
	Pointer avcodec_get_frame_class();
	/**
	 * Get the Pointer for AVSubtitleRect. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * @see av_opt_find().<br>
	 * Original signature : <code>Pointer* avcodec_get_subtitle_rect_class()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1261</i>
	 */
	Pointer avcodec_get_subtitle_rect_class();
	/**
	 * Copy the settings of the source AVCodecContext into the destination<br>
	 * AVCodecContext. The resulting destination codec context will be<br>
	 * unopened, i.e. you are required to call avcodec_open2() before you<br>
	 * can use this AVCodecContext to decode/encode video/audio data.<br>
	 * @param dest target codec context, should be initialized with<br>
	 *             avcodec_alloc_context3(NULL), but otherwise uninitialized<br>
	 * @param src source codec context<br>
	 * @return AVERROR() on error (e.g. memory allocation error), 0 on success<br>
	 * @deprecated The semantics of this function are ill-defined and it should not<br>
	 * be used. If you need to transfer the stream parameters from one codec context<br>
	 * to another, use an intermediate AVCodecParameters instance and the<br>
	 * avcodec_parameters_from_context() / avcodec_parameters_to_context()<br>
	 * functions.<br>
	 * Original signature : <code>int avcodec_copy_context(AVCodecContext*, const AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1278</i>
	 */
	int avcodec_copy_context(AVCodecContext dest, AVCodecContext src);
	/**
	 * Allocate a new AVCodecParameters and set its fields to default values<br>
	 * (unknown/invalid/0). The returned struct must be freed with<br>
	 * avcodec_parameters_free().<br>
	 * Original signature : <code>AVCodecParameters* avcodec_parameters_alloc()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1285</i>
	 */
	AVCodecParameters avcodec_parameters_alloc();
	/**
	 * Free an AVCodecParameters instance and everything associated with it and<br>
	 * write NULL to the supplied pointer.<br>
	 * Original signature : <code>void avcodec_parameters_free(AVCodecParameters**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1291</i><br>
	 * @deprecated use the safer method {@link #avcodec_parameters_free(org.ffmpeg.avcodec57.AVCodecParameters.ByReference[])} instead
	 */
	@Deprecated 
	void avcodec_parameters_free(PointerByReference par);
	/**
	 * Free an AVCodecParameters instance and everything associated with it and<br>
	 * write NULL to the supplied pointer.<br>
	 * Original signature : <code>void avcodec_parameters_free(AVCodecParameters**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1291</i>
	 */
	void avcodec_parameters_free(AVCodecParameters.ByReference par[]);
	/**
	 * Copy the contents of src to dst. Any allocated fields in dst are freed and<br>
	 * replaced with newly allocated duplicates of the corresponding fields in src.<br>
	 * @return >= 0 on success, a negative AVERROR code on failure.<br>
	 * Original signature : <code>int avcodec_parameters_copy(AVCodecParameters*, const AVCodecParameters*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1298</i>
	 */
	int avcodec_parameters_copy(AVCodecParameters dst, AVCodecParameters src);
	/**
	 * Fill the parameters struct based on the values from the supplied codec<br>
	 * context. Any allocated fields in par are freed and replaced with duplicates<br>
	 * of the corresponding fields in codec.<br>
	 * @return >= 0 on success, a negative AVERROR code on failure<br>
	 * Original signature : <code>int avcodec_parameters_from_context(AVCodecParameters*, const AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1306</i>
	 */
	int avcodec_parameters_from_context(AVCodecParameters par, AVCodecContext codec);
	/**
	 * Fill the codec context based on the values from the supplied codec<br>
	 * parameters. Any allocated fields in codec that have a corresponding field in<br>
	 * par are freed and replaced with duplicates of the corresponding field in par.<br>
	 * Fields in codec that do not have a counterpart in par are not touched.<br>
	 * @return >= 0 on success, a negative AVERROR code on failure.<br>
	 * Original signature : <code>int avcodec_parameters_to_context(AVCodecContext*, const AVCodecParameters*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1315</i>
	 */
	int avcodec_parameters_to_context(AVCodecContext codec, AVCodecParameters par);
	/**
	 * Initialize the AVCodecContext to use the given AVCodec. Prior to using this<br>
	 * function the context has to be allocated with avcodec_alloc_context3().<br>
	 * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),<br>
	 * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for<br>
	 * retrieving a codec.<br>
	 * @warning This function is not thread safe!<br>
	 * @note Always call this function before using decoding routines (such as<br>
	 * @ref avcodec_receive_frame()).<br>
	 * @code<br>
	 * avcodec_register_all();<br>
	 * av_dict_set(&opts, "b", "2.5M", 0);<br>
	 * codec = avcodec_find_decoder(AV_CODEC_ID_H264);<br>
	 * if (!codec)<br>
	 *     exit(1);<br>
	 * context = avcodec_alloc_context3(codec);<br>
	 * if (avcodec_open2(context, codec, opts) < 0)<br>
	 *     exit(1);<br>
	 * @endcode<br>
	 * @param avctx The context to initialize.<br>
	 * @param codec The codec to open this context for. If a non-NULL codec has been<br>
	 *              previously passed to avcodec_alloc_context3() or<br>
	 *              for this context, then this parameter MUST be either NULL or<br>
	 *              equal to the previously passed codec.<br>
	 * @param options A dictionary filled with AVCodecContext and codec-private options.<br>
	 *                On return this object will be filled with options that were not found.<br>
	 * @return zero on success, a negative value on error<br>
	 * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),<br>
	 *      av_dict_set(), av_opt_find().<br>
	 * Original signature : <code>int avcodec_open2(AVCodecContext*, const AVCodec*, AVDictionary**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1347</i><br>
	 * @deprecated use the safer method {@link #avcodec_open2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.AVCodec, org.ffmpeg.avutil55.AVDictionary.ByReference[])} instead
	 */
	@Deprecated 
	int avcodec_open2(AVCodecContext avctx, AVCodec codec, PointerByReference options);
	/**
	 * Initialize the AVCodecContext to use the given AVCodec. Prior to using this<br>
	 * function the context has to be allocated with avcodec_alloc_context3().<br>
	 * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),<br>
	 * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for<br>
	 * retrieving a codec.<br>
	 * @warning This function is not thread safe!<br>
	 * @note Always call this function before using decoding routines (such as<br>
	 * @ref avcodec_receive_frame()).<br>
	 * @code<br>
	 * avcodec_register_all();<br>
	 * av_dict_set(&opts, "b", "2.5M", 0);<br>
	 * codec = avcodec_find_decoder(AV_CODEC_ID_H264);<br>
	 * if (!codec)<br>
	 *     exit(1);<br>
	 * context = avcodec_alloc_context3(codec);<br>
	 * if (avcodec_open2(context, codec, opts) < 0)<br>
	 *     exit(1);<br>
	 * @endcode<br>
	 * @param avctx The context to initialize.<br>
	 * @param codec The codec to open this context for. If a non-NULL codec has been<br>
	 *              previously passed to avcodec_alloc_context3() or<br>
	 *              for this context, then this parameter MUST be either NULL or<br>
	 *              equal to the previously passed codec.<br>
	 * @param options A dictionary filled with AVCodecContext and codec-private options.<br>
	 *                On return this object will be filled with options that were not found.<br>
	 * @return zero on success, a negative value on error<br>
	 * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),<br>
	 *      av_dict_set(), av_opt_find().<br>
	 * Original signature : <code>int avcodec_open2(AVCodecContext*, const AVCodec*, AVDictionary**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1347</i>
	 */
	int avcodec_open2(AVCodecContext avctx, AVCodec codec, AVDictionary.ByReference options[]);
	/**
	 * Close a given AVCodecContext and free all the data associated with it<br>
	 * (but not the AVCodecContext itself).<br>
	 * Calling this function on an AVCodecContext that hasn't been opened will free<br>
	 * the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL<br>
	 * codec. Subsequent calls will do nothing.<br>
	 * @note Do not use this function. Use avcodec_free_context() to destroy a<br>
	 * codec context (either open or closed). Opening and closing a codec context<br>
	 * multiple times is not supported anymore -- use multiple codec contexts<br>
	 * instead.<br>
	 * Original signature : <code>int avcodec_close(AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1360</i>
	 */
	int avcodec_close(AVCodecContext avctx);
	/**
	 * Free all allocated data in the given subtitle struct.<br>
	 * @param sub AVSubtitle to free.<br>
	 * Original signature : <code>void avsubtitle_free(AVSubtitle*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1366</i>
	 */
	void avsubtitle_free(AVSubtitle sub);
	/**
	 * Allocate an AVPacket and set its fields to default values.  The resulting<br>
	 * struct must be freed using av_packet_free().<br>
	 * @return An AVPacket filled with default values or NULL on failure.<br>
	 * @note this only allocates the AVPacket itself, not the data buffers. Those<br>
	 * must be allocated through other means such as av_new_packet.<br>
	 * @see av_new_packet<br>
	 * Original signature : <code>AVPacket* av_packet_alloc()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1376</i>
	 */
	AVPacket av_packet_alloc();
	/**
	 * Create a new packet that references the same data as src.<br>
	 * This is a shortcut for av_packet_alloc()+av_packet_ref().<br>
	 * @return newly created AVPacket on success, NULL on error.<br>
	 * @see av_packet_alloc<br>
	 * @see av_packet_ref<br>
	 * Original signature : <code>AVPacket* av_packet_clone(const AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1385</i>
	 */
	AVPacket av_packet_clone(AVPacket src);
	/**
	 * Free the packet, if the packet is reference counted, it will be<br>
	 * unreferenced first.<br>
	 * @param packet packet to be freed. The pointer will be set to NULL.<br>
	 * @note passing NULL is a no-op.<br>
	 * Original signature : <code>void av_packet_free(AVPacket**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1393</i><br>
	 * @deprecated use the safer method {@link #av_packet_free(org.ffmpeg.avcodec57.AVPacket.ByReference[])} instead
	 */
	@Deprecated 
	void av_packet_free(PointerByReference pkt);
	/**
	 * Free the packet, if the packet is reference counted, it will be<br>
	 * unreferenced first.<br>
	 * @param packet packet to be freed. The pointer will be set to NULL.<br>
	 * @note passing NULL is a no-op.<br>
	 * Original signature : <code>void av_packet_free(AVPacket**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1393</i>
	 */
	void av_packet_free(AVPacket.ByReference pkt[]);
	/**
	 * Initialize optional fields of a packet with default values.<br>
	 * Note, this does not touch the data and size members, which have to be<br>
	 * initialized separately.<br>
	 * @param pkt packet<br>
	 * Original signature : <code>void av_init_packet(AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1401</i>
	 */
	void av_init_packet(AVPacket pkt);
	/**
	 * Allocate the payload of a packet and initialize its fields with<br>
	 * default values.<br>
	 * @param pkt packet<br>
	 * @param size wanted payload size<br>
	 * @return 0 if OK, AVERROR_xxx otherwise<br>
	 * Original signature : <code>int av_new_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1410</i>
	 */
	int av_new_packet(AVPacket pkt, int size);
	/**
	 * Reduce packet size, correctly zeroing padding<br>
	 * @param pkt packet<br>
	 * @param size new size<br>
	 * Original signature : <code>void av_shrink_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1417</i>
	 */
	void av_shrink_packet(AVPacket pkt, int size);
	/**
	 * Increase packet size, correctly zeroing padding<br>
	 * @param pkt packet<br>
	 * @param grow_by number of bytes by which to increase the size of the packet<br>
	 * Original signature : <code>int av_grow_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1424</i>
	 */
	int av_grow_packet(AVPacket pkt, int grow_by);
	/**
	 * Initialize a reference-counted packet from av_malloc()ed data.<br>
	 * @param pkt packet to be initialized. This function will set the data, size,<br>
	 *        buf and destruct fields, all others are left untouched.<br>
	 * @param data Data allocated by av_malloc() to be used as packet data. If this<br>
	 *        function returns successfully, the data is owned by the underlying AVBuffer.<br>
	 *        The caller may not access the data through other means.<br>
	 * @param size size of data in bytes, without the padding. I.e. the full buffer<br>
	 *        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.<br>
	 * @return 0 on success, a negative AVERROR on error<br>
	 * Original signature : <code>int av_packet_from_data(AVPacket*, uint8_t*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1437</i><br>
	 * @deprecated use the safer methods {@link #av_packet_from_data(org.ffmpeg.avcodec57.AVPacket, ByteBuffer, int)} and {@link #av_packet_from_data(org.ffmpeg.avcodec57.AVPacket, Pointer, int)} instead
	 */
	@Deprecated 
	int av_packet_from_data(AVPacket pkt, Pointer data, int size);
	/**
	 * Initialize a reference-counted packet from av_malloc()ed data.<br>
	 * @param pkt packet to be initialized. This function will set the data, size,<br>
	 *        buf and destruct fields, all others are left untouched.<br>
	 * @param data Data allocated by av_malloc() to be used as packet data. If this<br>
	 *        function returns successfully, the data is owned by the underlying AVBuffer.<br>
	 *        The caller may not access the data through other means.<br>
	 * @param size size of data in bytes, without the padding. I.e. the full buffer<br>
	 *        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.<br>
	 * @return 0 on success, a negative AVERROR on error<br>
	 * Original signature : <code>int av_packet_from_data(AVPacket*, uint8_t*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1437</i>
	 */
	int av_packet_from_data(AVPacket pkt, ByteBuffer data, int size);
	/**
	 * @warning This is a hack - the packet memory allocation stuff is broken. The<br>
	 * packet is allocated if it was not really allocated.<br>
	 * @deprecated Use av_packet_ref<br>
	 * Original signature : <code>int av_dup_packet(AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1444</i>
	 */
	int av_dup_packet(AVPacket pkt);
	/**
	 * Copy packet, including contents<br>
	 * @return 0 on success, negative AVERROR on fail<br>
	 * Original signature : <code>int av_copy_packet(AVPacket*, const AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1450</i>
	 */
	int av_copy_packet(AVPacket dst, AVPacket src);
	/**
	 * Copy packet side data<br>
	 * @return 0 on success, negative AVERROR on fail<br>
	 * Original signature : <code>int av_copy_packet_side_data(AVPacket*, const AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1456</i>
	 */
	int av_copy_packet_side_data(AVPacket dst, AVPacket src);
	/**
	 * Free a packet.<br>
	 * @deprecated Use av_packet_unref<br>
	 * @param pkt packet to free<br>
	 * Original signature : <code>void av_free_packet(AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1463</i>
	 */
	void av_free_packet(AVPacket pkt);
	/**
	 * Allocate new information of a packet.<br>
	 * @param pkt packet<br>
	 * @param type side information type<br>
	 * @param size side information size<br>
	 * @return pointer to fresh allocated data or NULL otherwise<br>
	 * Original signature : <code>uint8_t* av_packet_new_side_data(AVPacket*, AVPacketSideDataType, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1472</i>
	 */
	Pointer av_packet_new_side_data(AVPacket pkt, int type, int size);
	/**
	 * Wrap an existing array as a packet side data.<br>
	 * @param pkt packet<br>
	 * @param type side information type<br>
	 * @param data the side data array. It must be allocated with the av_malloc()<br>
	 *             family of functions. The ownership of the data is transferred to<br>
	 *             pkt.<br>
	 * @param size side information size<br>
	 * @return a non-negative number on success, a negative AVERROR code on<br>
	 *         failure. On failure, the packet is unchanged and the data remains<br>
	 *         owned by the caller.<br>
	 * Original signature : <code>int av_packet_add_side_data(AVPacket*, AVPacketSideDataType, uint8_t*, size_t)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1486</i><br>
	 * @deprecated use the safer methods {@link #av_packet_add_side_data(org.ffmpeg.avcodec57.AVPacket, int, ByteBuffer, NativeSize)} and {@link #av_packet_add_side_data(org.ffmpeg.avcodec57.AVPacket, int, Pointer, NativeSize)} instead
	 */
	@Deprecated 
	int av_packet_add_side_data(AVPacket pkt, int type, Pointer data, NativeSize size);
	/**
	 * Wrap an existing array as a packet side data.<br>
	 * @param pkt packet<br>
	 * @param type side information type<br>
	 * @param data the side data array. It must be allocated with the av_malloc()<br>
	 *             family of functions. The ownership of the data is transferred to<br>
	 *             pkt.<br>
	 * @param size side information size<br>
	 * @return a non-negative number on success, a negative AVERROR code on<br>
	 *         failure. On failure, the packet is unchanged and the data remains<br>
	 *         owned by the caller.<br>
	 * Original signature : <code>int av_packet_add_side_data(AVPacket*, AVPacketSideDataType, uint8_t*, size_t)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1486</i>
	 */
	int av_packet_add_side_data(AVPacket pkt, int type, ByteBuffer data, NativeSize size);
	/**
	 * Shrink the already allocated side data buffer<br>
	 * @param pkt packet<br>
	 * @param type side information type<br>
	 * @param size new side information size<br>
	 * @return 0 on success, < 0 on failure<br>
	 * Original signature : <code>int av_packet_shrink_side_data(AVPacket*, AVPacketSideDataType, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1495</i>
	 */
	int av_packet_shrink_side_data(AVPacket pkt, int type, int size);
	/**
	 * Get side information from packet.<br>
	 * @param pkt packet<br>
	 * @param type desired side information type<br>
	 * @param size pointer for side information size to store (optional)<br>
	 * @return pointer to data if present or NULL otherwise<br>
	 * Original signature : <code>uint8_t* av_packet_get_side_data(const AVPacket*, AVPacketSideDataType, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1504</i><br>
	 * @deprecated use the safer methods {@link #av_packet_get_side_data(org.ffmpeg.avcodec57.AVPacket, int, IntBuffer)} and {@link #av_packet_get_side_data(org.ffmpeg.avcodec57.AVPacket, int, IntByReference)} instead
	 */
	@Deprecated 
	Pointer av_packet_get_side_data(AVPacket pkt, int type, IntByReference size);
	/**
	 * Get side information from packet.<br>
	 * @param pkt packet<br>
	 * @param type desired side information type<br>
	 * @param size pointer for side information size to store (optional)<br>
	 * @return pointer to data if present or NULL otherwise<br>
	 * Original signature : <code>uint8_t* av_packet_get_side_data(const AVPacket*, AVPacketSideDataType, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1504</i>
	 */
	Pointer av_packet_get_side_data(AVPacket pkt, int type, IntBuffer size);
	/**
	 * Original signature : <code>int av_packet_merge_side_data(AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1506</i>
	 */
	int av_packet_merge_side_data(AVPacket pkt);
	/**
	 * Original signature : <code>int av_packet_split_side_data(AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1508</i>
	 */
	int av_packet_split_side_data(AVPacket pkt);
	/**
	 * Original signature : <code>char* av_packet_side_data_name(AVPacketSideDataType)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1510</i>
	 */
	String av_packet_side_data_name(int type);
	/**
	 * Pack a dictionary for use in side_data.<br>
	 * @param dict The dictionary to pack.<br>
	 * @param size pointer to store the size of the returned data<br>
	 * @return pointer to data if successful, NULL otherwise<br>
	 * Original signature : <code>uint8_t* av_packet_pack_dictionary(AVDictionary*, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1518</i><br>
	 * @deprecated use the safer methods {@link #av_packet_pack_dictionary(org.ffmpeg.avutil55.AVDictionary, IntBuffer)} and {@link #av_packet_pack_dictionary(org.ffmpeg.avutil55.AVDictionary, IntByReference)} instead
	 */
	@Deprecated 
	Pointer av_packet_pack_dictionary(AVDictionary dict, IntByReference size);
	/**
	 * Pack a dictionary for use in side_data.<br>
	 * @param dict The dictionary to pack.<br>
	 * @param size pointer to store the size of the returned data<br>
	 * @return pointer to data if successful, NULL otherwise<br>
	 * Original signature : <code>uint8_t* av_packet_pack_dictionary(AVDictionary*, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1518</i>
	 */
	Pointer av_packet_pack_dictionary(AVDictionary dict, IntBuffer size);
	/**
	 * Unpack a dictionary from side_data.<br>
	 * @param data data from side_data<br>
	 * @param size size of the data<br>
	 * @param dict the metadata storage dictionary<br>
	 * @return 0 on success, < 0 on failure<br>
	 * Original signature : <code>int av_packet_unpack_dictionary(const uint8_t*, int, AVDictionary**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1527</i><br>
	 * @deprecated use the safer methods {@link #av_packet_unpack_dictionary(byte[], int, org.ffmpeg.avutil55.AVDictionary.ByReference[])} and {@link #av_packet_unpack_dictionary(Pointer, int, org.ffmpeg.avutil55.AVDictionary.ByReference[])} instead
	 */
	@Deprecated 
	int av_packet_unpack_dictionary(Pointer data, int size, PointerByReference dict);
	/**
	 * Unpack a dictionary from side_data.<br>
	 * @param data data from side_data<br>
	 * @param size size of the data<br>
	 * @param dict the metadata storage dictionary<br>
	 * @return 0 on success, < 0 on failure<br>
	 * Original signature : <code>int av_packet_unpack_dictionary(const uint8_t*, int, AVDictionary**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1527</i>
	 */
	int av_packet_unpack_dictionary(byte data[], int size, AVDictionary.ByReference dict[]);
	/**
	 * Unpack a dictionary from side_data.<br>
	 * @param data data from side_data<br>
	 * @param size size of the data<br>
	 * @param dict the metadata storage dictionary<br>
	 * @return 0 on success, < 0 on failure<br>
	 * Original signature : <code>int av_packet_unpack_dictionary(const uint8_t*, int, AVDictionary**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1527</i>
	 */
	int av_packet_unpack_dictionary(Pointer data, int size, AVDictionary.ByReference dict[]);
	/**
	 * Convenience function to free all the side data stored.<br>
	 * All the other fields stay untouched.<br>
	 * @param pkt packet<br>
	 * Original signature : <code>void av_packet_free_side_data(AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1534</i>
	 */
	void av_packet_free_side_data(AVPacket pkt);
	/**
	 * Setup a new reference to the data described by a given packet<br>
	 * If src is reference-counted, setup dst as a new reference to the<br>
	 * buffer in src. Otherwise allocate a new buffer in dst and copy the<br>
	 * data from src into it.<br>
	 * All the other fields are copied from src.<br>
	 * @see av_packet_unref<br>
	 * @param dst Destination packet<br>
	 * @param src Source packet<br>
	 * @return 0 on success, a negative AVERROR on error.<br>
	 * Original signature : <code>int av_packet_ref(AVPacket*, const AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1547</i>
	 */
	int av_packet_ref(AVPacket dst, AVPacket src);
	/**
	 * Wipe the packet.<br>
	 * Unreference the buffer referenced by the packet and reset the<br>
	 * remaining packet fields to their default values.<br>
	 * @param pkt The packet to be unreferenced.<br>
	 * Original signature : <code>void av_packet_unref(AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1555</i>
	 */
	void av_packet_unref(AVPacket pkt);
	/**
	 * Move every field in src to dst and reset src.<br>
	 * @see av_packet_unref<br>
	 * @param src Source packet, will be reset<br>
	 * @param dst Destination packet<br>
	 * Original signature : <code>void av_packet_move_ref(AVPacket*, AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1563</i>
	 */
	void av_packet_move_ref(AVPacket dst, AVPacket src);
	/**
	 * Copy only "properties" fields from src to dst.<br>
	 * Properties for the purpose of this function are all the fields<br>
	 * beside those related to the packet data (buf, data, size)<br>
	 * @param dst Destination packet<br>
	 * @param src Source packet<br>
	 * @return 0 on success AVERROR on failure.<br>
	 * Original signature : <code>int av_packet_copy_props(AVPacket*, const AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1573</i>
	 */
	int av_packet_copy_props(AVPacket dst, AVPacket src);
	/**
	 * Convert valid timing fields (timestamps / durations) in a packet from one<br>
	 * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be<br>
	 * ignored.<br>
	 * @param pkt packet on which the conversion will be performed<br>
	 * @param tb_src source timebase, in which the timing fields in pkt are<br>
	 *               expressed<br>
	 * @param tb_dst destination timebase, to which the timing fields will be<br>
	 *               converted<br>
	 * Original signature : <code>void av_packet_rescale_ts(AVPacket*, AVRational, AVRational)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1585</i>
	 */
	void av_packet_rescale_ts(AVPacket pkt, ByValue tb_src, ByValue tb_dst);
	/**
	 * Find a registered decoder with a matching codec ID.<br>
	 * @param id AVCodecID of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder(AVCodecID)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1592</i>
	 */
	AVCodec avcodec_find_decoder(int id);
	/**
	 * Find a registered decoder with the specified name.<br>
	 * @param name name of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder_by_name(const char*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1599</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_decoder_by_name(String)} and {@link #avcodec_find_decoder_by_name(Pointer)} instead
	 */
	@Deprecated 
	AVCodec avcodec_find_decoder_by_name(Pointer name);
	/**
	 * Find a registered decoder with the specified name.<br>
	 * @param name name of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder_by_name(const char*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1599</i>
	 */
	AVCodec avcodec_find_decoder_by_name(String name);
	/**
	 * The default callback for AVCodecContext.get_buffer2(). It is made public so<br>
	 * it can be called by custom get_buffer2() implementations for decoders without<br>
	 * AV_CODEC_CAP_DR1 set.<br>
	 * Original signature : <code>int avcodec_default_get_buffer2(AVCodecContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1606</i>
	 */
	int avcodec_default_get_buffer2(AVCodecContext s, AVFrame frame, int flags);
	/**
	 * Return the amount of padding in pixels which the get_buffer callback must<br>
	 * provide around the edge of the image for codecs which do not have the<br>
	 * CODEC_FLAG_EMU_EDGE flag.<br>
	 * @return Required padding in pixels.<br>
	 * @deprecated CODEC_FLAG_EMU_EDGE is deprecated, so this function is no longer<br>
	 * needed<br>
	 * Original signature : <code>int avcodec_get_edge_width()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1616</i>
	 */
	int avcodec_get_edge_width();
	/**
	 * Modify width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you do not use any horizontal<br>
	 * padding.<br>
	 * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.<br>
	 * Original signature : <code>void avcodec_align_dimensions(AVCodecContext*, int*, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1624</i><br>
	 * @deprecated use the safer methods {@link #avcodec_align_dimensions(org.ffmpeg.avcodec57.AVCodecContext, IntBuffer, IntBuffer)} and {@link #avcodec_align_dimensions(org.ffmpeg.avcodec57.AVCodecContext, IntByReference, IntByReference)} instead
	 */
	@Deprecated 
	void avcodec_align_dimensions(AVCodecContext s, IntByReference width, IntByReference height);
	/**
	 * Modify width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you do not use any horizontal<br>
	 * padding.<br>
	 * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.<br>
	 * Original signature : <code>void avcodec_align_dimensions(AVCodecContext*, int*, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1624</i>
	 */
	void avcodec_align_dimensions(AVCodecContext s, IntBuffer width, IntBuffer height);
	/**
	 * Modify width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you also ensure that all<br>
	 * line sizes are a multiple of the respective linesize_align[i].<br>
	 * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.<br>
	 * Original signature : <code>void avcodec_align_dimensions2(AVCodecContext*, int*, int*, int[8])</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1632</i><br>
	 * @deprecated use the safer methods {@link #avcodec_align_dimensions2(org.ffmpeg.avcodec57.AVCodecContext, IntBuffer, IntBuffer, IntBuffer)} and {@link #avcodec_align_dimensions2(org.ffmpeg.avcodec57.AVCodecContext, IntByReference, IntByReference, IntByReference)} instead
	 */
	@Deprecated 
	void avcodec_align_dimensions2(AVCodecContext s, IntByReference width, IntByReference height, IntByReference linesize_align);
	/**
	 * Modify width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you also ensure that all<br>
	 * line sizes are a multiple of the respective linesize_align[i].<br>
	 * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.<br>
	 * Original signature : <code>void avcodec_align_dimensions2(AVCodecContext*, int*, int*, int[8])</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1632</i>
	 */
	void avcodec_align_dimensions2(AVCodecContext s, IntBuffer width, IntBuffer height, IntBuffer linesize_align);
	/**
	 * Converts AVChromaLocation to swscale x/y chroma position.<br>
	 * The positions represent the chroma (0,0) position in a coordinates system<br>
	 * with luma (0,0) representing the origin and luma(1,1) representing 256,256<br>
	 * @param xpos  horizontal chroma sample position<br>
	 * @param ypos  vertical   chroma sample position<br>
	 * Original signature : <code>int avcodec_enum_to_chroma_pos(int*, int*, AVChromaLocation)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1641</i><br>
	 * @deprecated use the safer methods {@link #avcodec_enum_to_chroma_pos(IntBuffer, IntBuffer, int)} and {@link #avcodec_enum_to_chroma_pos(IntByReference, IntByReference, int)} instead
	 */
	@Deprecated 
	int avcodec_enum_to_chroma_pos(IntByReference xpos, IntByReference ypos, int pos);
	/**
	 * Converts AVChromaLocation to swscale x/y chroma position.<br>
	 * The positions represent the chroma (0,0) position in a coordinates system<br>
	 * with luma (0,0) representing the origin and luma(1,1) representing 256,256<br>
	 * @param xpos  horizontal chroma sample position<br>
	 * @param ypos  vertical   chroma sample position<br>
	 * Original signature : <code>int avcodec_enum_to_chroma_pos(int*, int*, AVChromaLocation)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1641</i>
	 */
	int avcodec_enum_to_chroma_pos(IntBuffer xpos, IntBuffer ypos, int pos);
	/**
	 * Converts swscale x/y chroma position to AVChromaLocation.<br>
	 * The positions represent the chroma (0,0) position in a coordinates system<br>
	 * with luma (0,0) representing the origin and luma(1,1) representing 256,256<br>
	 * @param xpos  horizontal chroma sample position<br>
	 * @param ypos  vertical   chroma sample position<br>
	 * Original signature : <code>AVChromaLocation avcodec_chroma_pos_to_enum(int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1650</i>
	 */
	int avcodec_chroma_pos_to_enum(int xpos, int ypos);
	/**
	 * Decode the audio frame of size avpkt->size from avpkt->data into frame.<br>
	 * Some decoders may support multiple frames in a single AVPacket. Such<br>
	 * decoders would then just decode the first frame and the return value would be<br>
	 * less than the packet size. In this case, avcodec_decode_audio4 has to be<br>
	 * called again with an AVPacket containing the remaining data in order to<br>
	 * decode the second frame, etc...  Even if no frames are returned, the packet<br>
	 * needs to be fed to the decoder with remaining data until it is completely<br>
	 * consumed or an error occurs.<br>
	 * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input<br>
	 * and output. This means that for some packets they will not immediately<br>
	 * produce decoded output and need to be flushed at the end of decoding to get<br>
	 * all the decoded data. Flushing is done by calling this function with packets<br>
	 * with avpkt->data set to NULL and avpkt->size set to 0 until it stops<br>
	 * returning samples. It is safe to flush even those decoders that are not<br>
	 * marked with AV_CODEC_CAP_DELAY, then no samples will be returned.<br>
	 * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE<br>
	 *          larger than the actual read bytes because some optimized bitstream<br>
	 *          readers read 32 or 64 bits at once and could read over the end.<br>
	 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
	 * before packets may be fed to the decoder.<br>
	 * @param      avctx the codec context<br>
	 * @param[out] frame The AVFrame in which to store decoded audio samples.<br>
	 *                   The decoder will allocate a buffer for the decoded frame by<br>
	 *                   calling the AVCodecContext.get_buffer2() callback.<br>
	 *                   When AVCodecContext.refcounted_frames is set to 1, the frame is<br>
	 *                   reference counted and the returned reference belongs to the<br>
	 *                   caller. The caller must release the frame using av_frame_unref()<br>
	 *                   when the frame is no longer needed. The caller may safely write<br>
	 *                   to the frame if av_frame_is_writable() returns 1.<br>
	 *                   When AVCodecContext.refcounted_frames is set to 0, the returned<br>
	 *                   reference belongs to the decoder and is valid only until the<br>
	 *                   next call to this function or until closing or flushing the<br>
	 *                   decoder. The caller may not write to it.<br>
	 * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is<br>
	 *                           non-zero. Note that this field being set to zero<br>
	 *                           does not mean that an error has occurred. For<br>
	 *                           decoders with AV_CODEC_CAP_DELAY set, no given decode<br>
	 *                           call is guaranteed to produce a frame.<br>
	 * @param[in]  avpkt The input AVPacket containing the input buffer.<br>
	 *                   At least avpkt->data and avpkt->size should be set. Some<br>
	 *                   decoders might also require additional fields to be set.<br>
	 * @return A negative error code is returned if an error occurred during<br>
	 *         decoding, otherwise the number of bytes consumed from the input<br>
	 *         AVPacket is returned.<br>
	 * @deprecated Use avcodec_send_packet() and avcodec_receive_frame().<br>
	 * Original signature : <code>int avcodec_decode_audio4(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1699</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_audio4(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avutil55.AVFrame, IntBuffer, org.ffmpeg.avcodec57.AVPacket)} and {@link #avcodec_decode_audio4(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avutil55.AVFrame, IntByReference, org.ffmpeg.avcodec57.AVPacket)} instead
	 */
	@Deprecated 
	int avcodec_decode_audio4(AVCodecContext avctx, AVFrame frame, IntByReference got_frame_ptr, AVPacket avpkt);
	/**
	 * Decode the audio frame of size avpkt->size from avpkt->data into frame.<br>
	 * Some decoders may support multiple frames in a single AVPacket. Such<br>
	 * decoders would then just decode the first frame and the return value would be<br>
	 * less than the packet size. In this case, avcodec_decode_audio4 has to be<br>
	 * called again with an AVPacket containing the remaining data in order to<br>
	 * decode the second frame, etc...  Even if no frames are returned, the packet<br>
	 * needs to be fed to the decoder with remaining data until it is completely<br>
	 * consumed or an error occurs.<br>
	 * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input<br>
	 * and output. This means that for some packets they will not immediately<br>
	 * produce decoded output and need to be flushed at the end of decoding to get<br>
	 * all the decoded data. Flushing is done by calling this function with packets<br>
	 * with avpkt->data set to NULL and avpkt->size set to 0 until it stops<br>
	 * returning samples. It is safe to flush even those decoders that are not<br>
	 * marked with AV_CODEC_CAP_DELAY, then no samples will be returned.<br>
	 * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE<br>
	 *          larger than the actual read bytes because some optimized bitstream<br>
	 *          readers read 32 or 64 bits at once and could read over the end.<br>
	 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
	 * before packets may be fed to the decoder.<br>
	 * @param      avctx the codec context<br>
	 * @param[out] frame The AVFrame in which to store decoded audio samples.<br>
	 *                   The decoder will allocate a buffer for the decoded frame by<br>
	 *                   calling the AVCodecContext.get_buffer2() callback.<br>
	 *                   When AVCodecContext.refcounted_frames is set to 1, the frame is<br>
	 *                   reference counted and the returned reference belongs to the<br>
	 *                   caller. The caller must release the frame using av_frame_unref()<br>
	 *                   when the frame is no longer needed. The caller may safely write<br>
	 *                   to the frame if av_frame_is_writable() returns 1.<br>
	 *                   When AVCodecContext.refcounted_frames is set to 0, the returned<br>
	 *                   reference belongs to the decoder and is valid only until the<br>
	 *                   next call to this function or until closing or flushing the<br>
	 *                   decoder. The caller may not write to it.<br>
	 * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is<br>
	 *                           non-zero. Note that this field being set to zero<br>
	 *                           does not mean that an error has occurred. For<br>
	 *                           decoders with AV_CODEC_CAP_DELAY set, no given decode<br>
	 *                           call is guaranteed to produce a frame.<br>
	 * @param[in]  avpkt The input AVPacket containing the input buffer.<br>
	 *                   At least avpkt->data and avpkt->size should be set. Some<br>
	 *                   decoders might also require additional fields to be set.<br>
	 * @return A negative error code is returned if an error occurred during<br>
	 *         decoding, otherwise the number of bytes consumed from the input<br>
	 *         AVPacket is returned.<br>
	 * @deprecated Use avcodec_send_packet() and avcodec_receive_frame().<br>
	 * Original signature : <code>int avcodec_decode_audio4(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1699</i>
	 */
	int avcodec_decode_audio4(AVCodecContext avctx, AVFrame frame, IntBuffer got_frame_ptr, AVPacket avpkt);
	/**
	 * Decode the video frame of size avpkt->size from avpkt->data into picture.<br>
	 * Some decoders may support multiple frames in a single AVPacket, such<br>
	 * decoders would then just decode the first frame.<br>
	 * @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than<br>
	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
	 * bits at once and could read over the end.<br>
	 * @warning The end of the input buffer buf should be set to 0 to ensure that<br>
	 * no overreading happens for damaged MPEG streams.<br>
	 * @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay<br>
	 * between input and output, these need to be fed with avpkt->data=NULL,<br>
	 * avpkt->size=0 at the end to return the remaining frames.<br>
	 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
	 * before packets may be fed to the decoder.<br>
	 * @param avctx the codec context<br>
	 * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
	 *             Use av_frame_alloc() to get an AVFrame. The codec will<br>
	 *             allocate memory for the actual bitmap by calling the<br>
	 *             AVCodecContext.get_buffer2() callback.<br>
	 *             When AVCodecContext.refcounted_frames is set to 1, the frame is<br>
	 *             reference counted and the returned reference belongs to the<br>
	 *             caller. The caller must release the frame using av_frame_unref()<br>
	 *             when the frame is no longer needed. The caller may safely write<br>
	 *             to the frame if av_frame_is_writable() returns 1.<br>
	 *             When AVCodecContext.refcounted_frames is set to 0, the returned<br>
	 *             reference belongs to the decoder and is valid only until the<br>
	 *             next call to this function or until closing or flushing the<br>
	 *             decoder. The caller may not write to it.<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 *            You can create such packet with av_init_packet() and by then setting<br>
	 *            data and size, some decoders might in addition need other fields like<br>
	 *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least<br>
	 *            fields possible.<br>
	 * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame could be decompressed.<br>
	 * @deprecated Use avcodec_send_packet() and avcodec_receive_frame().<br>
	 * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1739</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_video2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avutil55.AVFrame, IntBuffer, org.ffmpeg.avcodec57.AVPacket)} and {@link #avcodec_decode_video2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avutil55.AVFrame, IntByReference, org.ffmpeg.avcodec57.AVPacket)} instead
	 */
	@Deprecated 
	int avcodec_decode_video2(AVCodecContext avctx, AVFrame picture, IntByReference got_picture_ptr, AVPacket avpkt);
	/**
	 * Decode the video frame of size avpkt->size from avpkt->data into picture.<br>
	 * Some decoders may support multiple frames in a single AVPacket, such<br>
	 * decoders would then just decode the first frame.<br>
	 * @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than<br>
	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
	 * bits at once and could read over the end.<br>
	 * @warning The end of the input buffer buf should be set to 0 to ensure that<br>
	 * no overreading happens for damaged MPEG streams.<br>
	 * @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay<br>
	 * between input and output, these need to be fed with avpkt->data=NULL,<br>
	 * avpkt->size=0 at the end to return the remaining frames.<br>
	 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
	 * before packets may be fed to the decoder.<br>
	 * @param avctx the codec context<br>
	 * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
	 *             Use av_frame_alloc() to get an AVFrame. The codec will<br>
	 *             allocate memory for the actual bitmap by calling the<br>
	 *             AVCodecContext.get_buffer2() callback.<br>
	 *             When AVCodecContext.refcounted_frames is set to 1, the frame is<br>
	 *             reference counted and the returned reference belongs to the<br>
	 *             caller. The caller must release the frame using av_frame_unref()<br>
	 *             when the frame is no longer needed. The caller may safely write<br>
	 *             to the frame if av_frame_is_writable() returns 1.<br>
	 *             When AVCodecContext.refcounted_frames is set to 0, the returned<br>
	 *             reference belongs to the decoder and is valid only until the<br>
	 *             next call to this function or until closing or flushing the<br>
	 *             decoder. The caller may not write to it.<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 *            You can create such packet with av_init_packet() and by then setting<br>
	 *            data and size, some decoders might in addition need other fields like<br>
	 *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least<br>
	 *            fields possible.<br>
	 * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame could be decompressed.<br>
	 * @deprecated Use avcodec_send_packet() and avcodec_receive_frame().<br>
	 * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1739</i>
	 */
	int avcodec_decode_video2(AVCodecContext avctx, AVFrame picture, IntBuffer got_picture_ptr, AVPacket avpkt);
	/**
	 * Decode a subtitle message.<br>
	 * Return a negative value on error, otherwise return the number of bytes used.<br>
	 * If no subtitle could be decompressed, got_sub_ptr is zero.<br>
	 * Otherwise, the subtitle is stored in *sub.<br>
	 * Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for<br>
	 * simplicity, because the performance difference is expect to be negligible<br>
	 * and reusing a get_buffer written for video codecs would probably perform badly<br>
	 * due to a potentially very different allocation pattern.<br>
	 * Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input<br>
	 * and output. This means that for some packets they will not immediately<br>
	 * produce decoded output and need to be flushed at the end of decoding to get<br>
	 * all the decoded data. Flushing is done by calling this function with packets<br>
	 * with avpkt->data set to NULL and avpkt->size set to 0 until it stops<br>
	 * returning subtitles. It is safe to flush even those decoders that are not<br>
	 * marked with CODEC_CAP_DELAY, then no subtitles will be returned.<br>
	 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
	 * before packets may be fed to the decoder.<br>
	 * @param avctx the codec context<br>
	 * @param[out] sub The Preallocated AVSubtitle in which the decoded subtitle will be stored,<br>
	 *                 must be freed with avsubtitle_free if *got_sub_ptr is set.<br>
	 * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 * Original signature : <code>int avcodec_decode_subtitle2(AVCodecContext*, AVSubtitle*, int*, AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1765</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_subtitle2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.AVSubtitle, IntBuffer, org.ffmpeg.avcodec57.AVPacket)} and {@link #avcodec_decode_subtitle2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.AVSubtitle, IntByReference, org.ffmpeg.avcodec57.AVPacket)} instead
	 */
	@Deprecated 
	int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub, IntByReference got_sub_ptr, AVPacket avpkt);
	/**
	 * Decode a subtitle message.<br>
	 * Return a negative value on error, otherwise return the number of bytes used.<br>
	 * If no subtitle could be decompressed, got_sub_ptr is zero.<br>
	 * Otherwise, the subtitle is stored in *sub.<br>
	 * Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for<br>
	 * simplicity, because the performance difference is expect to be negligible<br>
	 * and reusing a get_buffer written for video codecs would probably perform badly<br>
	 * due to a potentially very different allocation pattern.<br>
	 * Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input<br>
	 * and output. This means that for some packets they will not immediately<br>
	 * produce decoded output and need to be flushed at the end of decoding to get<br>
	 * all the decoded data. Flushing is done by calling this function with packets<br>
	 * with avpkt->data set to NULL and avpkt->size set to 0 until it stops<br>
	 * returning subtitles. It is safe to flush even those decoders that are not<br>
	 * marked with CODEC_CAP_DELAY, then no subtitles will be returned.<br>
	 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
	 * before packets may be fed to the decoder.<br>
	 * @param avctx the codec context<br>
	 * @param[out] sub The Preallocated AVSubtitle in which the decoded subtitle will be stored,<br>
	 *                 must be freed with avsubtitle_free if *got_sub_ptr is set.<br>
	 * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 * Original signature : <code>int avcodec_decode_subtitle2(AVCodecContext*, AVSubtitle*, int*, AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1765</i>
	 */
	int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub, IntBuffer got_sub_ptr, AVPacket avpkt);
	/**
	 * Supply raw packet data as input to a decoder.<br>
	 * Internally, this call will copy relevant AVCodecContext fields, which can<br>
	 * influence decoding per-packet, and apply them when the packet is actually<br>
	 * decoded. (For example AVCodecContext.skip_frame, which might direct the<br>
	 * decoder to drop the frame contained by the packet sent with this function.)<br>
	 * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE<br>
	 *          larger than the actual read bytes because some optimized bitstream<br>
	 *          readers read 32 or 64 bits at once and could read over the end.<br>
	 * @warning Do not mix this API with the legacy API (like avcodec_decode_video2())<br>
	 *          on the same AVCodecContext. It will return unexpected results now<br>
	 *          or in future libavcodec versions.<br>
	 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
	 *       before packets may be fed to the decoder.<br>
	 * @param avctx codec context<br>
	 * @param[in] avpkt The input AVPacket. Usually, this will be a single video<br>
	 *                  frame, or several complete audio frames.<br>
	 *                  Ownership of the packet remains with the caller, and the<br>
	 *                  decoder will not write to the packet. The decoder may create<br>
	 *                  a reference to the packet data (or copy it if the packet is<br>
	 *                  not reference-counted).<br>
	 *                  Unlike with older APIs, the packet is always fully consumed,<br>
	 *                  and if it contains multiple frames (e.g. some audio codecs),<br>
	 *                  will require you to call avcodec_receive_frame() multiple<br>
	 *                  times afterwards before you can send a new packet.<br>
	 *                  It can be NULL (or an AVPacket with data set to NULL and<br>
	 *                  size set to 0); in this case, it is considered a flush<br>
	 *                  packet, which signals the end of the stream. Sending the<br>
	 *                  first flush packet will return success. Subsequent ones are<br>
	 *                  unnecessary and will return AVERROR_EOF. If the decoder<br>
	 *                  still has frames buffered, it will return them after sending<br>
	 *                  a flush packet.<br>
	 * @return 0 on success, otherwise negative error code:<br>
	 *      AVERROR(EAGAIN):   input is not accepted in the current state - user<br>
	 *                         must read output with avcodec_receive_frame() (once<br>
	 *                         all output is read, the packet should be resent, and<br>
	 *                         the call will not fail with EAGAIN).<br>
	 *      AVERROR_EOF:       the decoder has been flushed, and no new packets can<br>
	 *                         be sent to it (also returned if more than 1 flush<br>
	 *                         packet is sent)<br>
	 *      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush<br>
	 *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar<br>
	 *      other errors: legitimate decoding errors<br>
	 * Original signature : <code>int avcodec_send_packet(AVCodecContext*, const AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1811</i>
	 */
	int avcodec_send_packet(AVCodecContext avctx, Pointer avpkt);
	/**
	 * Return decoded output data from a decoder.<br>
	 * @param avctx codec context<br>
	 * @param frame This will be set to a reference-counted video or audio<br>
	 *              frame (depending on the decoder type) allocated by the<br>
	 *              decoder. Note that the function will always call<br>
	 *              av_frame_unref(frame) before doing anything else.<br>
	 * @return<br>
	 *      0:                 success, a frame was returned<br>
	 *      AVERROR(EAGAIN):   output is not available in this state - user must try<br>
	 *                         to send new input<br>
	 *      AVERROR_EOF:       the decoder has been fully flushed, and there will be<br>
	 *                         no more output frames<br>
	 *      AVERROR(EINVAL):   codec not opened, or it is an encoder<br>
	 *      other negative values: legitimate decoding errors<br>
	 * Original signature : <code>int avcodec_receive_frame(AVCodecContext*, AVFrame*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1829</i>
	 */
	int avcodec_receive_frame(AVCodecContext avctx, AVFrame frame);
	/**
	 * Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()<br>
	 * to retrieve buffered output packets.<br>
	 * @param avctx     codec context<br>
	 * @param[in] frame AVFrame containing the raw audio or video frame to be encoded.<br>
	 *                  Ownership of the frame remains with the caller, and the<br>
	 *                  encoder will not write to the frame. The encoder may create<br>
	 *                  a reference to the frame data (or copy it if the frame is<br>
	 *                  not reference-counted).<br>
	 *                  It can be NULL, in which case it is considered a flush<br>
	 *                  packet.  This signals the end of the stream. If the encoder<br>
	 *                  still has packets buffered, it will return them after this<br>
	 *                  call. Once flushing mode has been entered, additional flush<br>
	 *                  packets are ignored, and sending frames will return<br>
	 *                  AVERROR_EOF.<br>
	 *                  For audio:<br>
	 *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame<br>
	 *                  can have any number of samples.<br>
	 *                  If it is not set, frame->nb_samples must be equal to<br>
	 *                  avctx->frame_size for all frames except the last.<br>
	 *                  The final frame may be smaller than avctx->frame_size.<br>
	 * @return 0 on success, otherwise negative error code:<br>
	 *      AVERROR(EAGAIN):   input is not accepted in the current state - user<br>
	 *                         must read output with avcodec_receive_packet() (once<br>
	 *                         all output is read, the packet should be resent, and<br>
	 *                         the call will not fail with EAGAIN).<br>
	 *      AVERROR_EOF:       the encoder has been flushed, and no new frames can<br>
	 *                         be sent to it<br>
	 *      AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a<br>
	 *                         decoder, or requires flush<br>
	 *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar<br>
	 *      other errors: legitimate decoding errors<br>
	 * Original signature : <code>int avcodec_send_frame(AVCodecContext*, const AVFrame*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1864</i>
	 */
	int avcodec_send_frame(AVCodecContext avctx, AVFrame frame);
	/**
	 * Read encoded data from the encoder.<br>
	 * @param avctx codec context<br>
	 * @param avpkt This will be set to a reference-counted packet allocated by the<br>
	 *              encoder. Note that the function will always call<br>
	 *              av_frame_unref(frame) before doing anything else.<br>
	 * @return 0 on success, otherwise negative error code:<br>
	 *      AVERROR(EAGAIN):   output is not available in the current state - user<br>
	 *                         must try to send input<br>
	 *      AVERROR_EOF:       the encoder has been fully flushed, and there will be<br>
	 *                         no more output packets<br>
	 *      AVERROR(EINVAL):   codec not opened, or it is an encoder<br>
	 *      other errors: legitimate decoding errors<br>
	 * Original signature : <code>int avcodec_receive_packet(AVCodecContext*, AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1880</i>
	 */
	int avcodec_receive_packet(AVCodecContext avctx, AVPacket avpkt);
	/**
	 * Original signature : <code>AVCodecParser* av_parser_next(const AVCodecParser*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1954</i>
	 */
	AVCodecParser av_parser_next(AVCodecParser c);
	/**
	 * Original signature : <code>void av_register_codec_parser(AVCodecParser*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1956</i>
	 */
	void av_register_codec_parser(AVCodecParser parser);
	/**
	 * Original signature : <code>AVCodecParserContext* av_parser_init(int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1958</i>
	 */
	AVCodecParserContext av_parser_init(int codec_id);
	/**
	 * Parse a packet.<br>
	 * @param s             parser context.<br>
	 * @param avctx         codec context.<br>
	 * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.<br>
	 * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.<br>
	 * @param buf           input buffer.<br>
	 * @param buf_size      buffer size in bytes without the padding. I.e. the full buffer<br>
	 * size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.<br>
	 * To signal EOF, this should be 0 (so that the last frame<br>
	 * can be output).<br>
	 * @param pts           input presentation timestamp.<br>
	 * @param dts           input decoding timestamp.<br>
	 * @param pos           input byte position in stream.<br>
	 * @return the number of bytes of the input bitstream used.<br>
	 * Example:<br>
	 * @code<br>
	 *   while(in_len){<br>
	 *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,<br>
	 *                                        in_data, in_len,<br>
	 *                                        pts, dts, pos);<br>
	 *       in_data += len;<br>
	 *       in_len  -= len;<br>
	 *       if(size)<br>
	 *          decode_frame(data, size);<br>
	 *   }<br>
	 * @endcode<br>
	 * Original signature : <code>int av_parser_parse2(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1988</i><br>
	 * @deprecated use the safer methods {@link #av_parser_parse2(org.ffmpeg.avcodec57.AVCodecParserContext, org.ffmpeg.avcodec57.AVCodecContext, PointerByReference, IntBuffer, byte[], int, long, long, long)} and {@link #av_parser_parse2(org.ffmpeg.avcodec57.AVCodecParserContext, org.ffmpeg.avcodec57.AVCodecContext, PointerByReference, IntByReference, Pointer, int, long, long, long)} instead
	 */
	@Deprecated 
	int av_parser_parse2(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, long pts, long dts, long pos);
	/**
	 * Parse a packet.<br>
	 * @param s             parser context.<br>
	 * @param avctx         codec context.<br>
	 * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.<br>
	 * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.<br>
	 * @param buf           input buffer.<br>
	 * @param buf_size      buffer size in bytes without the padding. I.e. the full buffer<br>
	 * size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.<br>
	 * To signal EOF, this should be 0 (so that the last frame<br>
	 * can be output).<br>
	 * @param pts           input presentation timestamp.<br>
	 * @param dts           input decoding timestamp.<br>
	 * @param pos           input byte position in stream.<br>
	 * @return the number of bytes of the input bitstream used.<br>
	 * Example:<br>
	 * @code<br>
	 *   while(in_len){<br>
	 *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,<br>
	 *                                        in_data, in_len,<br>
	 *                                        pts, dts, pos);<br>
	 *       in_data += len;<br>
	 *       in_len  -= len;<br>
	 *       if(size)<br>
	 *          decode_frame(data, size);<br>
	 *   }<br>
	 * @endcode<br>
	 * Original signature : <code>int av_parser_parse2(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1988</i>
	 */
	int av_parser_parse2(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntBuffer poutbuf_size, byte buf[], int buf_size, long pts, long dts, long pos);
	/**
	 * @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed<br>
	 * @deprecated use AVBitStreamFilter<br>
	 * Original signature : <code>int av_parser_change(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1994</i><br>
	 * @deprecated use the safer methods {@link #av_parser_change(org.ffmpeg.avcodec57.AVCodecParserContext, org.ffmpeg.avcodec57.AVCodecContext, PointerByReference, IntBuffer, byte[], int, int)} and {@link #av_parser_change(org.ffmpeg.avcodec57.AVCodecParserContext, org.ffmpeg.avcodec57.AVCodecContext, PointerByReference, IntByReference, Pointer, int, int)} instead
	 */
	@Deprecated 
	int av_parser_change(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, int keyframe);
	/**
	 * @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed<br>
	 * @deprecated use AVBitStreamFilter<br>
	 * Original signature : <code>int av_parser_change(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1994</i>
	 */
	int av_parser_change(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntBuffer poutbuf_size, byte buf[], int buf_size, int keyframe);
	/**
	 * Original signature : <code>void av_parser_close(AVCodecParserContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:1996</i>
	 */
	void av_parser_close(AVCodecParserContext s);
	/**
	 * Find a registered encoder with a matching codec ID.<br>
	 * @param id AVCodecID of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder(AVCodecID)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2003</i>
	 */
	AVCodec avcodec_find_encoder(int id);
	/**
	 * Find a registered encoder with the specified name.<br>
	 * @param name name of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder_by_name(const char*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2010</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_encoder_by_name(String)} and {@link #avcodec_find_encoder_by_name(Pointer)} instead
	 */
	@Deprecated 
	AVCodec avcodec_find_encoder_by_name(Pointer name);
	/**
	 * Find a registered encoder with the specified name.<br>
	 * @param name name of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder_by_name(const char*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2010</i>
	 */
	AVCodec avcodec_find_encoder_by_name(String name);
	/**
	 * Encode a frame of audio.<br>
	 * Takes input samples from frame and writes the next output packet, if<br>
	 * available, to avpkt. The output packet does not necessarily contain data for<br>
	 * the most recent frame, as encoders can delay, split, and combine input frames<br>
	 * internally as needed.<br>
	 * @param avctx     codec context<br>
	 * @param avpkt     output AVPacket.<br>
	 *                  The user can supply an output buffer by setting<br>
	 *                  avpkt->data and avpkt->size prior to calling the<br>
	 *                  function, but if the size of the user-provided data is not<br>
	 *                  large enough, encoding will fail. If avpkt->data and<br>
	 *                  avpkt->size are set, avpkt->destruct must also be set. All<br>
	 *                  other AVPacket fields will be reset by the encoder using<br>
	 *                  av_init_packet(). If avpkt->data is NULL, the encoder will<br>
	 *                  allocate it. The encoder will set avpkt->size to the size<br>
	 *                  of the output packet.<br>
	 *                  If this function fails or produces no output, avpkt will be<br>
	 *                  freed using av_packet_unref().<br>
	 * @param[in] frame AVFrame containing the raw audio data to be encoded.<br>
	 *                  May be NULL when flushing an encoder that has the<br>
	 *                  AV_CODEC_CAP_DELAY capability set.<br>
	 *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame<br>
	 *                  can have any number of samples.<br>
	 *                  If it is not set, frame->nb_samples must be equal to<br>
	 *                  avctx->frame_size for all frames except the last.<br>
	 *                  The final frame may be smaller than avctx->frame_size.<br>
	 * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
	 *                            output packet is non-empty, and to 0 if it is<br>
	 *                            empty. If the function returns an error, the<br>
	 *                            packet can be assumed to be invalid, and the<br>
	 *                            value of got_packet_ptr is undefined and should<br>
	 *                            not be used.<br>
	 * @return          0 on success, negative error code on failure<br>
	 * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead<br>
	 * Original signature : <code>int avcodec_encode_audio2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2048</i><br>
	 * @deprecated use the safer methods {@link #avcodec_encode_audio2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.AVPacket, org.ffmpeg.avutil55.AVFrame, IntBuffer)} and {@link #avcodec_encode_audio2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.AVPacket, org.ffmpeg.avutil55.AVFrame, IntByReference)} instead
	 */
	@Deprecated 
	int avcodec_encode_audio2(AVCodecContext avctx, AVPacket avpkt, AVFrame frame, IntByReference got_packet_ptr);
	/**
	 * Encode a frame of audio.<br>
	 * Takes input samples from frame and writes the next output packet, if<br>
	 * available, to avpkt. The output packet does not necessarily contain data for<br>
	 * the most recent frame, as encoders can delay, split, and combine input frames<br>
	 * internally as needed.<br>
	 * @param avctx     codec context<br>
	 * @param avpkt     output AVPacket.<br>
	 *                  The user can supply an output buffer by setting<br>
	 *                  avpkt->data and avpkt->size prior to calling the<br>
	 *                  function, but if the size of the user-provided data is not<br>
	 *                  large enough, encoding will fail. If avpkt->data and<br>
	 *                  avpkt->size are set, avpkt->destruct must also be set. All<br>
	 *                  other AVPacket fields will be reset by the encoder using<br>
	 *                  av_init_packet(). If avpkt->data is NULL, the encoder will<br>
	 *                  allocate it. The encoder will set avpkt->size to the size<br>
	 *                  of the output packet.<br>
	 *                  If this function fails or produces no output, avpkt will be<br>
	 *                  freed using av_packet_unref().<br>
	 * @param[in] frame AVFrame containing the raw audio data to be encoded.<br>
	 *                  May be NULL when flushing an encoder that has the<br>
	 *                  AV_CODEC_CAP_DELAY capability set.<br>
	 *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame<br>
	 *                  can have any number of samples.<br>
	 *                  If it is not set, frame->nb_samples must be equal to<br>
	 *                  avctx->frame_size for all frames except the last.<br>
	 *                  The final frame may be smaller than avctx->frame_size.<br>
	 * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
	 *                            output packet is non-empty, and to 0 if it is<br>
	 *                            empty. If the function returns an error, the<br>
	 *                            packet can be assumed to be invalid, and the<br>
	 *                            value of got_packet_ptr is undefined and should<br>
	 *                            not be used.<br>
	 * @return          0 on success, negative error code on failure<br>
	 * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead<br>
	 * Original signature : <code>int avcodec_encode_audio2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2048</i>
	 */
	int avcodec_encode_audio2(AVCodecContext avctx, AVPacket avpkt, AVFrame frame, IntBuffer got_packet_ptr);
	/**
	 * Encode a frame of video.<br>
	 * Takes input raw video data from frame and writes the next output packet, if<br>
	 * available, to avpkt. The output packet does not necessarily contain data for<br>
	 * the most recent frame, as encoders can delay and reorder input frames<br>
	 * internally as needed.<br>
	 * @param avctx     codec context<br>
	 * @param avpkt     output AVPacket.<br>
	 *                  The user can supply an output buffer by setting<br>
	 *                  avpkt->data and avpkt->size prior to calling the<br>
	 *                  function, but if the size of the user-provided data is not<br>
	 *                  large enough, encoding will fail. All other AVPacket fields<br>
	 *                  will be reset by the encoder using av_init_packet(). If<br>
	 *                  avpkt->data is NULL, the encoder will allocate it.<br>
	 *                  The encoder will set avpkt->size to the size of the<br>
	 *                  output packet. The returned data (if any) belongs to the<br>
	 *                  caller, he is responsible for freeing it.<br>
	 *                  If this function fails or produces no output, avpkt will be<br>
	 *                  freed using av_packet_unref().<br>
	 * @param[in] frame AVFrame containing the raw video data to be encoded.<br>
	 *                  May be NULL when flushing an encoder that has the<br>
	 *                  AV_CODEC_CAP_DELAY capability set.<br>
	 * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
	 *                            output packet is non-empty, and to 0 if it is<br>
	 *                            empty. If the function returns an error, the<br>
	 *                            packet can be assumed to be invalid, and the<br>
	 *                            value of got_packet_ptr is undefined and should<br>
	 *                            not be used.<br>
	 * @return          0 on success, negative error code on failure<br>
	 * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead<br>
	 * Original signature : <code>int avcodec_encode_video2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2081</i><br>
	 * @deprecated use the safer methods {@link #avcodec_encode_video2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.AVPacket, org.ffmpeg.avutil55.AVFrame, IntBuffer)} and {@link #avcodec_encode_video2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.AVPacket, org.ffmpeg.avutil55.AVFrame, IntByReference)} instead
	 */
	@Deprecated 
	int avcodec_encode_video2(AVCodecContext avctx, AVPacket avpkt, AVFrame frame, IntByReference got_packet_ptr);
	/**
	 * Encode a frame of video.<br>
	 * Takes input raw video data from frame and writes the next output packet, if<br>
	 * available, to avpkt. The output packet does not necessarily contain data for<br>
	 * the most recent frame, as encoders can delay and reorder input frames<br>
	 * internally as needed.<br>
	 * @param avctx     codec context<br>
	 * @param avpkt     output AVPacket.<br>
	 *                  The user can supply an output buffer by setting<br>
	 *                  avpkt->data and avpkt->size prior to calling the<br>
	 *                  function, but if the size of the user-provided data is not<br>
	 *                  large enough, encoding will fail. All other AVPacket fields<br>
	 *                  will be reset by the encoder using av_init_packet(). If<br>
	 *                  avpkt->data is NULL, the encoder will allocate it.<br>
	 *                  The encoder will set avpkt->size to the size of the<br>
	 *                  output packet. The returned data (if any) belongs to the<br>
	 *                  caller, he is responsible for freeing it.<br>
	 *                  If this function fails or produces no output, avpkt will be<br>
	 *                  freed using av_packet_unref().<br>
	 * @param[in] frame AVFrame containing the raw video data to be encoded.<br>
	 *                  May be NULL when flushing an encoder that has the<br>
	 *                  AV_CODEC_CAP_DELAY capability set.<br>
	 * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
	 *                            output packet is non-empty, and to 0 if it is<br>
	 *                            empty. If the function returns an error, the<br>
	 *                            packet can be assumed to be invalid, and the<br>
	 *                            value of got_packet_ptr is undefined and should<br>
	 *                            not be used.<br>
	 * @return          0 on success, negative error code on failure<br>
	 * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead<br>
	 * Original signature : <code>int avcodec_encode_video2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2081</i>
	 */
	int avcodec_encode_video2(AVCodecContext avctx, AVPacket avpkt, AVFrame frame, IntBuffer got_packet_ptr);
	/**
	 * Original signature : <code>int avcodec_encode_subtitle(AVCodecContext*, uint8_t*, int, const AVSubtitle*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2083</i><br>
	 * @deprecated use the safer methods {@link #avcodec_encode_subtitle(org.ffmpeg.avcodec57.AVCodecContext, ByteBuffer, int, org.ffmpeg.avcodec57.AVSubtitle)} and {@link #avcodec_encode_subtitle(org.ffmpeg.avcodec57.AVCodecContext, Pointer, int, org.ffmpeg.avcodec57.AVSubtitle)} instead
	 */
	@Deprecated 
	int avcodec_encode_subtitle(AVCodecContext avctx, Pointer buf, int buf_size, AVSubtitle sub);
	/**
	 * Original signature : <code>int avcodec_encode_subtitle(AVCodecContext*, uint8_t*, int, const AVSubtitle*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2083</i>
	 */
	int avcodec_encode_subtitle(AVCodecContext avctx, ByteBuffer buf, int buf_size, AVSubtitle sub);
	/**
	 * Initialize audio resampling context.<br>
	 * @param output_channels  number of output channels<br>
	 * @param input_channels   number of input channels<br>
	 * @param output_rate      output sample rate<br>
	 * @param input_rate       input sample rate<br>
	 * @param sample_fmt_out   requested output sample format<br>
	 * @param sample_fmt_in    input sample format<br>
	 * @param filter_length    length of each FIR filter in the filterbank relative to the cutoff frequency<br>
	 * @param log2_phase_count log2 of the number of entries in the polyphase filterbank<br>
	 * @param linear           if 1 then the used FIR filter will be linearly interpolated<br>
	 * between the 2 closest, if 0 the closest will be used<br>
	 * @param cutoff           cutoff frequency, 1.0 corresponds to half the output sampling rate<br>
	 * @return allocated ReSampleContext, NULL if error occurred<br>
	 * Original signature : <code>ReSampleContext* av_audio_resample_init(int, int, int, int, AVSampleFormat, AVSampleFormat, int, int, int, double)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2111</i>
	 */
	ReSampleContext av_audio_resample_init(int output_channels, int input_channels, int output_rate, int input_rate, int sample_fmt_out, int sample_fmt_in, int filter_length, int log2_phase_count, int linear, double cutoff);
	/**
	 * Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2113</i><br>
	 * @deprecated use the safer methods {@link #audio_resample(org.ffmpeg.avcodec57.ReSampleContext, ShortBuffer, ShortBuffer, int)} and {@link #audio_resample(org.ffmpeg.avcodec57.ReSampleContext, ShortByReference, ShortByReference, int)} instead
	 */
	@Deprecated 
	int audio_resample(ReSampleContext s, ShortByReference output, ShortByReference input, int nb_samples);
	/**
	 * Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2113</i>
	 */
	int audio_resample(ReSampleContext s, ShortBuffer output, ShortBuffer input, int nb_samples);
	/**
	 * Free resample context.<br>
	 * @param s a non-NULL pointer to a resample context previously<br>
	 *          created with av_audio_resample_init()<br>
	 * Original signature : <code>void audio_resample_close(ReSampleContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2120</i>
	 */
	void audio_resample_close(ReSampleContext s);
	/**
	 * Initialize an audio resampler.<br>
	 * Note, if either rate is not an integer then simply scale both rates up so they are.<br>
	 * @param filter_length length of each FIR filter in the filterbank relative to the cutoff freq<br>
	 * @param log2_phase_count log2 of the number of entries in the polyphase filterbank<br>
	 * @param linear If 1 then the used FIR filter will be linearly interpolated<br>
	 * between the 2 closest, if 0 the closest will be used<br>
	 * @param cutoff cutoff frequency, 1.0 corresponds to half the output sampling rate<br>
	 * Original signature : <code>AVResampleContext* av_resample_init(int, int, int, int, int, double)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2131</i>
	 */
	AVResampleContext av_resample_init(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff);
	/**
	 * Resample an array of samples using a previously configured context.<br>
	 * @param src an array of unconsumed samples<br>
	 * @param consumed the number of samples of src which have been consumed are returned here<br>
	 * @param src_size the number of unconsumed samples available<br>
	 * @param dst_size the amount of space in samples available in dst<br>
	 * @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.<br>
	 * @return the number of samples written in dst or -1 if an error occurred<br>
	 * Original signature : <code>int av_resample(AVResampleContext*, short*, short*, int*, int, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2142</i><br>
	 * @deprecated use the safer methods {@link #av_resample(org.ffmpeg.avcodec57.Avcodec57Library.AVResampleContext, ShortBuffer, ShortBuffer, IntBuffer, int, int, int)} and {@link #av_resample(org.ffmpeg.avcodec57.Avcodec57Library.AVResampleContext, ShortByReference, ShortByReference, IntByReference, int, int, int)} instead
	 */
	@Deprecated 
	int av_resample(AVResampleContext c, ShortByReference dst, ShortByReference src, IntByReference consumed, int src_size, int dst_size, int update_ctx);
	/**
	 * Resample an array of samples using a previously configured context.<br>
	 * @param src an array of unconsumed samples<br>
	 * @param consumed the number of samples of src which have been consumed are returned here<br>
	 * @param src_size the number of unconsumed samples available<br>
	 * @param dst_size the amount of space in samples available in dst<br>
	 * @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.<br>
	 * @return the number of samples written in dst or -1 if an error occurred<br>
	 * Original signature : <code>int av_resample(AVResampleContext*, short*, short*, int*, int, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2142</i>
	 */
	int av_resample(AVResampleContext c, ShortBuffer dst, ShortBuffer src, IntBuffer consumed, int src_size, int dst_size, int update_ctx);
	/**
	 * Compensate samplerate/timestamp drift. The compensation is done by changing<br>
	 * the resampler parameters, so no audible clicks or similar distortions occur<br>
	 * @param compensation_distance distance in output samples over which the compensation should be performed<br>
	 * @param sample_delta number of output samples which should be output less<br>
	 * example: av_resample_compensate(c, 10, 500)<br>
	 * here instead of 510 samples only 500 samples would be output<br>
	 * note, due to rounding the actual compensation might be slightly different,<br>
	 * especially if the compensation_distance is large and the in_rate used during init is small<br>
	 * Original signature : <code>void av_resample_compensate(AVResampleContext*, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2154</i>
	 */
	void av_resample_compensate(AVResampleContext c, int sample_delta, int compensation_distance);
	/**
	 * Original signature : <code>void av_resample_close(AVResampleContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2156</i>
	 */
	void av_resample_close(AVResampleContext c);
	/**
	 * @deprecated unused<br>
	 * Original signature : <code>int avpicture_alloc(AVPicture*, AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2161</i>
	 */
	int avpicture_alloc(AVPicture picture, int pix_fmt, int width, int height);
	/**
	 * @deprecated unused<br>
	 * Original signature : <code>void avpicture_free(AVPicture*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2166</i>
	 */
	void avpicture_free(AVPicture picture);
	/**
	 * @deprecated use av_image_fill_arrays() instead.<br>
	 * Original signature : <code>int avpicture_fill(AVPicture*, const uint8_t*, AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2171</i><br>
	 * @deprecated use the safer methods {@link #avpicture_fill(org.ffmpeg.avcodec57.AVPicture, byte[], int, int, int)} and {@link #avpicture_fill(org.ffmpeg.avcodec57.AVPicture, Pointer, int, int, int)} instead
	 */
	@Deprecated 
	int avpicture_fill(AVPicture picture, Pointer ptr, int pix_fmt, int width, int height);
	/**
	 * @deprecated use av_image_fill_arrays() instead.<br>
	 * Original signature : <code>int avpicture_fill(AVPicture*, const uint8_t*, AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2171</i>
	 */
	int avpicture_fill(AVPicture picture, byte ptr[], int pix_fmt, int width, int height);
	/**
	 * @deprecated use av_image_copy_to_buffer() instead.<br>
	 * Original signature : <code>int avpicture_layout(const AVPicture*, AVPixelFormat, int, int, unsigned char*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2176</i><br>
	 * @deprecated use the safer methods {@link #avpicture_layout(org.ffmpeg.avcodec57.AVPicture, int, int, int, ByteBuffer, int)} and {@link #avpicture_layout(org.ffmpeg.avcodec57.AVPicture, int, int, int, Pointer, int)} instead
	 */
	@Deprecated 
	int avpicture_layout(AVPicture src, int pix_fmt, int width, int height, Pointer dest, int dest_size);
	/**
	 * @deprecated use av_image_copy_to_buffer() instead.<br>
	 * Original signature : <code>int avpicture_layout(const AVPicture*, AVPixelFormat, int, int, unsigned char*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2176</i>
	 */
	int avpicture_layout(AVPicture src, int pix_fmt, int width, int height, ByteBuffer dest, int dest_size);
	/**
	 * @deprecated use av_image_get_buffer_size() instead.<br>
	 * Original signature : <code>int avpicture_get_size(AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2181</i>
	 */
	int avpicture_get_size(int pix_fmt, int width, int height);
	/**
	 * @deprecated av_image_copy() instead.<br>
	 * Original signature : <code>void av_picture_copy(AVPicture*, const AVPicture*, AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2186</i>
	 */
	void av_picture_copy(AVPicture dst, AVPicture src, int pix_fmt, int width, int height);
	/**
	 * @deprecated unused<br>
	 * Original signature : <code>int av_picture_crop(AVPicture*, const AVPicture*, AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2191</i>
	 */
	int av_picture_crop(AVPicture dst, AVPicture src, int pix_fmt, int top_band, int left_band);
	/**
	 * @deprecated unused<br>
	 * Original signature : <code>int av_picture_pad(AVPicture*, const AVPicture*, int, int, AVPixelFormat, int, int, int, int, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2196</i><br>
	 * @deprecated use the safer methods {@link #av_picture_pad(org.ffmpeg.avcodec57.AVPicture, org.ffmpeg.avcodec57.AVPicture, int, int, int, int, int, int, int, IntBuffer)} and {@link #av_picture_pad(org.ffmpeg.avcodec57.AVPicture, org.ffmpeg.avcodec57.AVPicture, int, int, int, int, int, int, int, IntByReference)} instead
	 */
	@Deprecated 
	int av_picture_pad(AVPicture dst, AVPicture src, int height, int width, int pix_fmt, int padtop, int padbottom, int padleft, int padright, IntByReference color);
	/**
	 * @deprecated unused<br>
	 * Original signature : <code>int av_picture_pad(AVPicture*, const AVPicture*, int, int, AVPixelFormat, int, int, int, int, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2196</i>
	 */
	int av_picture_pad(AVPicture dst, AVPicture src, int height, int width, int pix_fmt, int padtop, int padbottom, int padleft, int padright, IntBuffer color);
	/**
	 * Utility function to access log2_chroma_w log2_chroma_h from<br>
	 * the pixel format AVPixFmtDescriptor.<br>
	 * This function asserts that pix_fmt is valid. See av_pix_fmt_get_chroma_sub_sample<br>
	 * for one that returns a failure code and continues in case of invalid<br>
	 * pix_fmts.<br>
	 * @param[in]  pix_fmt the pixel format<br>
	 * @param[out] h_shift store log2_chroma_w<br>
	 * @param[out] v_shift store log2_chroma_h<br>
	 * @see av_pix_fmt_get_chroma_sub_sample<br>
	 * Original signature : <code>void avcodec_get_chroma_sub_sample(AVPixelFormat, int*, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2209</i><br>
	 * @deprecated use the safer methods {@link #avcodec_get_chroma_sub_sample(int, IntBuffer, IntBuffer)} and {@link #avcodec_get_chroma_sub_sample(int, IntByReference, IntByReference)} instead
	 */
	@Deprecated 
	void avcodec_get_chroma_sub_sample(int pix_fmt, IntByReference h_shift, IntByReference v_shift);
	/**
	 * Utility function to access log2_chroma_w log2_chroma_h from<br>
	 * the pixel format AVPixFmtDescriptor.<br>
	 * This function asserts that pix_fmt is valid. See av_pix_fmt_get_chroma_sub_sample<br>
	 * for one that returns a failure code and continues in case of invalid<br>
	 * pix_fmts.<br>
	 * @param[in]  pix_fmt the pixel format<br>
	 * @param[out] h_shift store log2_chroma_w<br>
	 * @param[out] v_shift store log2_chroma_h<br>
	 * @see av_pix_fmt_get_chroma_sub_sample<br>
	 * Original signature : <code>void avcodec_get_chroma_sub_sample(AVPixelFormat, int*, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2209</i>
	 */
	void avcodec_get_chroma_sub_sample(int pix_fmt, IntBuffer h_shift, IntBuffer v_shift);
	/**
	 * Return a value representing the fourCC code associated to the<br>
	 * pixel format pix_fmt, or 0 if no associated fourCC code can be<br>
	 * found.<br>
	 * Original signature : <code>int avcodec_pix_fmt_to_codec_tag(AVPixelFormat)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2216</i>
	 */
	int avcodec_pix_fmt_to_codec_tag(int pix_fmt);
	/**
	 * @deprecated see av_get_pix_fmt_loss()<br>
	 * Original signature : <code>int avcodec_get_pix_fmt_loss(AVPixelFormat, AVPixelFormat, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2221</i>
	 */
	int avcodec_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt, int has_alpha);
	/**
	 * Find the best pixel format to convert to given a certain source pixel<br>
	 * format.  When converting from one pixel format to another, information loss<br>
	 * may occur.  For example, when converting from RGB24 to GRAY, the color<br>
	 * information will be lost. Similarly, other losses occur when converting from<br>
	 * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of<br>
	 * the given pixel formats should be used to suffer the least amount of loss.<br>
	 * The pixel formats from which it chooses one, are determined by the<br>
	 * pix_fmt_list parameter.<br>
	 * *<br>
	 * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.<br>
	 * @return The best pixel format to convert to or -1 if none was found.<br>
	 * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_list(AVPixelFormat*, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2239</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_best_pix_fmt_of_list(IntBuffer, int, int, IntBuffer)} and {@link #avcodec_find_best_pix_fmt_of_list(IntByReference, int, int, IntByReference)} instead
	 */
	@Deprecated 
	int avcodec_find_best_pix_fmt_of_list(IntByReference pix_fmt_list, int src_pix_fmt, int has_alpha, IntByReference loss_ptr);
	/**
	 * Find the best pixel format to convert to given a certain source pixel<br>
	 * format.  When converting from one pixel format to another, information loss<br>
	 * may occur.  For example, when converting from RGB24 to GRAY, the color<br>
	 * information will be lost. Similarly, other losses occur when converting from<br>
	 * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of<br>
	 * the given pixel formats should be used to suffer the least amount of loss.<br>
	 * The pixel formats from which it chooses one, are determined by the<br>
	 * pix_fmt_list parameter.<br>
	 * *<br>
	 * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.<br>
	 * @return The best pixel format to convert to or -1 if none was found.<br>
	 * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_list(AVPixelFormat*, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2239</i>
	 */
	int avcodec_find_best_pix_fmt_of_list(IntBuffer pix_fmt_list, int src_pix_fmt, int has_alpha, IntBuffer loss_ptr);
	/**
	 * @deprecated see av_find_best_pix_fmt_of_2()<br>
	 * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2244</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_best_pix_fmt_of_2(int, int, int, int, IntBuffer)} and {@link #avcodec_find_best_pix_fmt_of_2(int, int, int, int, IntByReference)} instead
	 */
	@Deprecated 
	int avcodec_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, IntByReference loss_ptr);
	/**
	 * @deprecated see av_find_best_pix_fmt_of_2()<br>
	 * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2244</i>
	 */
	int avcodec_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, IntBuffer loss_ptr);
	/**
	 * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2246</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_best_pix_fmt2(int, int, int, int, IntBuffer)} and {@link #avcodec_find_best_pix_fmt2(int, int, int, int, IntByReference)} instead
	 */
	@Deprecated 
	int avcodec_find_best_pix_fmt2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, IntByReference loss_ptr);
	/**
	 * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2246</i>
	 */
	int avcodec_find_best_pix_fmt2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, IntBuffer loss_ptr);
	/**
	 * Original signature : <code>AVPixelFormat avcodec_default_get_format(AVCodecContext*, AVPixelFormat*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2248</i><br>
	 * @deprecated use the safer methods {@link #avcodec_default_get_format(org.ffmpeg.avcodec57.AVCodecContext, IntBuffer)} and {@link #avcodec_default_get_format(org.ffmpeg.avcodec57.AVCodecContext, IntByReference)} instead
	 */
	@Deprecated 
	int avcodec_default_get_format(AVCodecContext s, IntByReference fmt);
	/**
	 * Original signature : <code>AVPixelFormat avcodec_default_get_format(AVCodecContext*, AVPixelFormat*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2248</i>
	 */
	int avcodec_default_get_format(AVCodecContext s, IntBuffer fmt);
	/**
	 * @deprecated this function is not supposed to be used from outside of lavc<br>
	 * Original signature : <code>void avcodec_set_dimensions(AVCodecContext*, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2253</i>
	 */
	void avcodec_set_dimensions(AVCodecContext s, int width, int height);
	/**
	 * Put a string representing the codec tag codec_tag in buf.<br>
	 * @param buf       buffer to place codec tag in<br>
	 * @param buf_size size in bytes of buf<br>
	 * @param codec_tag codec tag to assign<br>
	 * @return the length of the string that would have been generated if<br>
	 * enough space had been available, excluding the trailing null<br>
	 * @deprecated see av_fourcc_make_string() and av_fourcc2str().<br>
	 * Original signature : <code>size_t av_get_codec_tag_string(char*, size_t, unsigned int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2264</i><br>
	 * @deprecated use the safer methods {@link #av_get_codec_tag_string(ByteBuffer, NativeSize, int)} and {@link #av_get_codec_tag_string(Pointer, NativeSize, int)} instead
	 */
	@Deprecated 
	NativeSize av_get_codec_tag_string(Pointer buf, NativeSize buf_size, int codec_tag);
	/**
	 * Put a string representing the codec tag codec_tag in buf.<br>
	 * @param buf       buffer to place codec tag in<br>
	 * @param buf_size size in bytes of buf<br>
	 * @param codec_tag codec tag to assign<br>
	 * @return the length of the string that would have been generated if<br>
	 * enough space had been available, excluding the trailing null<br>
	 * @deprecated see av_fourcc_make_string() and av_fourcc2str().<br>
	 * Original signature : <code>size_t av_get_codec_tag_string(char*, size_t, unsigned int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2264</i>
	 */
	NativeSize av_get_codec_tag_string(ByteBuffer buf, NativeSize buf_size, int codec_tag);
	/**
	 * Original signature : <code>void avcodec_string(char*, int, AVCodecContext*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2266</i><br>
	 * @deprecated use the safer methods {@link #avcodec_string(ByteBuffer, int, org.ffmpeg.avcodec57.AVCodecContext, int)} and {@link #avcodec_string(Pointer, int, org.ffmpeg.avcodec57.AVCodecContext, int)} instead
	 */
	@Deprecated 
	void avcodec_string(Pointer buf, int buf_size, AVCodecContext enc, int encode);
	/**
	 * Original signature : <code>void avcodec_string(char*, int, AVCodecContext*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2266</i>
	 */
	void avcodec_string(ByteBuffer buf, int buf_size, AVCodecContext enc, int encode);
	/**
	 * Return a name for the specified profile, if available.<br>
	 * @param codec the codec that is searched for the given profile<br>
	 * @param profile the profile value for which a name is requested<br>
	 * @return A name for the profile if found, NULL otherwise.<br>
	 * Original signature : <code>char* av_get_profile_name(const AVCodec*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2274</i>
	 */
	String av_get_profile_name(AVCodec codec, int profile);
	/**
	 * Return a name for the specified profile, if available.<br>
	 * @param codec_id the ID of the codec to which the requested profile belongs<br>
	 * @param profile the profile value for which a name is requested<br>
	 * @return A name for the profile if found, NULL otherwise.<br>
	 * @note unlike av_get_profile_name(), which searches a list of profiles<br>
	 *       supported by a specific decoder or encoder implementation, this<br>
	 *       function searches the list of profiles from the AVCodecDescriptor<br>
	 * Original signature : <code>char* avcodec_profile_name(AVCodecID, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2285</i>
	 */
	String avcodec_profile_name(int codec_id, int profile);
	/**
	 * Original signature : <code>int avcodec_default_execute(AVCodecContext*, avcodec_default_execute_func_callback*, void*, int*, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2287</i><br>
	 * @deprecated use the safer methods {@link #avcodec_default_execute(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.Avcodec57Library.avcodec_default_execute_func_callback, Pointer, IntBuffer, int, int)} and {@link #avcodec_default_execute(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.Avcodec57Library.avcodec_default_execute_func_callback, Pointer, IntByReference, int, int)} instead
	 */
	@Deprecated 
	int avcodec_default_execute(AVCodecContext c, avcodec_default_execute_func_callback func, Pointer arg, IntByReference ret, int count, int size);
	/**
	 * Original signature : <code>int avcodec_default_execute(AVCodecContext*, avcodec_default_execute_func_callback*, void*, int*, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2287</i>
	 */
	int avcodec_default_execute(AVCodecContext c, avcodec_default_execute_func_callback func, Pointer arg, IntBuffer ret, int count, int size);
	/**
	 * Original signature : <code>int avcodec_default_execute2(AVCodecContext*, avcodec_default_execute2_func_callback*, void*, int*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2289</i><br>
	 * @deprecated use the safer methods {@link #avcodec_default_execute2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.Avcodec57Library.avcodec_default_execute2_func_callback, Pointer, IntBuffer, int)} and {@link #avcodec_default_execute2(org.ffmpeg.avcodec57.AVCodecContext, org.ffmpeg.avcodec57.Avcodec57Library.avcodec_default_execute2_func_callback, Pointer, IntByReference, int)} instead
	 */
	@Deprecated 
	int avcodec_default_execute2(AVCodecContext c, avcodec_default_execute2_func_callback func, Pointer arg, IntByReference ret, int count);
	/**
	 * Original signature : <code>int avcodec_default_execute2(AVCodecContext*, avcodec_default_execute2_func_callback*, void*, int*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2289</i>
	 */
	int avcodec_default_execute2(AVCodecContext c, avcodec_default_execute2_func_callback func, Pointer arg, IntBuffer ret, int count);
	/**
	 * Fill AVFrame audio data and linesize pointers.<br>
	 * The buffer buf must be a preallocated buffer with a size big enough<br>
	 * to contain the specified samples amount. The filled AVFrame data<br>
	 * pointers will point to this buffer.<br>
	 * AVFrame extended_data channel pointers are allocated if necessary for<br>
	 * planar audio.<br>
	 * @param frame       the AVFrame<br>
	 *                    frame->nb_samples must be set prior to calling the<br>
	 *                    function. This function fills in frame->data,<br>
	 *                    frame->extended_data, frame->linesize[0].<br>
	 * @param nb_channels channel count<br>
	 * @param sample_fmt  sample format<br>
	 * @param buf         buffer to use for frame data<br>
	 * @param buf_size    size of buffer<br>
	 * @param align       plane size sample alignment (0 = default)<br>
	 * @return            >=0 on success, negative error code on failure<br>
	 * @todo return the size in bytes required to store the samples in<br>
	 * case of success, at the next libavutil bump<br>
	 * Original signature : <code>int avcodec_fill_audio_frame(AVFrame*, int, AVSampleFormat, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2311</i><br>
	 * @deprecated use the safer methods {@link #avcodec_fill_audio_frame(org.ffmpeg.avutil55.AVFrame, int, int, byte[], int, int)} and {@link #avcodec_fill_audio_frame(org.ffmpeg.avutil55.AVFrame, int, int, Pointer, int, int)} instead
	 */
	@Deprecated 
	int avcodec_fill_audio_frame(AVFrame frame, int nb_channels, int sample_fmt, Pointer buf, int buf_size, int align);
	/**
	 * Fill AVFrame audio data and linesize pointers.<br>
	 * The buffer buf must be a preallocated buffer with a size big enough<br>
	 * to contain the specified samples amount. The filled AVFrame data<br>
	 * pointers will point to this buffer.<br>
	 * AVFrame extended_data channel pointers are allocated if necessary for<br>
	 * planar audio.<br>
	 * @param frame       the AVFrame<br>
	 *                    frame->nb_samples must be set prior to calling the<br>
	 *                    function. This function fills in frame->data,<br>
	 *                    frame->extended_data, frame->linesize[0].<br>
	 * @param nb_channels channel count<br>
	 * @param sample_fmt  sample format<br>
	 * @param buf         buffer to use for frame data<br>
	 * @param buf_size    size of buffer<br>
	 * @param align       plane size sample alignment (0 = default)<br>
	 * @return            >=0 on success, negative error code on failure<br>
	 * @todo return the size in bytes required to store the samples in<br>
	 * case of success, at the next libavutil bump<br>
	 * Original signature : <code>int avcodec_fill_audio_frame(AVFrame*, int, AVSampleFormat, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2311</i>
	 */
	int avcodec_fill_audio_frame(AVFrame frame, int nb_channels, int sample_fmt, byte buf[], int buf_size, int align);
	/**
	 * Reset the internal decoder state / flush internal buffers. Should be called<br>
	 * e.g. when seeking or when switching to a different stream.<br>
	 * @note when refcounted frames are not used (i.e. avctx->refcounted_frames is 0),<br>
	 * this invalidates the frames previously returned from the decoder. When<br>
	 * refcounted frames are used, the decoder just releases any references it might<br>
	 * keep internally, but the caller's reference remains valid.<br>
	 * Original signature : <code>void avcodec_flush_buffers(AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2321</i>
	 */
	void avcodec_flush_buffers(AVCodecContext avctx);
	/**
	 * Return codec bits per sample.<br>
	 * @param[in] codec_id the codec<br>
	 * @return Number of bits per sample or zero if unknown for the given codec.<br>
	 * Original signature : <code>int av_get_bits_per_sample(AVCodecID)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2328</i>
	 */
	int av_get_bits_per_sample(int codec_id);
	/**
	 * Return the PCM codec associated with a sample format.<br>
	 * @param be  endianness, 0 for little, 1 for big,<br>
	 *            -1 (or anything else) for native<br>
	 * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE<br>
	 * Original signature : <code>AVCodecID av_get_pcm_codec(AVSampleFormat, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2336</i>
	 */
	int av_get_pcm_codec(int fmt, int be);
	/**
	 * Return codec bits per sample.<br>
	 * Only return non-zero if the bits per sample is exactly correct, not an<br>
	 * approximation.<br>
	 * @param[in] codec_id the codec<br>
	 * @return Number of bits per sample or zero if unknown for the given codec.<br>
	 * Original signature : <code>int av_get_exact_bits_per_sample(AVCodecID)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2345</i>
	 */
	int av_get_exact_bits_per_sample(int codec_id);
	/**
	 * Return audio frame duration.<br>
	 * @param avctx        codec context<br>
	 * @param frame_bytes  size of the frame, or 0 if unknown<br>
	 * @return             frame duration, in samples, if known. 0 if not able to<br>
	 *                     determine.<br>
	 * Original signature : <code>int av_get_audio_frame_duration(AVCodecContext*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2354</i>
	 */
	int av_get_audio_frame_duration(AVCodecContext avctx, int frame_bytes);
	/**
	 * This function is the same as av_get_audio_frame_duration(), except it works<br>
	 * with AVCodecParameters instead of an AVCodecContext.<br>
	 * Original signature : <code>int av_get_audio_frame_duration2(AVCodecParameters*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2360</i>
	 */
	int av_get_audio_frame_duration2(AVCodecParameters par, int frame_bytes);
	/**
	 * Register a bitstream filter.<br>
	 * The filter will be accessible to the application code through<br>
	 * av_bitstream_filter_next() or can be directly initialized with<br>
	 * av_bitstream_filter_init().<br>
	 * @see avcodec_register_all()<br>
	 * Original signature : <code>void av_register_bitstream_filter(AVBitStreamFilter*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2411</i>
	 */
	void av_register_bitstream_filter(AVBitStreamFilter bsf);
	/**
	 * Create and initialize a bitstream filter context given a bitstream<br>
	 * filter name.<br>
	 * The returned context must be freed with av_bitstream_filter_close().<br>
	 * @param name    the name of the bitstream filter<br>
	 * @return a bitstream filter context if a matching filter was found<br>
	 * and successfully initialized, NULL otherwise<br>
	 * Original signature : <code>AVBitStreamFilterContext* av_bitstream_filter_init(const char*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2421</i><br>
	 * @deprecated use the safer methods {@link #av_bitstream_filter_init(String)} and {@link #av_bitstream_filter_init(Pointer)} instead
	 */
	@Deprecated 
	AVBitStreamFilterContext av_bitstream_filter_init(Pointer name);
	/**
	 * Create and initialize a bitstream filter context given a bitstream<br>
	 * filter name.<br>
	 * The returned context must be freed with av_bitstream_filter_close().<br>
	 * @param name    the name of the bitstream filter<br>
	 * @return a bitstream filter context if a matching filter was found<br>
	 * and successfully initialized, NULL otherwise<br>
	 * Original signature : <code>AVBitStreamFilterContext* av_bitstream_filter_init(const char*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2421</i>
	 */
	AVBitStreamFilterContext av_bitstream_filter_init(String name);
	/**
	 * Filter bitstream.<br>
	 * This function filters the buffer buf with size buf_size, and places the<br>
	 * filtered buffer in the buffer pointed to by poutbuf.<br>
	 * The output buffer must be freed by the caller.<br>
	 * @param bsfc            bitstream filter context created by av_bitstream_filter_init()<br>
	 * @param avctx           AVCodecContext accessed by the filter, may be NULL.<br>
	 *                        If specified, this must point to the encoder context of the<br>
	 *                        output stream the packet is sent to.<br>
	 * @param args            arguments which specify the filter configuration, may be NULL<br>
	 * @param poutbuf         pointer which is updated to point to the filtered buffer<br>
	 * @param poutbuf_size    pointer which is updated to the filtered buffer size in bytes<br>
	 * @param buf             buffer containing the data to filter<br>
	 * @param buf_size        size in bytes of buf<br>
	 * @param keyframe        set to non-zero if the buffer to filter corresponds to a key-frame packet data<br>
	 * @return >= 0 in case of success, or a negative error code in case of failure<br>
	 * If the return value is positive, an output buffer is allocated and<br>
	 * is available in *poutbuf, and is distinct from the input buffer.<br>
	 * If the return value is 0, the output buffer is not allocated and<br>
	 * should be considered identical to the input buffer, or in case<br>
	 * *poutbuf was set it points to the input buffer (not necessarily to<br>
	 * its starting address). A special case is if *poutbuf was set to NULL and<br>
	 * *poutbuf_size was set to 0, which indicates the packet should be dropped.<br>
	 * Original signature : <code>int av_bitstream_filter_filter(AVBitStreamFilterContext*, AVCodecContext*, const char*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2447</i><br>
	 * @deprecated use the safer methods {@link #av_bitstream_filter_filter(org.ffmpeg.avcodec57.AVBitStreamFilterContext, org.ffmpeg.avcodec57.AVCodecContext, String, PointerByReference, IntBuffer, byte[], int, int)} and {@link #av_bitstream_filter_filter(org.ffmpeg.avcodec57.AVBitStreamFilterContext, org.ffmpeg.avcodec57.AVCodecContext, Pointer, PointerByReference, IntByReference, Pointer, int, int)} instead
	 */
	@Deprecated 
	int av_bitstream_filter_filter(AVBitStreamFilterContext bsfc, AVCodecContext avctx, Pointer args, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, int keyframe);
	/**
	 * Filter bitstream.<br>
	 * This function filters the buffer buf with size buf_size, and places the<br>
	 * filtered buffer in the buffer pointed to by poutbuf.<br>
	 * The output buffer must be freed by the caller.<br>
	 * @param bsfc            bitstream filter context created by av_bitstream_filter_init()<br>
	 * @param avctx           AVCodecContext accessed by the filter, may be NULL.<br>
	 *                        If specified, this must point to the encoder context of the<br>
	 *                        output stream the packet is sent to.<br>
	 * @param args            arguments which specify the filter configuration, may be NULL<br>
	 * @param poutbuf         pointer which is updated to point to the filtered buffer<br>
	 * @param poutbuf_size    pointer which is updated to the filtered buffer size in bytes<br>
	 * @param buf             buffer containing the data to filter<br>
	 * @param buf_size        size in bytes of buf<br>
	 * @param keyframe        set to non-zero if the buffer to filter corresponds to a key-frame packet data<br>
	 * @return >= 0 in case of success, or a negative error code in case of failure<br>
	 * If the return value is positive, an output buffer is allocated and<br>
	 * is available in *poutbuf, and is distinct from the input buffer.<br>
	 * If the return value is 0, the output buffer is not allocated and<br>
	 * should be considered identical to the input buffer, or in case<br>
	 * *poutbuf was set it points to the input buffer (not necessarily to<br>
	 * its starting address). A special case is if *poutbuf was set to NULL and<br>
	 * *poutbuf_size was set to 0, which indicates the packet should be dropped.<br>
	 * Original signature : <code>int av_bitstream_filter_filter(AVBitStreamFilterContext*, AVCodecContext*, const char*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2447</i>
	 */
	int av_bitstream_filter_filter(AVBitStreamFilterContext bsfc, AVCodecContext avctx, String args, PointerByReference poutbuf, IntBuffer poutbuf_size, byte buf[], int buf_size, int keyframe);
	/**
	 * Release bitstream filter context.<br>
	 * @param bsf the bitstream filter context created with<br>
	 * av_bitstream_filter_init(), can be NULL<br>
	 * Original signature : <code>void av_bitstream_filter_close(AVBitStreamFilterContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2454</i>
	 */
	void av_bitstream_filter_close(AVBitStreamFilterContext bsf);
	/**
	 * If f is NULL, return the first registered bitstream filter,<br>
	 * if f is non-NULL, return the next registered bitstream filter<br>
	 * after f, or NULL if f is the last one.<br>
	 * This function can be used to iterate over all registered bitstream<br>
	 * filters.<br>
	 * Original signature : <code>AVBitStreamFilter* av_bitstream_filter_next(const AVBitStreamFilter*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2463</i>
	 */
	AVBitStreamFilter av_bitstream_filter_next(AVBitStreamFilter f);
	/**
	 * @return a bitstream filter with the specified name or NULL if no such<br>
	 *         bitstream filter exists.<br>
	 * Original signature : <code>AVBitStreamFilter* av_bsf_get_by_name(const char*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2469</i><br>
	 * @deprecated use the safer methods {@link #av_bsf_get_by_name(String)} and {@link #av_bsf_get_by_name(Pointer)} instead
	 */
	@Deprecated 
	AVBitStreamFilter av_bsf_get_by_name(Pointer name);
	/**
	 * @return a bitstream filter with the specified name or NULL if no such<br>
	 *         bitstream filter exists.<br>
	 * Original signature : <code>AVBitStreamFilter* av_bsf_get_by_name(const char*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2469</i>
	 */
	AVBitStreamFilter av_bsf_get_by_name(String name);
	/**
	 * Iterate over all registered bitstream filters.<br>
	 * @param opaque a pointer where libavcodec will store the iteration state. Must<br>
	 *               point to NULL to start the iteration.<br>
	 * @return the next registered bitstream filter or NULL when the iteration is<br>
	 *         finished<br>
	 * Original signature : <code>AVBitStreamFilter* av_bsf_next(void**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2478</i>
	 */
	AVBitStreamFilter av_bsf_next(PointerByReference opaque);
	/**
	 * Allocate a context for a given bitstream filter. The caller must fill in the<br>
	 * context parameters as described in the documentation and then call<br>
	 * av_bsf_init() before sending any data to the filter.<br>
	 * @param filter the filter for which to allocate an instance.<br>
	 * @param ctx a pointer into which the pointer to the newly-allocated context<br>
	 *            will be written. It must be freed with av_bsf_free() after the<br>
	 *            filtering is done.<br>
	 * @return 0 on success, a negative AVERROR code on failure<br>
	 * Original signature : <code>int av_bsf_alloc(const AVBitStreamFilter*, AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2490</i><br>
	 * @deprecated use the safer method {@link #av_bsf_alloc(org.ffmpeg.avcodec57.AVBitStreamFilter, org.ffmpeg.avcodec57.AVBSFContext.ByReference[])} instead
	 */
	@Deprecated 
	int av_bsf_alloc(AVBitStreamFilter filter, PointerByReference ctx);
	/**
	 * Allocate a context for a given bitstream filter. The caller must fill in the<br>
	 * context parameters as described in the documentation and then call<br>
	 * av_bsf_init() before sending any data to the filter.<br>
	 * @param filter the filter for which to allocate an instance.<br>
	 * @param ctx a pointer into which the pointer to the newly-allocated context<br>
	 *            will be written. It must be freed with av_bsf_free() after the<br>
	 *            filtering is done.<br>
	 * @return 0 on success, a negative AVERROR code on failure<br>
	 * Original signature : <code>int av_bsf_alloc(const AVBitStreamFilter*, AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2490</i>
	 */
	int av_bsf_alloc(AVBitStreamFilter filter, AVBSFContext.ByReference ctx[]);
	/**
	 * Prepare the filter for use, after all the parameters and options have been<br>
	 * set.<br>
	 * Original signature : <code>int av_bsf_init(AVBSFContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2496</i>
	 */
	int av_bsf_init(AVBSFContext ctx);
	/**
	 * Submit a packet for filtering.<br>
	 * After sending each packet, the filter must be completely drained by calling<br>
	 * av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or<br>
	 * AVERROR_EOF.<br>
	 * @param pkt the packet to filter. pkt must contain some payload (i.e data or<br>
	 * side data must be present in pkt). The bitstream filter will take ownership of<br>
	 * the packet and reset the contents of pkt. pkt is not touched if an error occurs.<br>
	 * This parameter may be NULL, which signals the end of the stream (i.e. no more<br>
	 * packets will be sent). That will cause the filter to output any packets it<br>
	 * may have buffered internally.<br>
	 * @return 0 on success, a negative AVERROR on error.<br>
	 * Original signature : <code>int av_bsf_send_packet(AVBSFContext*, AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2511</i>
	 */
	int av_bsf_send_packet(AVBSFContext ctx, AVPacket pkt);
	/**
	 * Retrieve a filtered packet.<br>
	 * @param[out] pkt this struct will be filled with the contents of the filtered<br>
	 *                 packet. It is owned by the caller and must be freed using<br>
	 *                 av_packet_unref() when it is no longer needed.<br>
	 *                 This parameter should be "clean" (i.e. freshly allocated<br>
	 *                 with av_packet_alloc() or unreffed with av_packet_unref())<br>
	 *                 when this function is called. If this function returns<br>
	 *                 successfully, the contents of pkt will be completely<br>
	 *                 overwritten by the returned data. On failure, pkt is not<br>
	 *                 touched.<br>
	 * @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the<br>
	 * filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there<br>
	 * will be no further output from the filter. Another negative AVERROR value if<br>
	 * an error occurs.<br>
	 * @note one input packet may result in several output packets, so after sending<br>
	 * a packet with av_bsf_send_packet(), this function needs to be called<br>
	 * repeatedly until it stops returning 0. It is also possible for a filter to<br>
	 * output fewer packets than were sent to it, so this function may return<br>
	 * AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.<br>
	 * Original signature : <code>int av_bsf_receive_packet(AVBSFContext*, AVPacket*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2534</i>
	 */
	int av_bsf_receive_packet(AVBSFContext ctx, AVPacket pkt);
	/**
	 * Free a bitstream filter context and everything associated with it; write NULL<br>
	 * into the supplied pointer.<br>
	 * Original signature : <code>void av_bsf_free(AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2540</i><br>
	 * @deprecated use the safer method {@link #av_bsf_free(org.ffmpeg.avcodec57.AVBSFContext.ByReference[])} instead
	 */
	@Deprecated 
	void av_bsf_free(PointerByReference ctx);
	/**
	 * Free a bitstream filter context and everything associated with it; write NULL<br>
	 * into the supplied pointer.<br>
	 * Original signature : <code>void av_bsf_free(AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2540</i>
	 */
	void av_bsf_free(AVBSFContext.ByReference ctx[]);
	/**
	 * Get the Pointer for AVBSFContext. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * @see av_opt_find().<br>
	 * Original signature : <code>Pointer* av_bsf_get_class()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2547</i>
	 */
	Pointer av_bsf_get_class();
	/**
	 * Allocate empty list of bitstream filters.<br>
	 * The list must be later freed by av_bsf_list_free()<br>
	 * or finalized by av_bsf_list_finalize().<br>
	 * @return Pointer to @ref AVBSFList on success, NULL in case of failure<br>
	 * Original signature : <code>AVBSFList* av_bsf_list_alloc()</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2562</i>
	 */
	AVBSFList av_bsf_list_alloc();
	/**
	 * Free list of bitstream filters.<br>
	 * @param lst Pointer to pointer returned by av_bsf_list_alloc()<br>
	 * Original signature : <code>void av_bsf_list_free(AVBSFList**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2568</i><br>
	 * @deprecated use the safer method {@link #av_bsf_list_free(org.ffmpeg.avcodec57.AVBSFList.ByReference[])} instead
	 */
	@Deprecated 
	void av_bsf_list_free(PointerByReference lst);
	/**
	 * Free list of bitstream filters.<br>
	 * @param lst Pointer to pointer returned by av_bsf_list_alloc()<br>
	 * Original signature : <code>void av_bsf_list_free(AVBSFList**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2568</i>
	 */
	void av_bsf_list_free(AVBSFList.ByReference lst[]);
	/**
	 * Append bitstream filter to the list of bitstream filters.<br>
	 * @param lst List to append to<br>
	 * @param bsf Filter context to be appended<br>
	 * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_append(AVBSFList*, AVBSFContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2576</i>
	 */
	int av_bsf_list_append(AVBSFList lst, AVBSFContext bsf);
	/**
	 * Construct new bitstream filter context given it's name and options<br>
	 * and append it to the list of bitstream filters.<br>
	 * @param lst      List to append to<br>
	 * @param bsf_name Name of the bitstream filter<br>
	 * @param options  Options for the bitstream filter, can be set to NULL<br>
	 * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_append2(AVBSFList*, const char*, AVDictionary**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2586</i><br>
	 * @deprecated use the safer methods {@link #av_bsf_list_append2(org.ffmpeg.avcodec57.AVBSFList, String, org.ffmpeg.avutil55.AVDictionary.ByReference[])} and {@link #av_bsf_list_append2(org.ffmpeg.avcodec57.AVBSFList, Pointer, org.ffmpeg.avutil55.AVDictionary.ByReference[])} instead
	 */
	@Deprecated 
	int av_bsf_list_append2(AVBSFList lst, Pointer bsf_name, PointerByReference options);
	/**
	 * Construct new bitstream filter context given it's name and options<br>
	 * and append it to the list of bitstream filters.<br>
	 * @param lst      List to append to<br>
	 * @param bsf_name Name of the bitstream filter<br>
	 * @param options  Options for the bitstream filter, can be set to NULL<br>
	 * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_append2(AVBSFList*, const char*, AVDictionary**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2586</i>
	 */
	int av_bsf_list_append2(AVBSFList lst, String bsf_name, AVDictionary.ByReference options[]);
	/**
	 * Construct new bitstream filter context given it's name and options<br>
	 * and append it to the list of bitstream filters.<br>
	 * @param lst      List to append to<br>
	 * @param bsf_name Name of the bitstream filter<br>
	 * @param options  Options for the bitstream filter, can be set to NULL<br>
	 * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_append2(AVBSFList*, const char*, AVDictionary**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2586</i>
	 */
	int av_bsf_list_append2(AVBSFList lst, Pointer bsf_name, AVDictionary.ByReference options[]);
	/**
	 * Finalize list of bitstream filters.<br>
	 * This function will transform @ref AVBSFList to single @ref AVBSFContext,<br>
	 * so the whole chain of bitstream filters can be treated as single filter<br>
	 * freshly allocated by av_bsf_alloc().<br>
	 * If the call is successful, @ref AVBSFList structure is freed and lst<br>
	 * will be set to NULL. In case of failure, caller is responsible for<br>
	 * freeing the structure by av_bsf_list_free()<br>
	 * @param      lst Filter list structure to be transformed<br>
	 * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure<br>
	 *                 representing the chain of bitstream filters<br>
	 * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_finalize(AVBSFList**, AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2601</i><br>
	 * @deprecated use the safer method {@link #av_bsf_list_finalize(org.ffmpeg.avcodec57.AVBSFList.ByReference[], org.ffmpeg.avcodec57.AVBSFContext.ByReference[])} instead
	 */
	@Deprecated 
	int av_bsf_list_finalize(PointerByReference lst, PointerByReference bsf);
	/**
	 * Finalize list of bitstream filters.<br>
	 * This function will transform @ref AVBSFList to single @ref AVBSFContext,<br>
	 * so the whole chain of bitstream filters can be treated as single filter<br>
	 * freshly allocated by av_bsf_alloc().<br>
	 * If the call is successful, @ref AVBSFList structure is freed and lst<br>
	 * will be set to NULL. In case of failure, caller is responsible for<br>
	 * freeing the structure by av_bsf_list_free()<br>
	 * @param      lst Filter list structure to be transformed<br>
	 * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure<br>
	 *                 representing the chain of bitstream filters<br>
	 * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_finalize(AVBSFList**, AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2601</i>
	 */
	int av_bsf_list_finalize(AVBSFList.ByReference lst[], AVBSFContext.ByReference bsf[]);
	/**
	 * Parse string describing list of bitstream filters and create single<br>
	 * @ref AVBSFContext describing the whole chain of bitstream filters.<br>
	 * Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly<br>
	 * allocated by av_bsf_alloc().<br>
	 * @param      str String describing chain of bitstream filters in format<br>
	 *                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`<br>
	 * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure<br>
	 *                 representing the chain of bitstream filters<br>
	 * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_parse_str(const char*, AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2614</i><br>
	 * @deprecated use the safer methods {@link #av_bsf_list_parse_str(String, org.ffmpeg.avcodec57.AVBSFContext.ByReference[])} and {@link #av_bsf_list_parse_str(Pointer, org.ffmpeg.avcodec57.AVBSFContext.ByReference[])} instead
	 */
	@Deprecated 
	int av_bsf_list_parse_str(Pointer str, PointerByReference bsf);
	/**
	 * Parse string describing list of bitstream filters and create single<br>
	 * @ref AVBSFContext describing the whole chain of bitstream filters.<br>
	 * Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly<br>
	 * allocated by av_bsf_alloc().<br>
	 * @param      str String describing chain of bitstream filters in format<br>
	 *                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`<br>
	 * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure<br>
	 *                 representing the chain of bitstream filters<br>
	 * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_parse_str(const char*, AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2614</i>
	 */
	int av_bsf_list_parse_str(String str, AVBSFContext.ByReference bsf[]);
	/**
	 * Parse string describing list of bitstream filters and create single<br>
	 * @ref AVBSFContext describing the whole chain of bitstream filters.<br>
	 * Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly<br>
	 * allocated by av_bsf_alloc().<br>
	 * @param      str String describing chain of bitstream filters in format<br>
	 *                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`<br>
	 * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure<br>
	 *                 representing the chain of bitstream filters<br>
	 * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_parse_str(const char*, AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2614</i>
	 */
	int av_bsf_list_parse_str(Pointer str, AVBSFContext.ByReference bsf[]);
	/**
	 * Get null/pass-through bitstream filter.<br>
	 * @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter<br>
	 * @return<br>
	 * Original signature : <code>int av_bsf_get_null_filter(AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2621</i><br>
	 * @deprecated use the safer method {@link #av_bsf_get_null_filter(org.ffmpeg.avcodec57.AVBSFContext.ByReference[])} instead
	 */
	@Deprecated 
	int av_bsf_get_null_filter(PointerByReference bsf);
	/**
	 * Get null/pass-through bitstream filter.<br>
	 * @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter<br>
	 * @return<br>
	 * Original signature : <code>int av_bsf_get_null_filter(AVBSFContext**)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2621</i>
	 */
	int av_bsf_get_null_filter(AVBSFContext.ByReference bsf[]);
	/**
	 * Same behaviour av_fast_malloc but the buffer has additional<br>
	 * AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.<br>
	 * In addition the whole buffer will initially and after resizes<br>
	 * be 0-initialized so that no uninitialized data will ever appear.<br>
	 * Original signature : <code>void av_fast_padded_malloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2629</i><br>
	 * @deprecated use the safer methods {@link #av_fast_padded_malloc(Pointer, IntBuffer, NativeSize)} and {@link #av_fast_padded_malloc(Pointer, IntByReference, NativeSize)} instead
	 */
	@Deprecated 
	void av_fast_padded_malloc(Pointer ptr, IntByReference size, NativeSize min_size);
	/**
	 * Same behaviour av_fast_malloc but the buffer has additional<br>
	 * AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.<br>
	 * In addition the whole buffer will initially and after resizes<br>
	 * be 0-initialized so that no uninitialized data will ever appear.<br>
	 * Original signature : <code>void av_fast_padded_malloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2629</i>
	 */
	void av_fast_padded_malloc(Pointer ptr, IntBuffer size, NativeSize min_size);
	/**
	 * Same behaviour av_fast_padded_malloc except that buffer will always<br>
	 * be 0-initialized after call.<br>
	 * Original signature : <code>void av_fast_padded_mallocz(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2635</i><br>
	 * @deprecated use the safer methods {@link #av_fast_padded_mallocz(Pointer, IntBuffer, NativeSize)} and {@link #av_fast_padded_mallocz(Pointer, IntByReference, NativeSize)} instead
	 */
	@Deprecated 
	void av_fast_padded_mallocz(Pointer ptr, IntByReference size, NativeSize min_size);
	/**
	 * Same behaviour av_fast_padded_malloc except that buffer will always<br>
	 * be 0-initialized after call.<br>
	 * Original signature : <code>void av_fast_padded_mallocz(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2635</i>
	 */
	void av_fast_padded_mallocz(Pointer ptr, IntBuffer size, NativeSize min_size);
	/**
	 * Encode extradata length to a buffer. Used by xiph codecs.<br>
	 * @param s buffer to write to; must be at least (v/255+1) bytes long<br>
	 * @param v size of extradata in bytes<br>
	 * @return number of bytes written to the buffer.<br>
	 * Original signature : <code>int av_xiphlacing(unsigned char*, unsigned int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2643</i><br>
	 * @deprecated use the safer methods {@link #av_xiphlacing(ByteBuffer, int)} and {@link #av_xiphlacing(Pointer, int)} instead
	 */
	@Deprecated 
	int av_xiphlacing(Pointer s, int v);
	/**
	 * Encode extradata length to a buffer. Used by xiph codecs.<br>
	 * @param s buffer to write to; must be at least (v/255+1) bytes long<br>
	 * @param v size of extradata in bytes<br>
	 * @return number of bytes written to the buffer.<br>
	 * Original signature : <code>int av_xiphlacing(unsigned char*, unsigned int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2643</i>
	 */
	int av_xiphlacing(ByteBuffer s, int v);
	/**
	 * Log a generic warning message about a missing feature. This function is<br>
	 * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an Pointer struct<br>
	 * @param[in] feature string containing the name of the missing feature<br>
	 * @param[in] want_sample indicates if samples are wanted which exhibit this feature.<br>
	 * If want_sample is non-zero, additional verbiage will be added to the log<br>
	 * message which tells the user how to report samples to the development<br>
	 * mailing list.<br>
	 * @deprecated Use avpriv_report_missing_feature() instead.<br>
	 * Original signature : <code>void av_log_missing_feature(void*, const char*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2658</i><br>
	 * @deprecated use the safer methods {@link #av_log_missing_feature(Pointer, String, int)} and {@link #av_log_missing_feature(Pointer, Pointer, int)} instead
	 */
	@Deprecated 
	void av_log_missing_feature(Pointer avc, Pointer feature, int want_sample);
	/**
	 * Log a generic warning message about a missing feature. This function is<br>
	 * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an Pointer struct<br>
	 * @param[in] feature string containing the name of the missing feature<br>
	 * @param[in] want_sample indicates if samples are wanted which exhibit this feature.<br>
	 * If want_sample is non-zero, additional verbiage will be added to the log<br>
	 * message which tells the user how to report samples to the development<br>
	 * mailing list.<br>
	 * @deprecated Use avpriv_report_missing_feature() instead.<br>
	 * Original signature : <code>void av_log_missing_feature(void*, const char*, int)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2658</i>
	 */
	void av_log_missing_feature(Pointer avc, String feature, int want_sample);
	/**
	 * Log a generic warning message asking for a sample. This function is<br>
	 * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an Pointer struct<br>
	 * @param[in] msg string containing an optional message, or NULL if no message<br>
	 * @deprecated Use avpriv_request_sample() instead.<br>
	 * Original signature : <code>void av_log_ask_for_sample(void*, const char*, null)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2669</i><br>
	 * @deprecated use the safer methods {@link #av_log_ask_for_sample(Pointer, String, Object)} and {@link #av_log_ask_for_sample(Pointer, Pointer, Object)} instead
	 */
	@Deprecated 
	void av_log_ask_for_sample(Pointer avc, Pointer msg, Object... varArgs1);
	/**
	 * Log a generic warning message asking for a sample. This function is<br>
	 * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an Pointer struct<br>
	 * @param[in] msg string containing an optional message, or NULL if no message<br>
	 * @deprecated Use avpriv_request_sample() instead.<br>
	 * Original signature : <code>void av_log_ask_for_sample(void*, const char*, null)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2669</i>
	 */
	void av_log_ask_for_sample(Pointer avc, String msg, Object... varArgs1);
	/**
	 * Register the hardware accelerator hwaccel.<br>
	 * Original signature : <code>void av_register_hwaccel(AVHWAccel*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2674</i>
	 */
	void av_register_hwaccel(AVHWAccel hwaccel);
	/**
	 * If hwaccel is NULL, returns the first registered hardware accelerator,<br>
	 * if hwaccel is non-NULL, returns the next registered hardware accelerator<br>
	 * after hwaccel, or NULL if hwaccel is the last one.<br>
	 * Original signature : <code>AVHWAccel* av_hwaccel_next(const AVHWAccel*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2681</i>
	 */
	AVHWAccel av_hwaccel_next(AVHWAccel hwaccel);
	/**
	 * Get the type of the given codec.<br>
	 * Original signature : <code>AVMediaType avcodec_get_type(AVCodecID)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2697</i>
	 */
	int avcodec_get_type(int codec_id);
	/**
	 * Get the name of a codec.<br>
	 * @return  a static string identifying the codec; never NULL<br>
	 * Original signature : <code>char* avcodec_get_name(AVCodecID)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2703</i>
	 */
	String avcodec_get_name(int id);
	/**
	 * @return a positive value if s is open (i.e. avcodec_open2() was called on it<br>
	 * with no corresponding avcodec_close()), 0 otherwise.<br>
	 * Original signature : <code>int avcodec_is_open(AVCodecContext*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2709</i>
	 */
	int avcodec_is_open(AVCodecContext s);
	/**
	 * @return a non-zero number if codec is an encoder, zero otherwise<br>
	 * Original signature : <code>int av_codec_is_encoder(const AVCodec*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2714</i>
	 */
	int av_codec_is_encoder(AVCodec codec);
	/**
	 * @return a non-zero number if codec is a decoder, zero otherwise<br>
	 * Original signature : <code>int av_codec_is_decoder(const AVCodec*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2719</i>
	 */
	int av_codec_is_decoder(AVCodec codec);
	/**
	 * @return descriptor for given codec ID or NULL if no descriptor exists.<br>
	 * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_get(AVCodecID)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2724</i>
	 */
	AVCodecDescriptor avcodec_descriptor_get(int id);
	/**
	 * Iterate over all codec descriptors known to libavcodec.<br>
	 * @param prev previous descriptor. NULL to get the first descriptor.<br>
	 * @return next descriptor or NULL after the last descriptor<br>
	 * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_next(const AVCodecDescriptor*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2731</i>
	 */
	AVCodecDescriptor avcodec_descriptor_next(AVCodecDescriptor prev);
	/**
	 * @return codec descriptor with the given name or NULL if no such descriptor<br>
	 *         exists.<br>
	 * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_get_by_name(const char*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2737</i><br>
	 * @deprecated use the safer methods {@link #avcodec_descriptor_get_by_name(String)} and {@link #avcodec_descriptor_get_by_name(Pointer)} instead
	 */
	@Deprecated 
	AVCodecDescriptor avcodec_descriptor_get_by_name(Pointer name);
	/**
	 * @return codec descriptor with the given name or NULL if no such descriptor<br>
	 *         exists.<br>
	 * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_get_by_name(const char*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2737</i>
	 */
	AVCodecDescriptor avcodec_descriptor_get_by_name(String name);
	/**
	 * Allocate a CPB properties structure and initialize its fields to default<br>
	 * values.<br>
	 * @param size if non-NULL, the size of the allocated struct will be written<br>
	 *             here. This is useful for embedding it in side data.<br>
	 * @return the newly allocated struct or NULL on failure<br>
	 * Original signature : <code>AVCPBProperties* av_cpb_properties_alloc(size_t*)</code><br>
	 * <i>native declaration : .\libavcodec\avcodec.h:2746</i>
	 */
	AVCPBProperties av_cpb_properties_alloc(NativeSizeByReference size);
	public static class AVResampleContext extends PointerType {
		public AVResampleContext(Pointer address) {
			super(address);
		}
		public AVResampleContext() {
			super();
		}
	};
	public static class MpegEncContext extends PointerType {
		public MpegEncContext(Pointer address) {
			super(address);
		}
		public MpegEncContext() {
			super();
		}
	};
}
