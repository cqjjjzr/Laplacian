package org.ffmpeg.avutil55;
import com.ochafik.lang.jnaerator.runtime.NativeSize;
import com.ochafik.lang.jnaerator.runtime.NativeSizeByReference;
import com.sun.jna.*;
import com.sun.jna.ptr.*;
import org.ffmpeg.avformat57.Avformat57Library.AVBPrint;
import org.ffmpeg.avformat57.Avformat57Library.FILE;

import java.nio.*;

/**
 * JNA Wrapper for library <b>avutil-55</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Avutil55Library extends Library {
	public static final String JNA_LIBRARY_NAME = "avutil-55";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(Avutil55Library.JNA_LIBRARY_NAME);
	public static final Avutil55Library INSTANCE = (Avutil55Library)Native.loadLibrary(Avutil55Library.JNA_LIBRARY_NAME, Avutil55Library.class);
	/**
	 * @addtogroup lavu_media Media Type<br>
	 * @brief Media Type<br>
	 * <i>native declaration : libavutil\avutil.h:37</i><br>
	 * enum values
	 */
	public static interface AVMediaType {
		/**
		 * < Usually treated as AVMEDIA_TYPE_DATA<br>
		 * <i>native declaration : libavutil\avutil.h:28</i>
		 */
		public static final int AVMEDIA_TYPE_UNKNOWN = -1;
		/** <i>native declaration : libavutil\avutil.h:29</i> */
		public static final int AVMEDIA_TYPE_VIDEO = 0;
		/** <i>native declaration : libavutil\avutil.h:30</i> */
		public static final int AVMEDIA_TYPE_AUDIO = 1;
		/**
		 * < Opaque data information usually continuous<br>
		 * <i>native declaration : libavutil\avutil.h:32</i>
		 */
		public static final int AVMEDIA_TYPE_DATA = 2;
		/** <i>native declaration : libavutil\avutil.h:33</i> */
		public static final int AVMEDIA_TYPE_SUBTITLE = 3;
		/**
		 * < Opaque data information usually sparse<br>
		 * <i>native declaration : libavutil\avutil.h:35</i>
		 */
		public static final int AVMEDIA_TYPE_ATTACHMENT = 4;
		/** <i>native declaration : libavutil\avutil.h:36</i> */
		public static final int AVMEDIA_TYPE_NB = 5;
	};
	/**
	 * @}<br>
	 * @}<br>
	 * @defgroup lavu_picture Image related<br>
	 * AVPicture types, pixel formats and basic image planes manipulation.<br>
	 * @{<br>
	 * <i>native declaration : libavutil\avutil.h:68</i><br>
	 * enum values
	 */
	public static interface AVPictureType {
		/**
		 * < Undefined<br>
		 * <i>native declaration : libavutil\avutil.h:53</i>
		 */
		public static final int AV_PICTURE_TYPE_NONE = 0;
		/**
		 * < Intra<br>
		 * <i>native declaration : libavutil\avutil.h:55</i>
		 */
		public static final int AV_PICTURE_TYPE_I = 1;
		/**
		 * < Predicted<br>
		 * <i>native declaration : libavutil\avutil.h:57</i>
		 */
		public static final int AV_PICTURE_TYPE_P = 2;
		/**
		 * < Bi-dir predicted<br>
		 * <i>native declaration : libavutil\avutil.h:59</i>
		 */
		public static final int AV_PICTURE_TYPE_B = 3;
		/**
		 * < S(GMC)-VOP MPEG-4<br>
		 * <i>native declaration : libavutil\avutil.h:61</i>
		 */
		public static final int AV_PICTURE_TYPE_S = 4;
		/**
		 * < Switching Intra<br>
		 * <i>native declaration : libavutil\avutil.h:63</i>
		 */
		public static final int AV_PICTURE_TYPE_SI = 5;
		/**
		 * < Switching Predicted<br>
		 * <i>native declaration : libavutil\avutil.h:65</i>
		 */
		public static final int AV_PICTURE_TYPE_SP = 6;
		/**
		 * < BI type<br>
		 * <i>native declaration : libavutil\avutil.h:67</i>
		 */
		public static final int AV_PICTURE_TYPE_BI = 7;
	};
	/**
	 * Rounding methods.<br>
	 * <i>native declaration : libavutil\mathematics.h:13</i><br>
	 * enum values
	 */
	public static interface AVRounding {
		/**
		 * < Round toward zero.<br>
		 * <i>native declaration : libavutil\mathematics.h:3</i>
		 */
		public static final int AV_ROUND_ZERO = 0;
		/**
		 * < Round away from zero.<br>
		 * <i>native declaration : libavutil\mathematics.h:5</i>
		 */
		public static final int AV_ROUND_INF = 1;
		/**
		 * < Round toward -infinity.<br>
		 * <i>native declaration : libavutil\mathematics.h:7</i>
		 */
		public static final int AV_ROUND_DOWN = 2;
		/**
		 * < Round toward +infinity.<br>
		 * <i>native declaration : libavutil\mathematics.h:9</i>
		 */
		public static final int AV_ROUND_UP = 3;
		/**
		 * < Round to nearest and halfway cases away from zero.<br>
		 * <i>native declaration : libavutil\mathematics.h:11</i>
		 */
		public static final int AV_ROUND_NEAR_INF = 5;
		/** <i>native declaration : libavutil\mathematics.h:12</i> */
		public static final int AV_ROUND_PASS_MINMAX = 8192;
	};
	/**
	 * <i>native declaration : libavutil\log.h:20</i><br>
	 * enum values
	 */
	public static interface AVClassCategory {
		/** <i>native declaration : libavutil\log.h:1</i> */
		public static final int AV_CLASS_CATEGORY_NA = 0;
		/** <i>native declaration : libavutil\log.h:2</i> */
		public static final int AV_CLASS_CATEGORY_INPUT = 1;
		/** <i>native declaration : libavutil\log.h:3</i> */
		public static final int AV_CLASS_CATEGORY_OUTPUT = 2;
		/** <i>native declaration : libavutil\log.h:4</i> */
		public static final int AV_CLASS_CATEGORY_MUXER = 3;
		/** <i>native declaration : libavutil\log.h:5</i> */
		public static final int AV_CLASS_CATEGORY_DEMUXER = 4;
		/** <i>native declaration : libavutil\log.h:6</i> */
		public static final int AV_CLASS_CATEGORY_ENCODER = 5;
		/** <i>native declaration : libavutil\log.h:7</i> */
		public static final int AV_CLASS_CATEGORY_DECODER = 6;
		/** <i>native declaration : libavutil\log.h:8</i> */
		public static final int AV_CLASS_CATEGORY_FILTER = 7;
		/** <i>native declaration : libavutil\log.h:9</i> */
		public static final int AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8;
		/** <i>native declaration : libavutil\log.h:10</i> */
		public static final int AV_CLASS_CATEGORY_SWSCALER = 9;
		/** <i>native declaration : libavutil\log.h:11</i> */
		public static final int AV_CLASS_CATEGORY_SWRESAMPLER = 10;
		/** <i>native declaration : libavutil\log.h:12</i> */
		public static final int AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40;
		/** <i>native declaration : libavutil\log.h:13</i> */
		public static final int AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41;
		/** <i>native declaration : libavutil\log.h:14</i> */
		public static final int AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42;
		/** <i>native declaration : libavutil\log.h:15</i> */
		public static final int AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43;
		/** <i>native declaration : libavutil\log.h:16</i> */
		public static final int AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44;
		/** <i>native declaration : libavutil\log.h:17</i> */
		public static final int AV_CLASS_CATEGORY_DEVICE_INPUT = 45;
		/**
		 * < not part of ABI/API<br>
		 * <i>native declaration : libavutil\log.h:19</i>
		 */
		public static final int AV_CLASS_CATEGORY_NB = 46;
	};
	/**
	 * Pixel format.<br>
	 * @note<br>
	 * AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA<br>
	 * color is put together as:<br>
	 *  (A << 24) | (R << 16) | (G << 8) | B<br>
	 * This is stored as BGRA on little-endian CPU architectures and ARGB on<br>
	 * big-endian CPUs.<br>
	 * @par<br>
	 * When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized<br>
	 * image data is stored in AVFrame.data[0]. The palette is transported in<br>
	 * AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is<br>
	 * formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is<br>
	 * also endian-specific). Note also that the individual RGB32 palette<br>
	 * components stored in AVFrame.data[1] should be in the range 0..255.<br>
	 * This is important as many custom PAL8 video codecs that were designed<br>
	 * to run on the IBM VGA graphics adapter use 6-bit palette components.<br>
	 * @par<br>
	 * For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like<br>
	 * for pal8. This palette is filled in automatically by the function<br>
	 * allocating the picture.<br>
	 * <i>native declaration : libavutil\pixfmt.h:396</i><br>
	 * enum values
	 */
	public static interface AVPixelFormat {
		/** <i>native declaration : libavutil\pixfmt.h:23</i> */
		public static final int AV_PIX_FMT_NONE = -1;
		/**
		 * < planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)<br>
		 * <i>native declaration : libavutil\pixfmt.h:25</i>
		 */
		public static final int AV_PIX_FMT_YUV420P = 0;
		/**
		 * < packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr<br>
		 * <i>native declaration : libavutil\pixfmt.h:27</i>
		 */
		public static final int AV_PIX_FMT_YUYV422 = 1;
		/**
		 * < packed RGB 8:8:8, 24bpp, RGBRGB...<br>
		 * <i>native declaration : libavutil\pixfmt.h:29</i>
		 */
		public static final int AV_PIX_FMT_RGB24 = 2;
		/**
		 * < packed RGB 8:8:8, 24bpp, BGRBGR...<br>
		 * <i>native declaration : libavutil\pixfmt.h:31</i>
		 */
		public static final int AV_PIX_FMT_BGR24 = 3;
		/**
		 * < planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)<br>
		 * <i>native declaration : libavutil\pixfmt.h:33</i>
		 */
		public static final int AV_PIX_FMT_YUV422P = 4;
		/**
		 * < planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)<br>
		 * <i>native declaration : libavutil\pixfmt.h:35</i>
		 */
		public static final int AV_PIX_FMT_YUV444P = 5;
		/**
		 * < planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)<br>
		 * <i>native declaration : libavutil\pixfmt.h:37</i>
		 */
		public static final int AV_PIX_FMT_YUV410P = 6;
		/**
		 * < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)<br>
		 * <i>native declaration : libavutil\pixfmt.h:39</i>
		 */
		public static final int AV_PIX_FMT_YUV411P = 7;
		/**
		 * <        Y        ,  8bpp<br>
		 * <i>native declaration : libavutil\pixfmt.h:41</i>
		 */
		public static final int AV_PIX_FMT_GRAY8 = 8;
		/**
		 * <        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb<br>
		 * <i>native declaration : libavutil\pixfmt.h:43</i>
		 */
		public static final int AV_PIX_FMT_MONOWHITE = 9;
		/**
		 * <        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb<br>
		 * <i>native declaration : libavutil\pixfmt.h:45</i>
		 */
		public static final int AV_PIX_FMT_MONOBLACK = 10;
		/**
		 * < 8 bits with AV_PIX_FMT_RGB32 palette<br>
		 * <i>native declaration : libavutil\pixfmt.h:47</i>
		 */
		public static final int AV_PIX_FMT_PAL8 = 11;
		/**
		 * < planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range<br>
		 * <i>native declaration : libavutil\pixfmt.h:49</i>
		 */
		public static final int AV_PIX_FMT_YUVJ420P = 12;
		/**
		 * < planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range<br>
		 * <i>native declaration : libavutil\pixfmt.h:51</i>
		 */
		public static final int AV_PIX_FMT_YUVJ422P = 13;
		/**
		 * < planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range<br>
		 * <i>native declaration : libavutil\pixfmt.h:53</i>
		 */
		public static final int AV_PIX_FMT_YUVJ444P = 14;
		/**
		 * < XVideo Motion Acceleration via common packet passing<br>
		 * <i>native declaration : libavutil\pixfmt.h:55</i>
		 */
		public static final int AV_PIX_FMT_XVMC_MPEG2_MC = 15;
		/** <i>native declaration : libavutil\pixfmt.h:56</i> */
		public static final int AV_PIX_FMT_XVMC_MPEG2_IDCT = 16;
		/** <i>native declaration : libavutil\pixfmt.h:57</i> */
		public static final int AV_PIX_FMT_XVMC = (int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT;
		/**
		 * < packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1<br>
		 * <i>native declaration : libavutil\pixfmt.h:59</i>
		 */
		public static final int AV_PIX_FMT_UYVY422 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 1);
		/**
		 * < packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3<br>
		 * <i>native declaration : libavutil\pixfmt.h:61</i>
		 */
		public static final int AV_PIX_FMT_UYYVYY411 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 2);
		/**
		 * < packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)<br>
		 * <i>native declaration : libavutil\pixfmt.h:63</i>
		 */
		public static final int AV_PIX_FMT_BGR8 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 3);
		/**
		 * < packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits<br>
		 * <i>native declaration : libavutil\pixfmt.h:65</i>
		 */
		public static final int AV_PIX_FMT_BGR4 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 4);
		/**
		 * < packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)<br>
		 * <i>native declaration : libavutil\pixfmt.h:67</i>
		 */
		public static final int AV_PIX_FMT_BGR4_BYTE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 5);
		/**
		 * < packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)<br>
		 * <i>native declaration : libavutil\pixfmt.h:69</i>
		 */
		public static final int AV_PIX_FMT_RGB8 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 6);
		/**
		 * < packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits<br>
		 * <i>native declaration : libavutil\pixfmt.h:71</i>
		 */
		public static final int AV_PIX_FMT_RGB4 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 7);
		/**
		 * < packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)<br>
		 * <i>native declaration : libavutil\pixfmt.h:73</i>
		 */
		public static final int AV_PIX_FMT_RGB4_BYTE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 8);
		/**
		 * < planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)<br>
		 * <i>native declaration : libavutil\pixfmt.h:75</i>
		 */
		public static final int AV_PIX_FMT_NV12 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 9);
		/**
		 * < as above, but U and V bytes are swapped<br>
		 * <i>native declaration : libavutil\pixfmt.h:77</i>
		 */
		public static final int AV_PIX_FMT_NV21 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 10);
		/**
		 * < packed ARGB 8:8:8:8, 32bpp, ARGBARGB...<br>
		 * <i>native declaration : libavutil\pixfmt.h:79</i>
		 */
		public static final int AV_PIX_FMT_ARGB = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 11);
		/**
		 * < packed RGBA 8:8:8:8, 32bpp, RGBARGBA...<br>
		 * <i>native declaration : libavutil\pixfmt.h:81</i>
		 */
		public static final int AV_PIX_FMT_RGBA = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 12);
		/**
		 * < packed ABGR 8:8:8:8, 32bpp, ABGRABGR...<br>
		 * <i>native declaration : libavutil\pixfmt.h:83</i>
		 */
		public static final int AV_PIX_FMT_ABGR = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 13);
		/**
		 * < packed BGRA 8:8:8:8, 32bpp, BGRABGRA...<br>
		 * <i>native declaration : libavutil\pixfmt.h:85</i>
		 */
		public static final int AV_PIX_FMT_BGRA = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 14);
		/**
		 * <        Y        , 16bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:87</i>
		 */
		public static final int AV_PIX_FMT_GRAY16BE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 15);
		/**
		 * <        Y        , 16bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:89</i>
		 */
		public static final int AV_PIX_FMT_GRAY16LE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 16);
		/**
		 * < planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)<br>
		 * <i>native declaration : libavutil\pixfmt.h:91</i>
		 */
		public static final int AV_PIX_FMT_YUV440P = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 17);
		/**
		 * < planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range<br>
		 * <i>native declaration : libavutil\pixfmt.h:93</i>
		 */
		public static final int AV_PIX_FMT_YUVJ440P = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 18);
		/**
		 * < planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)<br>
		 * <i>native declaration : libavutil\pixfmt.h:95</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 19);
		/**
		 * < H.264 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : libavutil\pixfmt.h:97</i>
		 */
		public static final int AV_PIX_FMT_VDPAU_H264 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 20);
		/**
		 * < MPEG-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : libavutil\pixfmt.h:99</i>
		 */
		public static final int AV_PIX_FMT_VDPAU_MPEG1 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 21);
		/**
		 * < MPEG-2 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : libavutil\pixfmt.h:101</i>
		 */
		public static final int AV_PIX_FMT_VDPAU_MPEG2 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 22);
		/**
		 * < WMV3 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : libavutil\pixfmt.h:103</i>
		 */
		public static final int AV_PIX_FMT_VDPAU_WMV3 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 23);
		/**
		 * < VC-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : libavutil\pixfmt.h:105</i>
		 */
		public static final int AV_PIX_FMT_VDPAU_VC1 = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 24);
		/**
		 * < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:107</i>
		 */
		public static final int AV_PIX_FMT_RGB48BE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 25);
		/**
		 * < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:109</i>
		 */
		public static final int AV_PIX_FMT_RGB48LE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 26);
		/**
		 * < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:111</i>
		 */
		public static final int AV_PIX_FMT_RGB565BE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 27);
		/**
		 * < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:113</i>
		 */
		public static final int AV_PIX_FMT_RGB565LE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 28);
		/**
		 * < packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:115</i>
		 */
		public static final int AV_PIX_FMT_RGB555BE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 29);
		/**
		 * < packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:117</i>
		 */
		public static final int AV_PIX_FMT_RGB555LE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 30);
		/**
		 * < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:119</i>
		 */
		public static final int AV_PIX_FMT_BGR565BE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 31);
		/**
		 * < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:121</i>
		 */
		public static final int AV_PIX_FMT_BGR565LE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 32);
		/**
		 * < packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:123</i>
		 */
		public static final int AV_PIX_FMT_BGR555BE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 33);
		/**
		 * < packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:125</i>
		 */
		public static final int AV_PIX_FMT_BGR555LE = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 34);
		/**
		 * < HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers<br>
		 * <i>native declaration : libavutil\pixfmt.h:127</i>
		 */
		public static final int AV_PIX_FMT_VAAPI_MOCO = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 35);
		/**
		 * < HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers<br>
		 * <i>native declaration : libavutil\pixfmt.h:129</i>
		 */
		public static final int AV_PIX_FMT_VAAPI_IDCT = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 36);
		/**
		 * < HW decoding through VA API, Picture.data[3] contains a VASurfaceID<br>
		 * <i>native declaration : libavutil\pixfmt.h:131</i>
		 */
		public static final int AV_PIX_FMT_VAAPI_VLD = ((int) AVPixelFormat.AV_PIX_FMT_XVMC_MPEG2_IDCT + 37);
		/** <i>native declaration : libavutil\pixfmt.h:132</i> */
		public static final int AV_PIX_FMT_VAAPI = (int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD;
		/**
		 * < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:134</i>
		 */
		public static final int AV_PIX_FMT_YUV420P16LE = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 1);
		/**
		 * < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:136</i>
		 */
		public static final int AV_PIX_FMT_YUV420P16BE = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 2);
		/**
		 * < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:138</i>
		 */
		public static final int AV_PIX_FMT_YUV422P16LE = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 3);
		/**
		 * < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:140</i>
		 */
		public static final int AV_PIX_FMT_YUV422P16BE = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 4);
		/**
		 * < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:142</i>
		 */
		public static final int AV_PIX_FMT_YUV444P16LE = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 5);
		/**
		 * < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:144</i>
		 */
		public static final int AV_PIX_FMT_YUV444P16BE = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 6);
		/**
		 * < MPEG-4 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : libavutil\pixfmt.h:146</i>
		 */
		public static final int AV_PIX_FMT_VDPAU_MPEG4 = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 7);
		/**
		 * < HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer<br>
		 * <i>native declaration : libavutil\pixfmt.h:148</i>
		 */
		public static final int AV_PIX_FMT_DXVA2_VLD = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 8);
		/**
		 * < packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:150</i>
		 */
		public static final int AV_PIX_FMT_RGB444LE = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 9);
		/**
		 * < packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:152</i>
		 */
		public static final int AV_PIX_FMT_RGB444BE = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 10);
		/**
		 * < packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:154</i>
		 */
		public static final int AV_PIX_FMT_BGR444LE = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 11);
		/**
		 * < packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:156</i>
		 */
		public static final int AV_PIX_FMT_BGR444BE = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 12);
		/**
		 * < 8 bits gray, 8 bits alpha<br>
		 * <i>native declaration : libavutil\pixfmt.h:158</i>
		 */
		public static final int AV_PIX_FMT_YA8 = ((int) AVPixelFormat.AV_PIX_FMT_VAAPI_VLD + 13);
		/**
		 * < alias for AV_PIX_FMT_YA8<br>
		 * <i>native declaration : libavutil\pixfmt.h:160</i>
		 */
		public static final int AV_PIX_FMT_Y400A = (int) AVPixelFormat.AV_PIX_FMT_YA8;
		/**
		 * < alias for AV_PIX_FMT_YA8<br>
		 * <i>native declaration : libavutil\pixfmt.h:162</i>
		 */
		public static final int AV_PIX_FMT_GRAY8A = (int) AVPixelFormat.AV_PIX_FMT_YA8;
		/**
		 * < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:164</i>
		 */
		public static final int AV_PIX_FMT_BGR48BE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 1);
		/**
		 * < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:166</i>
		 */
		public static final int AV_PIX_FMT_BGR48LE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 2);
		/**
		 * < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:168</i>
		 */
		public static final int AV_PIX_FMT_YUV420P9BE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 3);
		/**
		 * < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:170</i>
		 */
		public static final int AV_PIX_FMT_YUV420P9LE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 4);
		/**
		 * < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:172</i>
		 */
		public static final int AV_PIX_FMT_YUV420P10BE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 5);
		/**
		 * < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:174</i>
		 */
		public static final int AV_PIX_FMT_YUV420P10LE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 6);
		/**
		 * < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:176</i>
		 */
		public static final int AV_PIX_FMT_YUV422P10BE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 7);
		/**
		 * < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:178</i>
		 */
		public static final int AV_PIX_FMT_YUV422P10LE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 8);
		/**
		 * < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:180</i>
		 */
		public static final int AV_PIX_FMT_YUV444P9BE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 9);
		/**
		 * < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:182</i>
		 */
		public static final int AV_PIX_FMT_YUV444P9LE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 10);
		/**
		 * < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:184</i>
		 */
		public static final int AV_PIX_FMT_YUV444P10BE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 11);
		/**
		 * < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:186</i>
		 */
		public static final int AV_PIX_FMT_YUV444P10LE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 12);
		/**
		 * < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:188</i>
		 */
		public static final int AV_PIX_FMT_YUV422P9BE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 13);
		/**
		 * < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:190</i>
		 */
		public static final int AV_PIX_FMT_YUV422P9LE = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 14);
		/**
		 * < hardware decoding through VDA<br>
		 * <i>native declaration : libavutil\pixfmt.h:192</i>
		 */
		public static final int AV_PIX_FMT_VDA_VLD = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 15);
		/**
		 * < planar GBR 4:4:4 24bpp<br>
		 * <i>native declaration : libavutil\pixfmt.h:194</i>
		 */
		public static final int AV_PIX_FMT_GBRP = ((int) AVPixelFormat.AV_PIX_FMT_YA8 + 16);
		/**
		 * alias for #AV_PIX_FMT_GBRP<br>
		 * <i>native declaration : libavutil\pixfmt.h:196</i>
		 */
		public static final int AV_PIX_FMT_GBR24P = (int) AVPixelFormat.AV_PIX_FMT_GBRP;
		/**
		 * < planar GBR 4:4:4 27bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:198</i>
		 */
		public static final int AV_PIX_FMT_GBRP9BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 1);
		/**
		 * < planar GBR 4:4:4 27bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:200</i>
		 */
		public static final int AV_PIX_FMT_GBRP9LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 2);
		/**
		 * < planar GBR 4:4:4 30bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:202</i>
		 */
		public static final int AV_PIX_FMT_GBRP10BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 3);
		/**
		 * < planar GBR 4:4:4 30bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:204</i>
		 */
		public static final int AV_PIX_FMT_GBRP10LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 4);
		/**
		 * < planar GBR 4:4:4 48bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:206</i>
		 */
		public static final int AV_PIX_FMT_GBRP16BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 5);
		/**
		 * < planar GBR 4:4:4 48bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:208</i>
		 */
		public static final int AV_PIX_FMT_GBRP16LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 6);
		/**
		 * < planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)<br>
		 * <i>native declaration : libavutil\pixfmt.h:210</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 7);
		/**
		 * < planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)<br>
		 * <i>native declaration : libavutil\pixfmt.h:212</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 8);
		/**
		 * < planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:214</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P9BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 9);
		/**
		 * < planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:216</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P9LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 10);
		/**
		 * < planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:218</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P9BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 11);
		/**
		 * < planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:220</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P9LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 12);
		/**
		 * < planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:222</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P9BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 13);
		/**
		 * < planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:224</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P9LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 14);
		/**
		 * < planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:226</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P10BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 15);
		/**
		 * < planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:228</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P10LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 16);
		/**
		 * < planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:230</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P10BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 17);
		/**
		 * < planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:232</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P10LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 18);
		/**
		 * < planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:234</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P10BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 19);
		/**
		 * < planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:236</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P10LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 20);
		/**
		 * < planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:238</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P16BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 21);
		/**
		 * < planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:240</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P16LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 22);
		/**
		 * < planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:242</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P16BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 23);
		/**
		 * < planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:244</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P16LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 24);
		/**
		 * < planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:246</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P16BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 25);
		/**
		 * < planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:248</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P16LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 26);
		/**
		 * < HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface<br>
		 * <i>native declaration : libavutil\pixfmt.h:250</i>
		 */
		public static final int AV_PIX_FMT_VDPAU = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 27);
		/**
		 * < packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0<br>
		 * <i>native declaration : libavutil\pixfmt.h:252</i>
		 */
		public static final int AV_PIX_FMT_XYZ12LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 28);
		/**
		 * < packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0<br>
		 * <i>native declaration : libavutil\pixfmt.h:254</i>
		 */
		public static final int AV_PIX_FMT_XYZ12BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 29);
		/**
		 * < interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)<br>
		 * <i>native declaration : libavutil\pixfmt.h:256</i>
		 */
		public static final int AV_PIX_FMT_NV16 = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 30);
		/**
		 * < interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:258</i>
		 */
		public static final int AV_PIX_FMT_NV20LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 31);
		/**
		 * < interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:260</i>
		 */
		public static final int AV_PIX_FMT_NV20BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 32);
		/**
		 * < packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:262</i>
		 */
		public static final int AV_PIX_FMT_RGBA64BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 33);
		/**
		 * < packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:264</i>
		 */
		public static final int AV_PIX_FMT_RGBA64LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 34);
		/**
		 * < packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:266</i>
		 */
		public static final int AV_PIX_FMT_BGRA64BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 35);
		/**
		 * < packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:268</i>
		 */
		public static final int AV_PIX_FMT_BGRA64LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 36);
		/**
		 * < packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb<br>
		 * <i>native declaration : libavutil\pixfmt.h:270</i>
		 */
		public static final int AV_PIX_FMT_YVYU422 = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 37);
		/**
		 * < HW acceleration through VDA, data[3] contains a CVPixelBufferRef<br>
		 * <i>native declaration : libavutil\pixfmt.h:272</i>
		 */
		public static final int AV_PIX_FMT_VDA = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 38);
		/**
		 * < 16 bits gray, 16 bits alpha (big-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:274</i>
		 */
		public static final int AV_PIX_FMT_YA16BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 39);
		/**
		 * < 16 bits gray, 16 bits alpha (little-endian)<br>
		 * <i>native declaration : libavutil\pixfmt.h:276</i>
		 */
		public static final int AV_PIX_FMT_YA16LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 40);
		/**
		 * < planar GBRA 4:4:4:4 32bpp<br>
		 * <i>native declaration : libavutil\pixfmt.h:278</i>
		 */
		public static final int AV_PIX_FMT_GBRAP = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 41);
		/**
		 * < planar GBRA 4:4:4:4 64bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:280</i>
		 */
		public static final int AV_PIX_FMT_GBRAP16BE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 42);
		/**
		 * < planar GBRA 4:4:4:4 64bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:282</i>
		 */
		public static final int AV_PIX_FMT_GBRAP16LE = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 43);
		/** <i>native declaration : libavutil\pixfmt.h:283</i> */
		public static final int AV_PIX_FMT_QSV = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 44);
		/** <i>native declaration : libavutil\pixfmt.h:284</i> */
		public static final int AV_PIX_FMT_MMAL = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 45);
		/**
		 * < HW decoding through Direct3D11, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer<br>
		 * <i>native declaration : libavutil\pixfmt.h:286</i>
		 */
		public static final int AV_PIX_FMT_D3D11VA_VLD = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 46);
		/** <i>native declaration : libavutil\pixfmt.h:287</i> */
		public static final int AV_PIX_FMT_CUDA = ((int) AVPixelFormat.AV_PIX_FMT_GBRP + 47);
		/**
		 * < packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:289</i>
		 */
		public static final int AV_PIX_FMT_0RGB = 0x123 + 4;
		/**
		 * < packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:291</i>
		 */
		public static final int AV_PIX_FMT_RGB0 = (0x123 + 4 + 1);
		/**
		 * < packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:293</i>
		 */
		public static final int AV_PIX_FMT_0BGR = (0x123 + 4 + 2);
		/**
		 * < packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined<br>
		 * <i>native declaration : libavutil\pixfmt.h:295</i>
		 */
		public static final int AV_PIX_FMT_BGR0 = (0x123 + 4 + 3);
		/**
		 * < planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:297</i>
		 */
		public static final int AV_PIX_FMT_YUV420P12BE = (0x123 + 4 + 4);
		/**
		 * < planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:299</i>
		 */
		public static final int AV_PIX_FMT_YUV420P12LE = (0x123 + 4 + 5);
		/**
		 * < planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:301</i>
		 */
		public static final int AV_PIX_FMT_YUV420P14BE = (0x123 + 4 + 6);
		/**
		 * < planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:303</i>
		 */
		public static final int AV_PIX_FMT_YUV420P14LE = (0x123 + 4 + 7);
		/**
		 * < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:305</i>
		 */
		public static final int AV_PIX_FMT_YUV422P12BE = (0x123 + 4 + 8);
		/**
		 * < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:307</i>
		 */
		public static final int AV_PIX_FMT_YUV422P12LE = (0x123 + 4 + 9);
		/**
		 * < planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:309</i>
		 */
		public static final int AV_PIX_FMT_YUV422P14BE = (0x123 + 4 + 10);
		/**
		 * < planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:311</i>
		 */
		public static final int AV_PIX_FMT_YUV422P14LE = (0x123 + 4 + 11);
		/**
		 * < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:313</i>
		 */
		public static final int AV_PIX_FMT_YUV444P12BE = (0x123 + 4 + 12);
		/**
		 * < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:315</i>
		 */
		public static final int AV_PIX_FMT_YUV444P12LE = (0x123 + 4 + 13);
		/**
		 * < planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:317</i>
		 */
		public static final int AV_PIX_FMT_YUV444P14BE = (0x123 + 4 + 14);
		/**
		 * < planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:319</i>
		 */
		public static final int AV_PIX_FMT_YUV444P14LE = (0x123 + 4 + 15);
		/**
		 * < planar GBR 4:4:4 36bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:321</i>
		 */
		public static final int AV_PIX_FMT_GBRP12BE = (0x123 + 4 + 16);
		/**
		 * < planar GBR 4:4:4 36bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:323</i>
		 */
		public static final int AV_PIX_FMT_GBRP12LE = (0x123 + 4 + 17);
		/**
		 * < planar GBR 4:4:4 42bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:325</i>
		 */
		public static final int AV_PIX_FMT_GBRP14BE = (0x123 + 4 + 18);
		/**
		 * < planar GBR 4:4:4 42bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:327</i>
		 */
		public static final int AV_PIX_FMT_GBRP14LE = (0x123 + 4 + 19);
		/**
		 * < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range<br>
		 * <i>native declaration : libavutil\pixfmt.h:329</i>
		 */
		public static final int AV_PIX_FMT_YUVJ411P = (0x123 + 4 + 20);
		/**
		 * < bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:331</i>
		 */
		public static final int AV_PIX_FMT_BAYER_BGGR8 = (0x123 + 4 + 21);
		/**
		 * < bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:333</i>
		 */
		public static final int AV_PIX_FMT_BAYER_RGGB8 = (0x123 + 4 + 22);
		/**
		 * < bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:335</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GBRG8 = (0x123 + 4 + 23);
		/**
		 * < bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:337</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GRBG8 = (0x123 + 4 + 24);
		/**
		 * < bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:339</i>
		 */
		public static final int AV_PIX_FMT_BAYER_BGGR16LE = (0x123 + 4 + 25);
		/**
		 * < bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:341</i>
		 */
		public static final int AV_PIX_FMT_BAYER_BGGR16BE = (0x123 + 4 + 26);
		/**
		 * < bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:343</i>
		 */
		public static final int AV_PIX_FMT_BAYER_RGGB16LE = (0x123 + 4 + 27);
		/**
		 * < bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:345</i>
		 */
		public static final int AV_PIX_FMT_BAYER_RGGB16BE = (0x123 + 4 + 28);
		/**
		 * < bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:347</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GBRG16LE = (0x123 + 4 + 29);
		/**
		 * < bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:349</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GBRG16BE = (0x123 + 4 + 30);
		/**
		 * < bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:351</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GRBG16LE = (0x123 + 4 + 31);
		/**
		 * < bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian * /<br>
		 * <i>native declaration : libavutil\pixfmt.h:353</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GRBG16BE = (0x123 + 4 + 32);
		/**
		 * < planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:355</i>
		 */
		public static final int AV_PIX_FMT_YUV440P10LE = (0x123 + 4 + 33);
		/**
		 * < planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:357</i>
		 */
		public static final int AV_PIX_FMT_YUV440P10BE = (0x123 + 4 + 34);
		/**
		 * < planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:359</i>
		 */
		public static final int AV_PIX_FMT_YUV440P12LE = (0x123 + 4 + 35);
		/**
		 * < planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:361</i>
		 */
		public static final int AV_PIX_FMT_YUV440P12BE = (0x123 + 4 + 36);
		/**
		 * < packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:363</i>
		 */
		public static final int AV_PIX_FMT_AYUV64LE = (0x123 + 4 + 37);
		/**
		 * < packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:365</i>
		 */
		public static final int AV_PIX_FMT_AYUV64BE = (0x123 + 4 + 38);
		/**
		 * < hardware decoding through Videotoolbox<br>
		 * <i>native declaration : libavutil\pixfmt.h:367</i>
		 */
		public static final int AV_PIX_FMT_VIDEOTOOLBOX = (0x123 + 4 + 39);
		/**
		 * < like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:369</i>
		 */
		public static final int AV_PIX_FMT_P010LE = (0x123 + 4 + 40);
		/**
		 * < like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:371</i>
		 */
		public static final int AV_PIX_FMT_P010BE = (0x123 + 4 + 41);
		/**
		 * < planar GBR 4:4:4:4 48bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:373</i>
		 */
		public static final int AV_PIX_FMT_GBRAP12BE = (0x123 + 4 + 42);
		/**
		 * < planar GBR 4:4:4:4 48bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:375</i>
		 */
		public static final int AV_PIX_FMT_GBRAP12LE = (0x123 + 4 + 43);
		/**
		 * < planar GBR 4:4:4:4 40bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:377</i>
		 */
		public static final int AV_PIX_FMT_GBRAP10BE = (0x123 + 4 + 44);
		/**
		 * < planar GBR 4:4:4:4 40bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:379</i>
		 */
		public static final int AV_PIX_FMT_GBRAP10LE = (0x123 + 4 + 45);
		/**
		 * < hardware decoding through MediaCodec<br>
		 * <i>native declaration : libavutil\pixfmt.h:381</i>
		 */
		public static final int AV_PIX_FMT_MEDIACODEC = (0x123 + 4 + 46);
		/**
		 * <        Y        , 12bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:383</i>
		 */
		public static final int AV_PIX_FMT_GRAY12BE = (0x123 + 4 + 47);
		/**
		 * <        Y        , 12bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:385</i>
		 */
		public static final int AV_PIX_FMT_GRAY12LE = (0x123 + 4 + 48);
		/**
		 * <        Y        , 10bpp, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:387</i>
		 */
		public static final int AV_PIX_FMT_GRAY10BE = (0x123 + 4 + 49);
		/**
		 * <        Y        , 10bpp, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:389</i>
		 */
		public static final int AV_PIX_FMT_GRAY10LE = (0x123 + 4 + 50);
		/**
		 * < like NV12, with 16bpp per component, little-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:391</i>
		 */
		public static final int AV_PIX_FMT_P016LE = (0x123 + 4 + 51);
		/**
		 * < like NV12, with 16bpp per component, big-endian<br>
		 * <i>native declaration : libavutil\pixfmt.h:393</i>
		 */
		public static final int AV_PIX_FMT_P016BE = (0x123 + 4 + 52);
		/**
		 * < number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions<br>
		 * <i>native declaration : libavutil\pixfmt.h:395</i>
		 */
		public static final int AV_PIX_FMT_NB = (0x123 + 4 + 53);
	};
	/**
	 * Chromaticity coordinates of the source primaries.<br>
	 * <i>native declaration : libavutil\pixfmt.h:427</i><br>
	 * enum values
	 */
	public static interface AVColorPrimaries {
		/** <i>native declaration : libavutil\pixfmt.h:399</i> */
		public static final int AVCOL_PRI_RESERVED0 = 0;
		/**
		 * < also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B<br>
		 * <i>native declaration : libavutil\pixfmt.h:401</i>
		 */
		public static final int AVCOL_PRI_BT709 = 1;
		/** <i>native declaration : libavutil\pixfmt.h:402</i> */
		public static final int AVCOL_PRI_UNSPECIFIED = 2;
		/** <i>native declaration : libavutil\pixfmt.h:403</i> */
		public static final int AVCOL_PRI_RESERVED = 3;
		/**
		 * < also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)<br>
		 * <i>native declaration : libavutil\pixfmt.h:405</i>
		 */
		public static final int AVCOL_PRI_BT470M = 4;
		/**
		 * < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM<br>
		 * <i>native declaration : libavutil\pixfmt.h:407</i>
		 */
		public static final int AVCOL_PRI_BT470BG = 5;
		/**
		 * < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC<br>
		 * <i>native declaration : libavutil\pixfmt.h:409</i>
		 */
		public static final int AVCOL_PRI_SMPTE170M = 6;
		/**
		 * < functionally identical to above<br>
		 * <i>native declaration : libavutil\pixfmt.h:411</i>
		 */
		public static final int AVCOL_PRI_SMPTE240M = 7;
		/**
		 * < colour filters using Illuminant C<br>
		 * <i>native declaration : libavutil\pixfmt.h:413</i>
		 */
		public static final int AVCOL_PRI_FILM = 8;
		/**
		 * < ITU-R BT2020<br>
		 * <i>native declaration : libavutil\pixfmt.h:415</i>
		 */
		public static final int AVCOL_PRI_BT2020 = 9;
		/**
		 * < SMPTE ST 428-1 (CIE 1931 XYZ)<br>
		 * <i>native declaration : libavutil\pixfmt.h:417</i>
		 */
		public static final int AVCOL_PRI_SMPTE428 = 10;
		/** <i>native declaration : libavutil\pixfmt.h:418</i> */
		public static final int AVCOL_PRI_SMPTEST428_1 = (int) AVColorPrimaries.AVCOL_PRI_SMPTE428;
		/**
		 * < SMPTE ST 431-2 (2011) / DCI P3<br>
		 * <i>native declaration : libavutil\pixfmt.h:420</i>
		 */
		public static final int AVCOL_PRI_SMPTE431 = 11;
		/**
		 * < SMPTE ST 432-1 (2010) / P3 D65 / Display P3<br>
		 * <i>native declaration : libavutil\pixfmt.h:422</i>
		 */
		public static final int AVCOL_PRI_SMPTE432 = 12;
		/**
		 * < JEDEC P22 phosphors<br>
		 * <i>native declaration : libavutil\pixfmt.h:424</i>
		 */
		public static final int AVCOL_PRI_JEDEC_P22 = 22;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : libavutil\pixfmt.h:426</i>
		 */
		public static final int AVCOL_PRI_NB = 23;
	};
	/**
	 * Color Transfer Characteristic.<br>
	 * <i>native declaration : libavutil\pixfmt.h:468</i><br>
	 * enum values
	 */
	public static interface AVColorTransferCharacteristic {
		/** <i>native declaration : libavutil\pixfmt.h:430</i> */
		public static final int AVCOL_TRC_RESERVED0 = 0;
		/**
		 * < also ITU-R BT1361<br>
		 * <i>native declaration : libavutil\pixfmt.h:432</i>
		 */
		public static final int AVCOL_TRC_BT709 = 1;
		/** <i>native declaration : libavutil\pixfmt.h:433</i> */
		public static final int AVCOL_TRC_UNSPECIFIED = 2;
		/** <i>native declaration : libavutil\pixfmt.h:434</i> */
		public static final int AVCOL_TRC_RESERVED = 3;
		/**
		 * < also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM<br>
		 * <i>native declaration : libavutil\pixfmt.h:436</i>
		 */
		public static final int AVCOL_TRC_GAMMA22 = 4;
		/**
		 * < also ITU-R BT470BG<br>
		 * <i>native declaration : libavutil\pixfmt.h:438</i>
		 */
		public static final int AVCOL_TRC_GAMMA28 = 5;
		/**
		 * < also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC<br>
		 * <i>native declaration : libavutil\pixfmt.h:440</i>
		 */
		public static final int AVCOL_TRC_SMPTE170M = 6;
		/** <i>native declaration : libavutil\pixfmt.h:441</i> */
		public static final int AVCOL_TRC_SMPTE240M = 7;
		/**
		 * < "Linear transfer characteristics"<br>
		 * <i>native declaration : libavutil\pixfmt.h:443</i>
		 */
		public static final int AVCOL_TRC_LINEAR = 8;
		/**
		 * < "Logarithmic transfer characteristic (100:1 range)"<br>
		 * <i>native declaration : libavutil\pixfmt.h:445</i>
		 */
		public static final int AVCOL_TRC_LOG = 9;
		/**
		 * < "Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)"<br>
		 * <i>native declaration : libavutil\pixfmt.h:447</i>
		 */
		public static final int AVCOL_TRC_LOG_SQRT = 10;
		/**
		 * < IEC 61966-2-4<br>
		 * <i>native declaration : libavutil\pixfmt.h:449</i>
		 */
		public static final int AVCOL_TRC_IEC61966_2_4 = 11;
		/**
		 * < ITU-R BT1361 Extended Colour Gamut<br>
		 * <i>native declaration : libavutil\pixfmt.h:451</i>
		 */
		public static final int AVCOL_TRC_BT1361_ECG = 12;
		/**
		 * < IEC 61966-2-1 (sRGB or sYCC)<br>
		 * <i>native declaration : libavutil\pixfmt.h:453</i>
		 */
		public static final int AVCOL_TRC_IEC61966_2_1 = 13;
		/**
		 * < ITU-R BT2020 for 10-bit system<br>
		 * <i>native declaration : libavutil\pixfmt.h:455</i>
		 */
		public static final int AVCOL_TRC_BT2020_10 = 14;
		/**
		 * < ITU-R BT2020 for 12-bit system<br>
		 * <i>native declaration : libavutil\pixfmt.h:457</i>
		 */
		public static final int AVCOL_TRC_BT2020_12 = 15;
		/**
		 * < SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems<br>
		 * <i>native declaration : libavutil\pixfmt.h:459</i>
		 */
		public static final int AVCOL_TRC_SMPTE2084 = 16;
		/** <i>native declaration : libavutil\pixfmt.h:460</i> */
		public static final int AVCOL_TRC_SMPTEST2084 = (int) AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084;
		/**
		 * < SMPTE ST 428-1<br>
		 * <i>native declaration : libavutil\pixfmt.h:462</i>
		 */
		public static final int AVCOL_TRC_SMPTE428 = 17;
		/** <i>native declaration : libavutil\pixfmt.h:463</i> */
		public static final int AVCOL_TRC_SMPTEST428_1 = (int) AVColorTransferCharacteristic.AVCOL_TRC_SMPTE428;
		/**
		 * < ARIB STD-B67, known as "Hybrid log-gamma"<br>
		 * <i>native declaration : libavutil\pixfmt.h:465</i>
		 */
		public static final int AVCOL_TRC_ARIB_STD_B67 = 18;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : libavutil\pixfmt.h:467</i>
		 */
		public static final int AVCOL_TRC_NB = 19;
	};
	/**
	 * YUV colorspace type.<br>
	 * <i>native declaration : libavutil\pixfmt.h:496</i><br>
	 * enum values
	 */
	public static interface AVColorSpace {
		/**
		 * < order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)<br>
		 * <i>native declaration : libavutil\pixfmt.h:472</i>
		 */
		public static final int AVCOL_SPC_RGB = 0;
		/**
		 * < also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B<br>
		 * <i>native declaration : libavutil\pixfmt.h:474</i>
		 */
		public static final int AVCOL_SPC_BT709 = 1;
		/** <i>native declaration : libavutil\pixfmt.h:475</i> */
		public static final int AVCOL_SPC_UNSPECIFIED = 2;
		/** <i>native declaration : libavutil\pixfmt.h:476</i> */
		public static final int AVCOL_SPC_RESERVED = 3;
		/**
		 * < FCC Title 47 Code of Federal Regulations 73.682 (a)(20)<br>
		 * <i>native declaration : libavutil\pixfmt.h:478</i>
		 */
		public static final int AVCOL_SPC_FCC = 4;
		/**
		 * < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601<br>
		 * <i>native declaration : libavutil\pixfmt.h:480</i>
		 */
		public static final int AVCOL_SPC_BT470BG = 5;
		/**
		 * < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC<br>
		 * <i>native declaration : libavutil\pixfmt.h:482</i>
		 */
		public static final int AVCOL_SPC_SMPTE170M = 6;
		/**
		 * < functionally identical to above<br>
		 * <i>native declaration : libavutil\pixfmt.h:484</i>
		 */
		public static final int AVCOL_SPC_SMPTE240M = 7;
		/**
		 * < Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16<br>
		 * <i>native declaration : libavutil\pixfmt.h:486</i>
		 */
		public static final int AVCOL_SPC_YCGCO = 8;
		/** <i>native declaration : libavutil\pixfmt.h:487</i> */
		public static final int AVCOL_SPC_YCOCG = (int) AVColorSpace.AVCOL_SPC_YCOCG;
		/**
		 * < ITU-R BT2020 non-constant luminance system<br>
		 * <i>native declaration : libavutil\pixfmt.h:489</i>
		 */
		public static final int AVCOL_SPC_BT2020_NCL = 9;
		/**
		 * < ITU-R BT2020 constant luminance system<br>
		 * <i>native declaration : libavutil\pixfmt.h:491</i>
		 */
		public static final int AVCOL_SPC_BT2020_CL = 10;
		/**
		 * < SMPTE 2085, Y'D'zD'x<br>
		 * <i>native declaration : libavutil\pixfmt.h:493</i>
		 */
		public static final int AVCOL_SPC_SMPTE2085 = 11;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : libavutil\pixfmt.h:495</i>
		 */
		public static final int AVCOL_SPC_NB = 12;
	};
	/**
	 * MPEG vs JPEG YUV range.<br>
	 * <i>native declaration : libavutil\pixfmt.h:506</i><br>
	 * enum values
	 */
	public static interface AVColorRange {
		/** <i>native declaration : libavutil\pixfmt.h:499</i> */
		public static final int AVCOL_RANGE_UNSPECIFIED = 0;
		/**
		 * < the normal 219*2^(n-8) "MPEG" YUV ranges<br>
		 * <i>native declaration : libavutil\pixfmt.h:501</i>
		 */
		public static final int AVCOL_RANGE_MPEG = 1;
		/**
		 * < the normal     2^n-1   "JPEG" YUV ranges<br>
		 * <i>native declaration : libavutil\pixfmt.h:503</i>
		 */
		public static final int AVCOL_RANGE_JPEG = 2;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : libavutil\pixfmt.h:505</i>
		 */
		public static final int AVCOL_RANGE_NB = 3;
	};
	/**
	 * Location of chroma samples.<br>
	 * Illustration showing the location of the first (top left) chroma sample of the<br>
	 * image, the left shows only luma, the right<br>
	 * shows the location of the chroma sample, the 2 could be imagined to overlay<br>
	 * each other but are drawn separately due to limitations of ASCII<br>
	 *                1st 2nd       1st 2nd horizontal luma sample positions<br>
	 *                 v   v         v   v<br>
	 *                 ______        ______<br>
	 * 1st luma line > |X   X ...    |3 4 X ...     X are luma samples,<br>
	 *                |             |1 2           1-6 are possible chroma positions<br>
	 * 2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position<br>
	 * <i>native declaration : libavutil\pixfmt.h:533</i><br>
	 * enum values
	 */
	public static interface AVChromaLocation {
		/** <i>native declaration : libavutil\pixfmt.h:521</i> */
		public static final int AVCHROMA_LOC_UNSPECIFIED = 0;
		/**
		 * < MPEG-2/4 4:2:0, H.264 default for 4:2:0<br>
		 * <i>native declaration : libavutil\pixfmt.h:523</i>
		 */
		public static final int AVCHROMA_LOC_LEFT = 1;
		/**
		 * < MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0<br>
		 * <i>native declaration : libavutil\pixfmt.h:525</i>
		 */
		public static final int AVCHROMA_LOC_CENTER = 2;
		/**
		 * < ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2<br>
		 * <i>native declaration : libavutil\pixfmt.h:527</i>
		 */
		public static final int AVCHROMA_LOC_TOPLEFT = 3;
		/** <i>native declaration : libavutil\pixfmt.h:528</i> */
		public static final int AVCHROMA_LOC_TOP = 4;
		/** <i>native declaration : libavutil\pixfmt.h:529</i> */
		public static final int AVCHROMA_LOC_BOTTOMLEFT = 5;
		/** <i>native declaration : libavutil\pixfmt.h:530</i> */
		public static final int AVCHROMA_LOC_BOTTOM = 6;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : libavutil\pixfmt.h:532</i>
		 */
		public static final int AVCHROMA_LOC_NB = 7;
	};
	/**
	 * Audio sample formats<br>
	 * - The data described by the sample format is always in native-endian order.<br>
	 *   Sample values can be expressed by native C types, hence the lack of a signed<br>
	 *   24-bit sample format even though it is a common raw audio data format.<br>
	 * - The floating-point formats are based on full volume being in the range<br>
	 *   [-1.0, 1.0]. Any values outside this range are beyond full volume level.<br>
	 * - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg<br>
	 *   (such as AVFrame in libavcodec) is as follows:<br>
	 * @par<br>
	 * For planar sample formats, each audio channel is in a separate data plane,<br>
	 * and linesize is the buffer size, in bytes, for a single plane. All data<br>
	 * planes must be the same size. For packed sample formats, only the first data<br>
	 * plane is used, and samples for each channel are interleaved. In this case,<br>
	 * linesize is the buffer size, in bytes, for the 1 plane.<br>
	 * <i>native declaration : libavutil\samplefmt.h:44</i><br>
	 * enum values
	 */
	public static interface AVSampleFormat {
		/** <i>native declaration : libavutil\samplefmt.h:17</i> */
		public static final int AV_SAMPLE_FMT_NONE = -1;
		/**
		 * < unsigned 8 bits<br>
		 * <i>native declaration : libavutil\samplefmt.h:19</i>
		 */
		public static final int AV_SAMPLE_FMT_U8 = 0;
		/**
		 * < signed 16 bits<br>
		 * <i>native declaration : libavutil\samplefmt.h:21</i>
		 */
		public static final int AV_SAMPLE_FMT_S16 = 1;
		/**
		 * < signed 32 bits<br>
		 * <i>native declaration : libavutil\samplefmt.h:23</i>
		 */
		public static final int AV_SAMPLE_FMT_S32 = 2;
		/**
		 * < float<br>
		 * <i>native declaration : libavutil\samplefmt.h:25</i>
		 */
		public static final int AV_SAMPLE_FMT_FLT = 3;
		/**
		 * < double<br>
		 * <i>native declaration : libavutil\samplefmt.h:27</i>
		 */
		public static final int AV_SAMPLE_FMT_DBL = 4;
		/**
		 * < unsigned 8 bits, planar<br>
		 * <i>native declaration : libavutil\samplefmt.h:29</i>
		 */
		public static final int AV_SAMPLE_FMT_U8P = 5;
		/**
		 * < signed 16 bits, planar<br>
		 * <i>native declaration : libavutil\samplefmt.h:31</i>
		 */
		public static final int AV_SAMPLE_FMT_S16P = 6;
		/**
		 * < signed 32 bits, planar<br>
		 * <i>native declaration : libavutil\samplefmt.h:33</i>
		 */
		public static final int AV_SAMPLE_FMT_S32P = 7;
		/**
		 * < float, planar<br>
		 * <i>native declaration : libavutil\samplefmt.h:35</i>
		 */
		public static final int AV_SAMPLE_FMT_FLTP = 8;
		/**
		 * < double, planar<br>
		 * <i>native declaration : libavutil\samplefmt.h:37</i>
		 */
		public static final int AV_SAMPLE_FMT_DBLP = 9;
		/**
		 * < signed 64 bits<br>
		 * <i>native declaration : libavutil\samplefmt.h:39</i>
		 */
		public static final int AV_SAMPLE_FMT_S64 = 10;
		/**
		 * < signed 64 bits, planar<br>
		 * <i>native declaration : libavutil\samplefmt.h:41</i>
		 */
		public static final int AV_SAMPLE_FMT_S64P = 11;
		/**
		 * < Number of sample formats. DO NOT USE if linking dynamically<br>
		 * <i>native declaration : libavutil\samplefmt.h:43</i>
		 */
		public static final int AV_SAMPLE_FMT_NB = 12;
	};
	/**
	 * @defgroup lavu_frame AVFrame<br>
	 * @ingroup lavu_data<br>
	 * @{<br>
	 * AVFrame is an abstraction for reference-counted raw multimedia data.<br>
	 * <i>native declaration : libavutil\frame.h:21</i><br>
	 * enum values
	 */
	public static interface AVFrameSideDataType {
		/** <i>native declaration : libavutil\frame.h:7</i> */
		public static final int AV_FRAME_DATA_PANSCAN = 0;
		/** <i>native declaration : libavutil\frame.h:8</i> */
		public static final int AV_FRAME_DATA_A53_CC = 1;
		/** <i>native declaration : libavutil\frame.h:9</i> */
		public static final int AV_FRAME_DATA_STEREO3D = 2;
		/** <i>native declaration : libavutil\frame.h:10</i> */
		public static final int AV_FRAME_DATA_MATRIXENCODING = 3;
		/** <i>native declaration : libavutil\frame.h:11</i> */
		public static final int AV_FRAME_DATA_DOWNMIX_INFO = 4;
		/** <i>native declaration : libavutil\frame.h:12</i> */
		public static final int AV_FRAME_DATA_REPLAYGAIN = 5;
		/** <i>native declaration : libavutil\frame.h:13</i> */
		public static final int AV_FRAME_DATA_DISPLAYMATRIX = 6;
		/** <i>native declaration : libavutil\frame.h:14</i> */
		public static final int AV_FRAME_DATA_AFD = 7;
		/** <i>native declaration : libavutil\frame.h:15</i> */
		public static final int AV_FRAME_DATA_MOTION_VECTORS = 8;
		/** <i>native declaration : libavutil\frame.h:16</i> */
		public static final int AV_FRAME_DATA_SKIP_SAMPLES = 9;
		/** <i>native declaration : libavutil\frame.h:17</i> */
		public static final int AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10;
		/** <i>native declaration : libavutil\frame.h:18</i> */
		public static final int AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11;
		/** <i>native declaration : libavutil\frame.h:19</i> */
		public static final int AV_FRAME_DATA_GOP_TIMECODE = 12;
		/** <i>native declaration : libavutil\frame.h:20</i> */
		public static final int AV_FRAME_DATA_SPHERICAL = 13;
	};
	/**
	 * <i>native declaration : libavutil\frame.h:30</i><br>
	 * enum values
	 */
	public static interface AVActiveFormatDescription {
		/** <i>native declaration : libavutil\frame.h:23</i> */
		public static final int AV_AFD_SAME = 8;
		/** <i>native declaration : libavutil\frame.h:24</i> */
		public static final int AV_AFD_4_3 = 9;
		/** <i>native declaration : libavutil\frame.h:25</i> */
		public static final int AV_AFD_16_9 = 10;
		/** <i>native declaration : libavutil\frame.h:26</i> */
		public static final int AV_AFD_14_9 = 11;
		/** <i>native declaration : libavutil\frame.h:27</i> */
		public static final int AV_AFD_4_3_SP_14_9 = 13;
		/** <i>native declaration : libavutil\frame.h:28</i> */
		public static final int AV_AFD_16_9_SP_14_9 = 14;
		/** <i>native declaration : libavutil\frame.h:29</i> */
		public static final int AV_AFD_SP_4_3 = 15;
	};
	/**
	 * @defgroup avoptions AVOptions<br>
	 * @ingroup lavu_data<br>
	 * @{<br>
	 * AVOptions provide a generic system to declare options on arbitrary structs<br>
	 * ("objects"). An option can have a help text, a type and a range of possible<br>
	 * values. Options may then be enumerated, read and written to.<br>
	 * @section avoptions_implement Implementing AVOptions<br>
	 * This section describes how to add AVOptions capabilities to a struct.<br>
	 * All AVOptions-related information is stored in an AVClass. Therefore<br>
	 * the first member of the struct should be a pointer to an AVClass describing it.<br>
	 * The option field of the AVClass must be set to a NULL-terminated static array<br>
	 * of AVOptions. Each AVOption must have a non-empty name, a type, a default<br>
	 * value and for number-type AVOptions also a range of allowed values. It must<br>
	 * also declare an offset in bytes from the start of the struct, where the field<br>
	 * associated with this AVOption is located. Other fields in the AVOption struct<br>
	 * should also be set when applicable, but are not required.<br>
	 * The following example illustrates an AVOptions-enabled struct:<br>
	 * @code<br>
	 * typedef struct test_struct {<br>
	 *     const AVClass *class;<br>
	 *     int      int_opt;<br>
	 *     char    *str_opt;<br>
	 *     uint8_t *bin_opt;<br>
	 *     int      bin_len;<br>
	 * } test_struct;<br>
	 * static const AVOption test_options[] = {<br>
	 *   { "test_int", "This is a test option of int type.", offsetof(test_struct, int_opt),<br>
	 *     AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },<br>
	 *   { "test_str", "This is a test option of string type.", offsetof(test_struct, str_opt),<br>
	 *     AV_OPT_TYPE_STRING },<br>
	 *   { "test_bin", "This is a test option of binary type.", offsetof(test_struct, bin_opt),<br>
	 *     AV_OPT_TYPE_BINARY },<br>
	 *   { NULL },<br>
	 * };<br>
	 * static const AVClass test_class = {<br>
	 *     .class_name = "test class",<br>
	 *     .item_name  = av_default_item_name,<br>
	 *     .option     = test_options,<br>
	 *     .version    = LIBAVUTIL_VERSION_INT,<br>
	 * };<br>
	 * @endcode<br>
	 * Next, when allocating your struct, you must ensure that the AVClass pointer<br>
	 * is set to the correct value. Then, av_opt_set_defaults() can be called to<br>
	 * initialize defaults. After that the struct is ready to be used with the<br>
	 * AVOptions API.<br>
	 * When cleaning up, you may use the av_opt_free() function to automatically<br>
	 * free all the allocated string and binary options.<br>
	 * Continuing with the above example:<br>
	 * @code<br>
	 * test_struct *alloc_test_struct(void)<br>
	 * {<br>
	 *     test_struct *ret = av_mallocz(sizeof(*ret));<br>
	 *     ret->class = &test_class;<br>
	 *     av_opt_set_defaults(ret);<br>
	 *     return ret;<br>
	 * }<br>
	 * void free_test_struct(test_struct **foo)<br>
	 * {<br>
	 *     av_opt_free(*foo);<br>
	 *     av_freep(foo);<br>
	 * }<br>
	 * @endcode<br>
	 * @subsection avoptions_implement_nesting Nesting<br>
	 *      It may happen that an AVOptions-enabled struct contains another<br>
	 *      AVOptions-enabled struct as a member (e.g. AVCodecContext in<br>
	 *      libavcodec exports generic options, while its priv_data field exports<br>
	 *      codec-specific options). In such a case, it is possible to set up the<br>
	 *      parent struct to export a child's options. To do that, simply<br>
	 *      implement AVClass.child_next() and AVClass.child_class_next() in the<br>
	 *      parent struct's AVClass.<br>
	 *      Assuming that the test_struct from above now also contains a<br>
	 *      child_struct field:<br>
	 *      @code<br>
	 *      typedef struct child_struct {<br>
	 *          AVClass *class;<br>
	 *          int flags_opt;<br>
	 *      } child_struct;<br>
	 *      static const AVOption child_opts[] = {<br>
	 *          { "test_flags", "This is a test option of flags type.",<br>
	 *            offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },<br>
	 *          { NULL },<br>
	 *      };<br>
	 *      static const AVClass child_class = {<br>
	 *          .class_name = "child class",<br>
	 *          .item_name  = av_default_item_name,<br>
	 *          .option     = child_opts,<br>
	 *          .version    = LIBAVUTIL_VERSION_INT,<br>
	 *      };<br>
	 *      void *child_next(void *obj, void *prev)<br>
	 *      {<br>
	 *          test_struct *t = obj;<br>
	 *          if (!prev && t->child_struct)<br>
	 *              return t->child_struct;<br>
	 *          return NULL<br>
	 *      }<br>
	 *      const AVClass child_class_next(const AVClass *prev)<br>
	 *      {<br>
	 *          return prev ? NULL : &child_class;<br>
	 *      }<br>
	 *      @endcode<br>
	 *      Putting child_next() and child_class_next() as defined above into<br>
	 *      test_class will now make child_struct's options accessible through<br>
	 *      test_struct (again, proper setup as described above needs to be done on<br>
	 *      child_struct right after it is created).<br>
	 *      From the above example it might not be clear why both child_next()<br>
	 *      and child_class_next() are needed. The distinction is that child_next()<br>
	 *      iterates over actually existing objects, while child_class_next()<br>
	 *      iterates over all possible child classes. E.g. if an AVCodecContext<br>
	 *      was initialized to use a codec which has private options, then its<br>
	 *      child_next() will return AVCodecContext.priv_data and finish<br>
	 *      iterating. OTOH child_class_next() on AVCodecContext.av_class will<br>
	 *      iterate over all available codecs with private options.<br>
	 * @subsection avoptions_implement_named_constants Named constants<br>
	 *      It is possible to create named constants for options. Simply set the unit<br>
	 *      field of the option the constants should apply to a string and<br>
	 *      create the constants themselves as options of type AV_OPT_TYPE_CONST<br>
	 *      with their unit field set to the same string.<br>
	 *      Their default_val field should contain the value of the named<br>
	 *      constant.<br>
	 *      For example, to add some named constants for the test_flags option<br>
	 *      above, put the following into the child_opts array:<br>
	 *      @code<br>
	 *      { "test_flags", "This is a test option of flags type.",<br>
	 *        offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, "test_unit" },<br>
	 *      { "flag1", "This is a flag with value 16", 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, "test_unit" },<br>
	 *      @endcode<br>
	 * @section avoptions_use Using AVOptions<br>
	 * This section deals with accessing options in an AVOptions-enabled struct.<br>
	 * Such structs in FFmpeg are e.g. AVCodecContext in libavcodec or<br>
	 * AVFormatContext in libavformat.<br>
	 * @subsection avoptions_use_examine Examining AVOptions<br>
	 * The basic functions for examining options are av_opt_next(), which iterates<br>
	 * over all options defined for one object, and av_opt_find(), which searches<br>
	 * for an option with the given name.<br>
	 * The situation is more complicated with nesting. An AVOptions-enabled struct<br>
	 * may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN flag<br>
	 * to av_opt_find() will make the function search children recursively.<br>
	 * For enumerating there are basically two cases. The first is when you want to<br>
	 * get all options that may potentially exist on the struct and its children<br>
	 * (e.g.  when constructing documentation). In that case you should call<br>
	 * av_opt_child_class_next() recursively on the parent struct's AVClass.  The<br>
	 * second case is when you have an already initialized struct with all its<br>
	 * children and you want to get all options that can be actually written or read<br>
	 * from it. In that case you should call av_opt_child_next() recursively (and<br>
	 * av_opt_next() on each result).<br>
	 * @subsection avoptions_use_get_set Reading and writing AVOptions<br>
	 * When setting options, you often have a string read directly from the<br>
	 * user. In such a case, simply passing it to av_opt_set() is enough. For<br>
	 * non-string type options, av_opt_set() will parse the string according to the<br>
	 * option type.<br>
	 * Similarly av_opt_get() will read any option type and convert it to a string<br>
	 * which will be returned. Do not forget that the string is allocated, so you<br>
	 * have to free it with av_free().<br>
	 * In some cases it may be more convenient to put all options into an<br>
	 * AVDictionary and call av_opt_set_dict() on it. A specific case of this<br>
	 * are the format/codec open functions in lavf/lavc which take a dictionary<br>
	 * filled with option as a parameter. This makes it possible to set some options<br>
	 * that cannot be set otherwise, since e.g. the input file format is not known<br>
	 * before the file is actually opened.<br>
	 * <i>native declaration : libavutil\opt.h:184</i><br>
	 * enum values
	 */
	public static interface AVOptionType {
		/** <i>native declaration : libavutil\opt.h:162</i> */
		public static final int AV_OPT_TYPE_FLAGS = 0;
		/** <i>native declaration : libavutil\opt.h:163</i> */
		public static final int AV_OPT_TYPE_INT = 1;
		/** <i>native declaration : libavutil\opt.h:164</i> */
		public static final int AV_OPT_TYPE_INT64 = 2;
		/** <i>native declaration : libavutil\opt.h:165</i> */
		public static final int AV_OPT_TYPE_DOUBLE = 3;
		/** <i>native declaration : libavutil\opt.h:166</i> */
		public static final int AV_OPT_TYPE_FLOAT = 4;
		/** <i>native declaration : libavutil\opt.h:167</i> */
		public static final int AV_OPT_TYPE_STRING = 5;
		/** <i>native declaration : libavutil\opt.h:168</i> */
		public static final int AV_OPT_TYPE_RATIONAL = 6;
		/**
		 * < offset must point to a pointer immediately followed by an int for the length<br>
		 * <i>native declaration : libavutil\opt.h:170</i>
		 */
		public static final int AV_OPT_TYPE_BINARY = 7;
		/** <i>native declaration : libavutil\opt.h:171</i> */
		public static final int AV_OPT_TYPE_DICT = 8;
		/** <i>native declaration : libavutil\opt.h:172</i> */
		public static final int AV_OPT_TYPE_UINT64 = 9;
		/** <i>native declaration : libavutil\opt.h:173</i> */
		public static final int AV_OPT_TYPE_CONST = 128;
		/**
		 * < offset must point to two consecutive integers<br>
		 * <i>native declaration : libavutil\opt.h:175</i>
		 */
		public static final int AV_OPT_TYPE_IMAGE_SIZE = (('E') | (('Z') << 8) | (('I') << 16) | (('S') << 24));
		/** <i>native declaration : libavutil\opt.h:176</i> */
		public static final int AV_OPT_TYPE_PIXEL_FMT = (('T') | (('M') << 8) | (('F') << 16) | (('P') << 24));
		/** <i>native declaration : libavutil\opt.h:177</i> */
		public static final int AV_OPT_TYPE_SAMPLE_FMT = (('T') | (('M') << 8) | (('F') << 16) | (('S') << 24));
		/**
		 * < offset must point to AVRational<br>
		 * <i>native declaration : libavutil\opt.h:179</i>
		 */
		public static final int AV_OPT_TYPE_VIDEO_RATE = (('T') | (('A') << 8) | (('R') << 16) | (('V') << 24));
		/** <i>native declaration : libavutil\opt.h:180</i> */
		public static final int AV_OPT_TYPE_DURATION = ((' ') | (('R') << 8) | (('U') << 16) | (('D') << 24));
		/** <i>native declaration : libavutil\opt.h:181</i> */
		public static final int AV_OPT_TYPE_COLOR = (('R') | (('L') << 8) | (('O') << 16) | (('C') << 24));
		/** <i>native declaration : libavutil\opt.h:182</i> */
		public static final int AV_OPT_TYPE_CHANNEL_LAYOUT = (('A') | (('L') << 8) | (('H') << 16) | (('C') << 24));
		/** <i>native declaration : libavutil\opt.h:183</i> */
		public static final int AV_OPT_TYPE_BOOL = (('L') | (('O') << 8) | (('O') << 16) | (('B') << 24));
	};
	public static final int AV_OPT_FLAG_IMPLICIT_KEY = 1;
	/**
	 * Projection of the video surface(s) on a sphere.<br>
	 * <i>native declaration : libavutil\spherical.h:5</i><br>
	 * enum values
	 */
	public static interface AVSphericalProjection {
		/** <i>native declaration : libavutil\spherical.h:2</i> */
		public static final int AV_SPHERICAL_EQUIRECTANGULAR = 0;
		/** <i>native declaration : libavutil\spherical.h:3</i> */
		public static final int AV_SPHERICAL_CUBEMAP = 1;
		/** <i>native declaration : libavutil\spherical.h:4</i> */
		public static final int AV_SPHERICAL_EQUIRECTANGULAR_TILE = 2;
	};
	/**
	 * @}<br>
	 * @defgroup channel_mask_c Audio channel layouts<br>
	 * @{<br>
	 * <i>native declaration : .\libavutil\channel_layout.h:14</i><br>
	 * enum values
	 */
	public static interface AVMatrixEncoding {
		/** <i>native declaration : .\libavutil\channel_layout.h:6</i> */
		public static final int AV_MATRIX_ENCODING_NONE = 0;
		/** <i>native declaration : .\libavutil\channel_layout.h:7</i> */
		public static final int AV_MATRIX_ENCODING_DOLBY = 1;
		/** <i>native declaration : .\libavutil\channel_layout.h:8</i> */
		public static final int AV_MATRIX_ENCODING_DPLII = 2;
		/** <i>native declaration : .\libavutil\channel_layout.h:9</i> */
		public static final int AV_MATRIX_ENCODING_DPLIIX = 3;
		/** <i>native declaration : .\libavutil\channel_layout.h:10</i> */
		public static final int AV_MATRIX_ENCODING_DPLIIZ = 4;
		/** <i>native declaration : .\libavutil\channel_layout.h:11</i> */
		public static final int AV_MATRIX_ENCODING_DOLBYEX = 5;
		/** <i>native declaration : .\libavutil\channel_layout.h:12</i> */
		public static final int AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6;
		/** <i>native declaration : .\libavutil\channel_layout.h:13</i> */
		public static final int AV_MATRIX_ENCODING_NB = 7;
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil\rational.h:0</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : libavutil\ffversion.h</i> */
	public static final String FFMPEG_VERSION = (String)"3.3";
	/** <i>native declaration : libavutil\avutil.h</i> */
	public static final int FF_LAMBDA_SHIFT = (int)7;
	/** <i>native declaration : libavutil\avutil.h</i> */
	public static final int FF_LAMBDA_SCALE = (int)(1 << 7);
	/** <i>native declaration : libavutil\avutil.h</i> */
	public static final int FF_QP2LAMBDA = (int)118;
	/** <i>native declaration : libavutil\avutil.h</i> */
	public static final int FF_LAMBDA_MAX = (int)(256 * 128 - 1);
	/** <i>native declaration : libavutil\avutil.h</i> */
	public static final int FF_QUALITY_SCALE = (int)(1 << 7);
	/** <i>native declaration : libavutil\avutil.h</i> */
	public static final int AV_TIME_BASE = (int)1000000;
	/** <i>native declaration : libavutil\version.h</i> */
	public static final int LIBAVUTIL_VERSION_MAJOR = (int)55;
	/** <i>native declaration : libavutil\version.h</i> */
	public static final int LIBAVUTIL_VERSION_MINOR = (int)58;
	/** <i>native declaration : libavutil\version.h</i> */
	public static final int LIBAVUTIL_VERSION_MICRO = (int)100;
	/** <i>native declaration : libavutil\version.h</i> */
	public static final int LIBAVUTIL_VERSION_INT = (int)((55) << 16 | (58) << 8 | (100));
	/**
	 * define<br>
	 * Conversion Error : 55.58.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil\version.h:0</i><br>
	 * 55.58.
	 */
	/** <i>native declaration : libavutil\version.h</i> */
	public static final int LIBAVUTIL_BUILD = (int)((55) << 16 | (58) << 8 | (100));
	/** <i>native declaration : libavutil\version.h</i> */
	public static final String LIBAVUTIL_IDENT = (String)"Lavu55.58.100";
	/** <i>native declaration : libavutil\version.h</i> */
	public static final boolean FF_API_VDPAU = (boolean)(55 < 56);
	/** <i>native declaration : libavutil\version.h</i> */
	public static final boolean FF_API_XVMC = (boolean)(55 < 56);
	/** <i>native declaration : libavutil\version.h</i> */
	public static final boolean FF_API_OPT_TYPE_METADATA = (boolean)(55 < 56);
	/** <i>native declaration : libavutil\version.h</i> */
	public static final boolean FF_API_DLOG = (boolean)(55 < 56);
	/** <i>native declaration : libavutil\version.h</i> */
	public static final boolean FF_API_VAAPI = (boolean)(55 < 56);
	/** <i>native declaration : libavutil\version.h</i> */
	public static final boolean FF_API_FRAME_QP = (boolean)(55 < 56);
	/** <i>native declaration : libavutil\version.h</i> */
	public static final boolean FF_API_PLUS1_MINUS1 = (boolean)(55 < 56);
	/** <i>native declaration : libavutil\version.h</i> */
	public static final boolean FF_API_ERROR_FRAME = (boolean)(55 < 56);
	/** <i>native declaration : libavutil\version.h</i> */
	public static final boolean FF_API_CRC_BIG_TABLE = (boolean)(55 < 56);
	/** <i>native declaration : libavutil\version.h</i> */
	public static final boolean FF_API_PKT_PTS = (boolean)(55 < 56);
	/** <i>native declaration : .\libavutil\avconfig.h</i> */
	public static final int AV_HAVE_BIGENDIAN = (int)0;
	/** <i>native declaration : .\libavutil\avconfig.h</i> */
	public static final int AV_HAVE_FAST_UNALIGNED = (int)1;
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_BSF_NOT_FOUND = (int)(-((0xF8) | (('B') << 8) | (('S') << 16) | (('F') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_BUG = (int)(-(('B') | (('U') << 8) | (('G') << 16) | (('!') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_BUFFER_TOO_SMALL = (int)(-(('B') | (('U') << 8) | (('F') << 16) | (('S') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_DECODER_NOT_FOUND = (int)(-((0xF8) | (('D') << 8) | (('E') << 16) | (('C') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_DEMUXER_NOT_FOUND = (int)(-((0xF8) | (('D') << 8) | (('E') << 16) | (('M') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_ENCODER_NOT_FOUND = (int)(-((0xF8) | (('E') << 8) | (('N') << 16) | (('C') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_EOF = (int)(-(('E') | (('O') << 8) | (('F') << 16) | ((' ') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_EXIT = (int)(-(('E') | (('X') << 8) | (('I') << 16) | (('T') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_EXTERNAL = (int)(-(('E') | (('X') << 8) | (('T') << 16) | ((' ') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_FILTER_NOT_FOUND = (int)(-((0xF8) | (('F') << 8) | (('I') << 16) | (('L') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_INVALIDDATA = (int)(-(('I') | (('N') << 8) | (('D') << 16) | (('A') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_MUXER_NOT_FOUND = (int)(-((0xF8) | (('M') << 8) | (('U') << 16) | (('X') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_OPTION_NOT_FOUND = (int)(-((0xF8) | (('O') << 8) | (('P') << 16) | (('T') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_PATCHWELCOME = (int)(-(('P') | (('A') << 8) | (('W') << 16) | (('E') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_PROTOCOL_NOT_FOUND = (int)(-((0xF8) | (('P') << 8) | (('R') << 16) | (('O') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_STREAM_NOT_FOUND = (int)(-((0xF8) | (('S') << 8) | (('T') << 16) | (('R') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_BUG2 = (int)(-(('B') | (('U') << 8) | (('G') << 16) | ((' ') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_UNKNOWN = (int)(-(('U') | (('N') << 8) | (('K') << 16) | (('N') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_EXPERIMENTAL = (int)(0x2bb2afa8);
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_INPUT_CHANGED = (int)(0x636e6701);
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_OUTPUT_CHANGED = (int)(0x636e6702);
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_HTTP_BAD_REQUEST = (int)(-((0xF8) | (('4') << 8) | (('0') << 16) | (('0') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_HTTP_UNAUTHORIZED = (int)(-((0xF8) | (('4') << 8) | (('0') << 16) | (('1') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_HTTP_FORBIDDEN = (int)(-((0xF8) | (('4') << 8) | (('0') << 16) | (('3') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_HTTP_NOT_FOUND = (int)(-((0xF8) | (('4') << 8) | (('0') << 16) | (('4') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_HTTP_OTHER_4XX = (int)(-((0xF8) | (('4') << 8) | (('X') << 16) | (('X') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AVERROR_HTTP_SERVER_ERROR = (int)(-((0xF8) | (('5') << 8) | (('X') << 16) | (('X') << 24)));
	/** <i>native declaration : libavutil\error.h</i> */
	public static final int AV_ERROR_MAX_STRING_SIZE = (int)64;
	/** <i>native declaration : libavutil\mathematics.h</i> */
	public static final double M_E = (double)2.7182818284590452354;
	/** <i>native declaration : libavutil\mathematics.h</i> */
	public static final double M_LN2 = (double)0.69314718055994530942;
	/** <i>native declaration : libavutil\mathematics.h</i> */
	public static final double M_LN10 = (double)2.30258509299404568402;
	/** <i>native declaration : libavutil\mathematics.h</i> */
	public static final double M_LOG2_10 = (double)3.32192809488736234787;
	/** <i>native declaration : libavutil\mathematics.h</i> */
	public static final double M_PHI = (double)1.61803398874989484820;
	/** <i>native declaration : libavutil\mathematics.h</i> */
	public static final double M_PI = (double)3.14159265358979323846;
	/** <i>native declaration : libavutil\mathematics.h</i> */
	public static final double M_PI_2 = (double)1.57079632679489661923;
	/** <i>native declaration : libavutil\mathematics.h</i> */
	public static final double M_SQRT1_2 = (double)0.70710678118654752440;
	/** <i>native declaration : libavutil\mathematics.h</i> */
	public static final double M_SQRT2 = (double)1.41421356237309504880;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_QUIET = (int)-8;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_PANIC = (int)0;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_FATAL = (int)8;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_ERROR = (int)16;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_WARNING = (int)24;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_INFO = (int)32;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_VERBOSE = (int)40;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_DEBUG = (int)48;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_TRACE = (int)56;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_MAX_OFFSET = (int)(56 - -8);
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_SKIP_REPEATED = (int)1;
	/** <i>native declaration : libavutil\log.h</i> */
	public static final int AV_LOG_PRINT_LEVEL = (int)2;
	/** <i>native declaration : libavutil\pixfmt.h</i> */
	public static final int AVPALETTE_SIZE = (int)1024;
	/** <i>native declaration : libavutil\pixfmt.h</i> */
	public static final int AVPALETTE_COUNT = (int)256;
	/** <i>native declaration : libavutil\avutil.h</i> */
	public static final int AV_FOURCC_MAX_STRING_SIZE = (int)32;
	/** <i>native declaration : libavutil\dict.h</i> */
	public static final int AV_DICT_MATCH_CASE = (int)1;
	/** <i>native declaration : libavutil\dict.h</i> */
	public static final int AV_DICT_IGNORE_SUFFIX = (int)2;
	/** <i>native declaration : libavutil\dict.h</i> */
	public static final int AV_DICT_DONT_STRDUP_KEY = (int)4;
	/** <i>native declaration : libavutil\dict.h</i> */
	public static final int AV_DICT_DONT_STRDUP_VAL = (int)8;
	/** <i>native declaration : libavutil\dict.h</i> */
	public static final int AV_DICT_DONT_OVERWRITE = (int)16;
	/** <i>native declaration : libavutil\dict.h</i> */
	public static final int AV_DICT_APPEND = (int)32;
	/** <i>native declaration : libavutil\dict.h</i> */
	public static final int AV_DICT_MULTIKEY = (int)64;
	/** <i>native declaration : libavutil\buffer.h</i> */
	public static final int AV_BUFFER_FLAG_READONLY = (int)(1 << 0);
	/** <i>native declaration : libavutil\frame.h</i> */
	public static final int AV_NUM_DATA_POINTERS = (int)8;
	/** <i>native declaration : libavutil\frame.h</i> */
	public static final int AV_FRAME_FLAG_CORRUPT = (int)(1 << 0);
	/** <i>native declaration : libavutil\frame.h</i> */
	public static final int AV_FRAME_FLAG_DISCARD = (int)(1 << 2);
	/** <i>native declaration : libavutil\frame.h</i> */
	public static final int FF_DECODE_ERROR_INVALID_BITSTREAM = (int)1;
	/** <i>native declaration : libavutil\frame.h</i> */
	public static final int FF_DECODE_ERROR_MISSING_REFERENCE = (int)2;
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_FLAG_ENCODING_PARAM = (int)1;
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_FLAG_DECODING_PARAM = (int)2;
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_FLAG_METADATA = (int)4;
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_FLAG_AUDIO_PARAM = (int)8;
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_FLAG_VIDEO_PARAM = (int)16;
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_FLAG_SUBTITLE_PARAM = (int)32;
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_FLAG_EXPORT = (int)64;
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_FLAG_READONLY = (int)128;
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_FLAG_FILTERING_PARAM = (int)(1 << 16);
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_SEARCH_CHILDREN = (int)(1 << 0);
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_SEARCH_FAKE_OBJ = (int)(1 << 1);
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_ALLOW_NULL = (int)(1 << 2);
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_MULTI_COMPONENT_RANGE = (int)(1 << 12);
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_SERIALIZE_SKIP_DEFAULTS = (int)0x00000001;
	/** <i>native declaration : libavutil\opt.h</i> */
	public static final int AV_OPT_SERIALIZE_OPT_FLAGS_EXACT = (int)0x00000002;
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int AV_PIX_FMT_FLAG_BE = (int)(1 << 0);
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int AV_PIX_FMT_FLAG_PAL = (int)(1 << 1);
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int AV_PIX_FMT_FLAG_BITSTREAM = (int)(1 << 2);
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int AV_PIX_FMT_FLAG_HWACCEL = (int)(1 << 3);
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int AV_PIX_FMT_FLAG_PLANAR = (int)(1 << 4);
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int AV_PIX_FMT_FLAG_RGB = (int)(1 << 5);
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int AV_PIX_FMT_FLAG_PSEUDOPAL = (int)(1 << 6);
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int AV_PIX_FMT_FLAG_ALPHA = (int)(1 << 7);
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int AV_PIX_FMT_FLAG_BAYER = (int)(1 << 8);
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int FF_LOSS_RESOLUTION = (int)0x0001;
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int FF_LOSS_DEPTH = (int)0x0002;
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int FF_LOSS_COLORSPACE = (int)0x0004;
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int FF_LOSS_ALPHA = (int)0x0008;
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int FF_LOSS_COLORQUANT = (int)0x0010;
	/** <i>native declaration : libavutil\pixdesc.h</i> */
	public static final int FF_LOSS_CHROMA = (int)0x0020;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_FORCE = (int)0x80000000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_MMX = (int)0x0001;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_MMXEXT = (int)0x0002;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_MMX2 = (int)0x0002;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_3DNOW = (int)0x0004;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE = (int)0x0008;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE2 = (int)0x0010;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE2SLOW = (int)0x40000000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_3DNOWEXT = (int)0x0020;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE3 = (int)0x0040;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE3SLOW = (int)0x20000000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_SSSE3 = (int)0x0080;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_SSSE3SLOW = (int)0x4000000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_ATOM = (int)0x10000000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE4 = (int)0x0100;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE42 = (int)0x0200;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_AESNI = (int)0x80000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_AVX = (int)0x4000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_AVXSLOW = (int)0x8000000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_XOP = (int)0x0400;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_FMA4 = (int)0x0800;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_CMOV = (int)0x1000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_AVX2 = (int)0x8000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_FMA3 = (int)0x10000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_BMI1 = (int)0x20000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_BMI2 = (int)0x40000;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_ALTIVEC = (int)0x0001;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_VSX = (int)0x0002;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_POWER8 = (int)0x0004;
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_ARMV5TE = (int)(1 << 0);
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_ARMV6 = (int)(1 << 1);
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_ARMV6T2 = (int)(1 << 2);
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_VFP = (int)(1 << 3);
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_VFPV3 = (int)(1 << 4);
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_NEON = (int)(1 << 5);
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_ARMV8 = (int)(1 << 6);
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_VFP_VM = (int)(1 << 7);
	/** <i>native declaration : .\libavutil\cpu.h</i> */
	public static final int AV_CPU_FLAG_SETEND = (int)(1 << 16);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_FRONT_LEFT = (int)0x00000001;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_FRONT_RIGHT = (int)0x00000002;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_FRONT_CENTER = (int)0x00000004;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LOW_FREQUENCY = (int)0x00000008;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_BACK_LEFT = (int)0x00000010;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_BACK_RIGHT = (int)0x00000020;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_FRONT_LEFT_OF_CENTER = (int)0x00000040;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_FRONT_RIGHT_OF_CENTER = (int)0x00000080;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_BACK_CENTER = (int)0x00000100;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_SIDE_LEFT = (int)0x00000200;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_SIDE_RIGHT = (int)0x00000400;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_TOP_CENTER = (int)0x00000800;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_TOP_FRONT_LEFT = (int)0x00001000;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_TOP_FRONT_CENTER = (int)0x00002000;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_TOP_FRONT_RIGHT = (int)0x00004000;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_TOP_BACK_LEFT = (int)0x00008000;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_TOP_BACK_CENTER = (int)0x00010000;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_TOP_BACK_RIGHT = (int)0x00020000;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_STEREO_LEFT = (int)0x20000000;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_STEREO_RIGHT = (int)0x40000000;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final long AV_CH_WIDE_LEFT = (long)0x0000000080000000L;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final long AV_CH_WIDE_RIGHT = (long)0x0000000100000000L;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final long AV_CH_SURROUND_DIRECT_LEFT = (long)0x0000000200000000L;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final long AV_CH_SURROUND_DIRECT_RIGHT = (long)0x0000000400000000L;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final long AV_CH_LOW_FREQUENCY_2 = (long)0x0000000800000000L;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final long AV_CH_LAYOUT_NATIVE = (long)0x8000000000000000L;
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_MONO = (int)(0x00000004);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_STEREO = (int)(0x00000001 | 0x00000002);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_2POINT1 = (int)((0x00000001 | 0x00000002) | 0x00000008);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_2_1 = (int)((0x00000001 | 0x00000002) | 0x00000100);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_SURROUND = (int)((0x00000001 | 0x00000002) | 0x00000004);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_3POINT1 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000008);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_4POINT0 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000100);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_4POINT1 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000100) | 0x00000008);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_2_2 = (int)((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_QUAD = (int)((0x00000001 | 0x00000002) | 0x00000010 | 0x00000020);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_5POINT0 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_5POINT1 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_5POINT0_BACK = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_5POINT1_BACK = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_6POINT0 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000100);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_6POINT0_FRONT = (int)(((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_HEXAGONAL = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000100);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_6POINT1 = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000100);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_6POINT1_BACK = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008) | 0x00000100);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_6POINT1_FRONT = (int)((((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080) | 0x00000008);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_7POINT0 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000020);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_7POINT0_FRONT = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_7POINT1 = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000010 | 0x00000020);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_7POINT1_WIDE = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000040 | 0x00000080);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_7POINT1_WIDE_BACK = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008) | 0x00000040 | 0x00000080);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_OCTAGONAL = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000100 | 0x00000020);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final long AV_CH_LAYOUT_HEXADECAGONAL = (long)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000100 | 0x00000020) | 0x0000000080000000L | 0x0000000100000000L | 0x00008000 | 0x00020000 | 0x00010000 | 0x00002000 | 0x00001000 | 0x00004000);
	/** <i>native declaration : .\libavutil\channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_STEREO_DOWNMIX = (int)(0x20000000 | 0x40000000);
	/** <i>native declaration : libavutil\log.h:155</i> */
	public interface av_log_set_callback_callback_callback extends Callback {
		void apply(Pointer voidPtr1, int int1, Pointer charPtr1, Pointer va_list1);
	};
	/** <i>native declaration : libavutil\buffer.h:154</i> */
	public interface av_buffer_create_free_callback extends Callback {
		void apply(Pointer opaque, Pointer data);
	};
	/** <i>native declaration : libavutil\buffer.h:155</i> */
	public interface av_buffer_pool_init_alloc_callback extends Callback {
		AVBufferRef apply(int size);
	};
	/** <i>native declaration : libavutil\buffer.h:156</i> */
	public interface av_buffer_pool_init2_alloc_callback extends Callback {
		AVBufferRef apply(Pointer opaque, int size);
	};
	/** <i>native declaration : libavutil\buffer.h:157</i> */
	public interface av_buffer_pool_init2_pool_free_callback extends Callback {
		void apply(Pointer opaque);
	};
	/**
	 * Return the LIBAVUTIL_VERSION_INT constant.<br>
	 * Original signature : <code>int avutil_version()</code><br>
	 * <i>native declaration : libavutil\avutil.h:4</i>
	 */
	int avutil_version();
	/**
	 * Return an informative version string. This usually is the actual release<br>
	 * version number or a git commit description. This string has no fixed format<br>
	 * and can change any time. It should never be parsed by code.<br>
	 * Original signature : <code>char* av_version_info()</code><br>
	 * <i>native declaration : libavutil\avutil.h:11</i>
	 */
	String av_version_info();
	/**
	 * Return the libavutil build-time configuration.<br>
	 * Original signature : <code>char* avutil_configuration()</code><br>
	 * <i>native declaration : libavutil\avutil.h:16</i>
	 */
	String avutil_configuration();
	/**
	 * Return the libavutil license.<br>
	 * Original signature : <code>char* avutil_license()</code><br>
	 * <i>native declaration : libavutil\avutil.h:21</i>
	 */
	String avutil_license();
	/**
	 * Return a string describing the media_type enum, NULL if media_type<br>
	 * is unknown.<br>
	 * Original signature : <code>char* av_get_media_type_string(AVMediaType)</code><br>
	 * <i>native declaration : libavutil\avutil.h:43</i>
	 */
	String av_get_media_type_string(int media_type);
	/**
	 * Return a single letter to describe the given picture type<br>
	 * pict_type.<br>
	 * @param[in] pict_type the picture type @return a single character<br>
	 * representing the picture type, '?' if pict_type is unknown<br>
	 * Original signature : <code>char av_get_picture_type_char(AVPictureType)</code><br>
	 * <i>native declaration : libavutil\avutil.h:76</i>
	 */
	byte av_get_picture_type_char(int pict_type);
	/**
	 * Original signature : <code>int av_log2(unsigned)</code><br>
	 * <i>native declaration : libavutil\common.h:1</i>
	 */
	int av_log2(int v);
	/**
	 * Original signature : <code>int av_log2_16bit(unsigned)</code><br>
	 * <i>native declaration : libavutil\common.h:3</i>
	 */
	int av_log2_16bit(int v);
	/**
	 * Clip a signed integer value into the amin-amax range.<br>
	 * @param a value to clip<br>
	 * @param amin minimum value of the clip range<br>
	 * @param amax maximum value of the clip range<br>
	 * @return clipped value<br>
	 * Original signature : <code>int av_clip_c(int, int, int)</code><br>
	 * <i>native declaration : libavutil\common.h:20</i>
	 */
	int av_clip_c(int a, int amin, int amax);
	/**
	 * Clip a signed 64bit integer value into the amin-amax range.<br>
	 * @param a value to clip<br>
	 * @param amin minimum value of the clip range<br>
	 * @param amax maximum value of the clip range<br>
	 * @return clipped value<br>
	 * Original signature : <code>int64_t av_clip64_c(int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil\common.h:37</i>
	 */
	long av_clip64_c(long a, long amin, long amax);
	/**
	 * Clip a signed integer value into the 0-255 range.<br>
	 * @param a value to clip<br>
	 * @return clipped value<br>
	 * Original signature : <code>uint8_t av_clip_uint8_c(int)</code><br>
	 * <i>native declaration : libavutil\common.h:49</i>
	 */
	byte av_clip_uint8_c(int a);
	/**
	 * Clip a signed integer value into the -128,127 range.<br>
	 * @param a value to clip<br>
	 * @return clipped value<br>
	 * Original signature : <code>int8_t av_clip_int8_c(int)</code><br>
	 * <i>native declaration : libavutil\common.h:61</i>
	 */
	byte av_clip_int8_c(int a);
	/**
	 * Clip a signed integer value into the 0-65535 range.<br>
	 * @param a value to clip<br>
	 * @return clipped value<br>
	 * Original signature : <code>uint16_t av_clip_uint16_c(int)</code><br>
	 * <i>native declaration : libavutil\common.h:73</i>
	 */
	short av_clip_uint16_c(int a);
	/**
	 * Clip a signed integer value into the -32768,32767 range.<br>
	 * @param a value to clip<br>
	 * @return clipped value<br>
	 * Original signature : <code>int16_t av_clip_int16_c(int)</code><br>
	 * <i>native declaration : libavutil\common.h:85</i>
	 */
	short av_clip_int16_c(int a);
	/**
	 * Clip a signed 64-bit integer value into the -2147483648,2147483647 range.<br>
	 * @param a value to clip<br>
	 * @return clipped value<br>
	 * Original signature : <code>int32_t av_clipl_int32_c(int64_t)</code><br>
	 * <i>native declaration : libavutil\common.h:97</i>
	 */
	int av_clipl_int32_c(long a);
	/**
	 * Clip a signed integer into the -(2^p),(2^p-1) range.<br>
	 * @param  a value to clip<br>
	 * @param  p bit position to clip at<br>
	 * @return clipped value<br>
	 * Original signature : <code>int av_clip_intp2_c(int, int)</code><br>
	 * <i>native declaration : libavutil\common.h:110</i>
	 */
	int av_clip_intp2_c(int a, int p);
	/**
	 * Clip a signed integer to an unsigned power of two range.<br>
	 * @param  a value to clip<br>
	 * @param  p bit position to clip at<br>
	 * @return clipped value<br>
	 * Original signature : <code>int av_clip_uintp2_c(int, int)</code><br>
	 * <i>native declaration : libavutil\common.h:123</i>
	 */
	int av_clip_uintp2_c(int a, int p);
	/**
	 * Clear high bits from an unsigned integer starting with specific bit position<br>
	 * @param  a value to clip<br>
	 * @param  p bit position to clip at<br>
	 * @return clipped value<br>
	 * Original signature : <code>int av_mod_uintp2_c(unsigned, unsigned)</code><br>
	 * <i>native declaration : libavutil\common.h:133</i>
	 */
	int av_mod_uintp2_c(int a, int p);
	/**
	 * Add two signed 32-bit values with saturation.<br>
	 * @param  a one value<br>
	 * @param  b another value<br>
	 * @return sum with signed saturation<br>
	 * Original signature : <code>int av_sat_add32_c(int, int)</code><br>
	 * <i>native declaration : libavutil\common.h:143</i>
	 */
	int av_sat_add32_c(int a, int b);
	/**
	 * Add a doubled value to another value with saturation at both stages.<br>
	 * @param  a first value<br>
	 * @param  b value doubled and added to a<br>
	 * @return sum with signed saturation<br>
	 * Original signature : <code>int av_sat_dadd32_c(int, int)</code><br>
	 * <i>native declaration : libavutil\common.h:153</i>
	 */
	int av_sat_dadd32_c(int a, int b);
	/**
	 * Clip a float value into the amin-amax range.<br>
	 * @param a value to clip<br>
	 * @param amin minimum value of the clip range<br>
	 * @param amax maximum value of the clip range<br>
	 * @return clipped value<br>
	 * Original signature : <code>float av_clipf_c(float, float, float)</code><br>
	 * <i>native declaration : libavutil\common.h:170</i>
	 */
	float av_clipf_c(float a, float amin, float amax);
	/**
	 * Clip a double value into the amin-amax range.<br>
	 * @param a value to clip<br>
	 * @param amin minimum value of the clip range<br>
	 * @param amax maximum value of the clip range<br>
	 * @return clipped value<br>
	 * Original signature : <code>double av_clipd_c(double, double, double)</code><br>
	 * <i>native declaration : libavutil\common.h:187</i>
	 */
	double av_clipd_c(double a, double amin, double amax);
	/**
	 * Compute ceil(log2(x)).<br>
	 * @param x value used to compute ceil(log2(x))<br>
	 * @return computed ceiling of log2(x)<br>
	 * Original signature : <code>int av_ceil_log2_c(int)</code><br>
	 * <i>native declaration : libavutil\common.h:196</i>
	 */
	int av_ceil_log2_c(int x);
	/**
	 * Count number of bits set to one in x<br>
	 * @param x value to count bits of<br>
	 * @return the number of bits set to one in x<br>
	 * Original signature : <code>int av_popcount_c(uint32_t)</code><br>
	 * <i>native declaration : libavutil\common.h:209</i>
	 */
	int av_popcount_c(int x);
	/**
	 * Count number of bits set to one in x<br>
	 * @param x value to count bits of<br>
	 * @return the number of bits set to one in x<br>
	 * Original signature : <code>int av_popcount64_c(uint64_t)</code><br>
	 * <i>native declaration : libavutil\common.h:218</i>
	 */
	int av_popcount64_c(long x);
	/**
	 * Original signature : <code>int av_parity_c(uint32_t)</code><br>
	 * <i>native declaration : libavutil\common.h:222</i>
	 */
	int av_parity_c(int v);
	/**
	 * Put a description of the AVERROR code errnum in errbuf.<br>
	 * In case of failure the global variable errno is set to indicate the<br>
	 * error. Even in case of failure av_strerror() will print a generic<br>
	 * error message indicating the errnum provided to errbuf.<br>
	 * @param errnum      error code to describe<br>
	 * @param errbuf      buffer to which description is written<br>
	 * @param errbuf_size the size in bytes of errbuf<br>
	 * @return 0 on success, a negative value if a description for errnum<br>
	 * cannot be found<br>
	 * Original signature : <code>int av_strerror(int, char*, size_t)</code><br>
	 * <i>native declaration : libavutil\error.h:12</i><br>
	 * @deprecated use the safer methods {@link #av_strerror(int, ByteBuffer, NativeSize)} and {@link #av_strerror(int, Pointer, NativeSize)} instead
	 */
	@Deprecated 
	int av_strerror(int errnum, Pointer errbuf, NativeSize errbuf_size);
	/**
	 * Put a description of the AVERROR code errnum in errbuf.<br>
	 * In case of failure the global variable errno is set to indicate the<br>
	 * error. Even in case of failure av_strerror() will print a generic<br>
	 * error message indicating the errnum provided to errbuf.<br>
	 * @param errnum      error code to describe<br>
	 * @param errbuf      buffer to which description is written<br>
	 * @param errbuf_size the size in bytes of errbuf<br>
	 * @return 0 on success, a negative value if a description for errnum<br>
	 * cannot be found<br>
	 * Original signature : <code>int av_strerror(int, char*, size_t)</code><br>
	 * <i>native declaration : libavutil\error.h:12</i>
	 */
	int av_strerror(int errnum, ByteBuffer errbuf, NativeSize errbuf_size);
	/**
	 * Fill the provided buffer with a string containing an error string<br>
	 * corresponding to the AVERROR code errnum.<br>
	 * @param errbuf         a buffer<br>
	 * @param errbuf_size    size in bytes of errbuf<br>
	 * @param errnum         error code to describe<br>
	 * @return the buffer in input, filled with the error description<br>
	 * @see av_strerror()<br>
	 * Original signature : <code>char* av_make_error_string(char*, size_t, int)</code><br>
	 * <i>native declaration : libavutil\error.h:26</i><br>
	 * @deprecated use the safer methods {@link #av_make_error_string(ByteBuffer, NativeSize, int)} and {@link #av_make_error_string(Pointer, NativeSize, int)} instead
	 */
	@Deprecated 
	Pointer av_make_error_string(Pointer errbuf, NativeSize errbuf_size, int errnum);
	/**
	 * Fill the provided buffer with a string containing an error string<br>
	 * corresponding to the AVERROR code errnum.<br>
	 * @param errbuf         a buffer<br>
	 * @param errbuf_size    size in bytes of errbuf<br>
	 * @param errnum         error code to describe<br>
	 * @return the buffer in input, filled with the error description<br>
	 * @see av_strerror()<br>
	 * Original signature : <code>char* av_make_error_string(char*, size_t, int)</code><br>
	 * <i>native declaration : libavutil\error.h:26</i>
	 */
	Pointer av_make_error_string(ByteBuffer errbuf, NativeSize errbuf_size, int errnum);
	/**
	 * Allocate a memory block with alignment suitable for all memory accesses<br>
	 * (including vectors if available on the CPU).<br>
	 * @param size Size in bytes for the memory block to be allocated<br>
	 * @return Pointer to the allocated block, or `NULL` if the block cannot<br>
	 *         be allocated<br>
	 * @see av_mallocz()<br>
	 * Original signature : <code>void* av_malloc(size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:9</i>
	 */
	Pointer av_malloc(NativeSize size);
	/**
	 * Allocate a memory block with alignment suitable for all memory accesses<br>
	 * (including vectors if available on the CPU) and zero all the bytes of the<br>
	 * block.<br>
	 * @param size Size in bytes for the memory block to be allocated<br>
	 * @return Pointer to the allocated block, or `NULL` if it cannot be allocated<br>
	 * @see av_malloc()<br>
	 * Original signature : <code>void* av_mallocz(size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:19</i>
	 */
	Pointer av_mallocz(NativeSize size);
	/**
	 * Allocate a memory block for an array with av_malloc().<br>
	 * The allocated memory will have size `size * nmemb` bytes.<br>
	 * @param nmemb Number of element<br>
	 * @param size  Size of a single element<br>
	 * @return Pointer to the allocated block, or `NULL` if the block cannot<br>
	 *         be allocated<br>
	 * @see av_malloc()<br>
	 * Original signature : <code>void* av_malloc_array(size_t, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:34</i>
	 */
	Pointer av_malloc_array(NativeSize nmemb, NativeSize size);
	/**
	 * Allocate a memory block for an array with av_mallocz().<br>
	 * The allocated memory will have size `size * nmemb` bytes.<br>
	 * @param nmemb Number of elements<br>
	 * @param size  Size of the single element<br>
	 * @return Pointer to the allocated block, or `NULL` if the block cannot<br>
	 *         be allocated<br>
	 * @see av_mallocz()<br>
	 * @see av_malloc_array()<br>
	 * Original signature : <code>void* av_mallocz_array(size_t, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:50</i>
	 */
	Pointer av_mallocz_array(NativeSize nmemb, NativeSize size);
	/**
	 * Non-inlined equivalent of av_mallocz_array().<br>
	 * Created for symmetry with the calloc() C function.<br>
	 * Original signature : <code>void* av_calloc(size_t, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:56</i>
	 */
	Pointer av_calloc(NativeSize nmemb, NativeSize size);
	/**
	 * Allocate, reallocate, or free a block of memory.<br>
	 * If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is<br>
	 * zero, free the memory block pointed to by `ptr`. Otherwise, expand or<br>
	 * shrink that block of memory according to `size`.<br>
	 * @param ptr  Pointer to a memory block already allocated with<br>
	 *             av_realloc() or `NULL`<br>
	 * @param size Size in bytes of the memory block to be allocated or<br>
	 *             reallocated<br>
	 * @return Pointer to a newly-reallocated block or `NULL` if the block<br>
	 *         cannot be reallocated or the function is used to free the memory block<br>
	 * @warning Unlike av_malloc(), the returned pointer is not guaranteed to be<br>
	 *          correctly aligned.<br>
	 * @see av_fast_realloc()<br>
	 * @see av_reallocp()<br>
	 * Original signature : <code>void* av_realloc(void*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:74</i>
	 */
	Pointer av_realloc(Pointer ptr, NativeSize size);
	/**
	 * Allocate, reallocate, or free a block of memory through a pointer to a<br>
	 * pointer.<br>
	 * If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is<br>
	 * zero, free the memory block pointed to by `*ptr`. Otherwise, expand or<br>
	 * shrink that block of memory according to `size`.<br>
	 * @param[in,out] ptr  Pointer to a pointer to a memory block already allocated<br>
	 *                     with av_realloc(), or a pointer to `NULL`. The pointer<br>
	 *                     is updated on success, or freed on failure.<br>
	 * @param[in]     size Size in bytes for the memory block to be allocated or<br>
	 *                     reallocated<br>
	 * @return Zero on success, an AVERROR error code on failure<br>
	 * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be<br>
	 *          correctly aligned.<br>
	 * Original signature : <code>int av_reallocp(void*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:91</i>
	 */
	int av_reallocp(Pointer ptr, NativeSize size);
	/**
	 * Allocate, reallocate, or free a block of memory.<br>
	 * This function does the same thing as av_realloc(), except:<br>
	 * - It takes two size arguments and allocates `nelem * elsize` bytes,<br>
	 *   after checking the result of the multiplication for integer overflow.<br>
	 * - It frees the input block in case of failure, thus avoiding the memory<br>
	 *   leak with the classic<br>
	 *   @code{.c}<br>
	 *   buf = realloc(buf);<br>
	 *   if (!buf)<br>
	 *       return -1;<br>
	 *   @endcode<br>
	 *   pattern.<br>
	 * Original signature : <code>void* av_realloc_f(void*, size_t, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:107</i>
	 */
	Pointer av_realloc_f(Pointer ptr, NativeSize nelem, NativeSize elsize);
	/**
	 * Allocate, reallocate, or free an array.<br>
	 * If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If<br>
	 * `nmemb` is zero, free the memory block pointed to by `ptr`.<br>
	 * @param ptr   Pointer to a memory block already allocated with<br>
	 *              av_realloc() or `NULL`<br>
	 * @param nmemb Number of elements in the array<br>
	 * @param size  Size of the single element of the array<br>
	 * @return Pointer to a newly-reallocated block or NULL if the block<br>
	 *         cannot be reallocated or the function is used to free the memory block<br>
	 * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be<br>
	 *          correctly aligned.<br>
	 * @see av_reallocp_array()<br>
	 * Original signature : <code>void* av_realloc_array(void*, size_t, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:123</i>
	 */
	Pointer av_realloc_array(Pointer ptr, NativeSize nmemb, NativeSize size);
	/**
	 * Allocate, reallocate, or free an array through a pointer to a pointer.<br>
	 * If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is<br>
	 * zero, free the memory block pointed to by `*ptr`.<br>
	 * @param[in,out] ptr   Pointer to a pointer to a memory block already<br>
	 *                      allocated with av_realloc(), or a pointer to `NULL`.<br>
	 *                      The pointer is updated on success, or freed on failure.<br>
	 * @param[in]     nmemb Number of elements<br>
	 * @param[in]     size  Size of the single element<br>
	 * @return Zero on success, an AVERROR error code on failure<br>
	 * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be<br>
	 *          correctly aligned.<br>
	 * Original signature : <code>int av_reallocp_array(void*, size_t, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:138</i>
	 */
	int av_reallocp_array(Pointer ptr, NativeSize nmemb, NativeSize size);
	/**
	 * Reallocate the given buffer if it is not large enough, otherwise do nothing.<br>
	 * If the given buffer is `NULL`, then a new uninitialized buffer is allocated.<br>
	 * If the given buffer is not large enough, and reallocation fails, `NULL` is<br>
	 * returned and `*size` is set to 0, but the original buffer is not changed or<br>
	 * freed.<br>
	 * A typical use pattern follows:<br>
	 * @code{.c}<br>
	 * uint8_t *buf = ...;<br>
	 * uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);<br>
	 * if (!new_buf) {<br>
	 *     // Allocation failed; clean up original buffer<br>
	 *     av_freep(&buf);<br>
	 *     return AVERROR(ENOMEM);<br>
	 * }<br>
	 * @endcode<br>
	 * @param[in,out] ptr      Already allocated buffer, or `NULL`<br>
	 * @param[in,out] size     Pointer to current size of buffer `ptr`. `*size` is<br>
	 *                         changed to `min_size` in case of success or 0 in<br>
	 *                         case of failure<br>
	 * @param[in]     min_size New size of buffer `ptr`<br>
	 * @return `ptr` if the buffer is large enough, a pointer to newly reallocated<br>
	 *         buffer if the buffer was not large enough, or `NULL` in case of<br>
	 *         error<br>
	 * @see av_realloc()<br>
	 * @see av_fast_malloc()<br>
	 * Original signature : <code>void* av_fast_realloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:167</i><br>
	 * @deprecated use the safer methods {@link #av_fast_realloc(Pointer, IntBuffer, NativeSize)} and {@link #av_fast_realloc(Pointer, IntByReference, NativeSize)} instead
	 */
	@Deprecated 
	Pointer av_fast_realloc(Pointer ptr, IntByReference size, NativeSize min_size);
	/**
	 * Reallocate the given buffer if it is not large enough, otherwise do nothing.<br>
	 * If the given buffer is `NULL`, then a new uninitialized buffer is allocated.<br>
	 * If the given buffer is not large enough, and reallocation fails, `NULL` is<br>
	 * returned and `*size` is set to 0, but the original buffer is not changed or<br>
	 * freed.<br>
	 * A typical use pattern follows:<br>
	 * @code{.c}<br>
	 * uint8_t *buf = ...;<br>
	 * uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);<br>
	 * if (!new_buf) {<br>
	 *     // Allocation failed; clean up original buffer<br>
	 *     av_freep(&buf);<br>
	 *     return AVERROR(ENOMEM);<br>
	 * }<br>
	 * @endcode<br>
	 * @param[in,out] ptr      Already allocated buffer, or `NULL`<br>
	 * @param[in,out] size     Pointer to current size of buffer `ptr`. `*size` is<br>
	 *                         changed to `min_size` in case of success or 0 in<br>
	 *                         case of failure<br>
	 * @param[in]     min_size New size of buffer `ptr`<br>
	 * @return `ptr` if the buffer is large enough, a pointer to newly reallocated<br>
	 *         buffer if the buffer was not large enough, or `NULL` in case of<br>
	 *         error<br>
	 * @see av_realloc()<br>
	 * @see av_fast_malloc()<br>
	 * Original signature : <code>void* av_fast_realloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:167</i>
	 */
	Pointer av_fast_realloc(Pointer ptr, IntBuffer size, NativeSize min_size);
	/**
	 * Allocate a buffer, reusing the given one if large enough.<br>
	 * Contrary to av_fast_realloc(), the current buffer contents might not be<br>
	 * preserved and on error the old buffer is freed, thus no special handling to<br>
	 * avoid memleaks is necessary.<br>
	 * `*ptr` is allowed to be `NULL`, in which case allocation always happens if<br>
	 * `size_needed` is greater than 0.<br>
	 * @code{.c}<br>
	 * uint8_t *buf = ...;<br>
	 * av_fast_malloc(&buf, &current_size, size_needed);<br>
	 * if (!buf) {<br>
	 *     // Allocation failed; buf already freed<br>
	 *     return AVERROR(ENOMEM);<br>
	 * }<br>
	 * @endcode<br>
	 * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.<br>
	 *                         `*ptr` will be overwritten with pointer to new<br>
	 *                         buffer on success or `NULL` on failure<br>
	 * @param[in,out] size     Pointer to current size of buffer `*ptr`. `*size` is<br>
	 *                         changed to `min_size` in case of success or 0 in<br>
	 *                         case of failure<br>
	 * @param[in]     min_size New size of buffer `*ptr`<br>
	 * @see av_realloc()<br>
	 * @see av_fast_mallocz()<br>
	 * Original signature : <code>void av_fast_malloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:194</i><br>
	 * @deprecated use the safer methods {@link #av_fast_malloc(Pointer, IntBuffer, NativeSize)} and {@link #av_fast_malloc(Pointer, IntByReference, NativeSize)} instead
	 */
	@Deprecated 
	void av_fast_malloc(Pointer ptr, IntByReference size, NativeSize min_size);
	/**
	 * Allocate a buffer, reusing the given one if large enough.<br>
	 * Contrary to av_fast_realloc(), the current buffer contents might not be<br>
	 * preserved and on error the old buffer is freed, thus no special handling to<br>
	 * avoid memleaks is necessary.<br>
	 * `*ptr` is allowed to be `NULL`, in which case allocation always happens if<br>
	 * `size_needed` is greater than 0.<br>
	 * @code{.c}<br>
	 * uint8_t *buf = ...;<br>
	 * av_fast_malloc(&buf, &current_size, size_needed);<br>
	 * if (!buf) {<br>
	 *     // Allocation failed; buf already freed<br>
	 *     return AVERROR(ENOMEM);<br>
	 * }<br>
	 * @endcode<br>
	 * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.<br>
	 *                         `*ptr` will be overwritten with pointer to new<br>
	 *                         buffer on success or `NULL` on failure<br>
	 * @param[in,out] size     Pointer to current size of buffer `*ptr`. `*size` is<br>
	 *                         changed to `min_size` in case of success or 0 in<br>
	 *                         case of failure<br>
	 * @param[in]     min_size New size of buffer `*ptr`<br>
	 * @see av_realloc()<br>
	 * @see av_fast_mallocz()<br>
	 * Original signature : <code>void av_fast_malloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:194</i>
	 */
	void av_fast_malloc(Pointer ptr, IntBuffer size, NativeSize min_size);
	/**
	 * Allocate and clear a buffer, reusing the given one if large enough.<br>
	 * Like av_fast_malloc(), but all newly allocated space is initially cleared.<br>
	 * Reused buffer is not cleared.<br>
	 * `*ptr` is allowed to be `NULL`, in which case allocation always happens if<br>
	 * `size_needed` is greater than 0.<br>
	 * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.<br>
	 *                         `*ptr` will be overwritten with pointer to new<br>
	 *                         buffer on success or `NULL` on failure<br>
	 * @param[in,out] size     Pointer to current size of buffer `*ptr`. `*size` is<br>
	 *                         changed to `min_size` in case of success or 0 in<br>
	 *                         case of failure<br>
	 * @param[in]     min_size New size of buffer `*ptr`<br>
	 * @see av_fast_malloc()<br>
	 * Original signature : <code>void av_fast_mallocz(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:211</i><br>
	 * @deprecated use the safer methods {@link #av_fast_mallocz(Pointer, IntBuffer, NativeSize)} and {@link #av_fast_mallocz(Pointer, IntByReference, NativeSize)} instead
	 */
	@Deprecated 
	void av_fast_mallocz(Pointer ptr, IntByReference size, NativeSize min_size);
	/**
	 * Allocate and clear a buffer, reusing the given one if large enough.<br>
	 * Like av_fast_malloc(), but all newly allocated space is initially cleared.<br>
	 * Reused buffer is not cleared.<br>
	 * `*ptr` is allowed to be `NULL`, in which case allocation always happens if<br>
	 * `size_needed` is greater than 0.<br>
	 * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.<br>
	 *                         `*ptr` will be overwritten with pointer to new<br>
	 *                         buffer on success or `NULL` on failure<br>
	 * @param[in,out] size     Pointer to current size of buffer `*ptr`. `*size` is<br>
	 *                         changed to `min_size` in case of success or 0 in<br>
	 *                         case of failure<br>
	 * @param[in]     min_size New size of buffer `*ptr`<br>
	 * @see av_fast_malloc()<br>
	 * Original signature : <code>void av_fast_mallocz(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:211</i>
	 */
	void av_fast_mallocz(Pointer ptr, IntBuffer size, NativeSize min_size);
	/**
	 * Free a memory block which has been allocated with a function of av_malloc()<br>
	 * or av_realloc() family.<br>
	 * @param ptr Pointer to the memory block which should be freed.<br>
	 * @note `ptr = NULL` is explicitly allowed.<br>
	 * @note It is recommended that you use av_freep() instead, to prevent leaving<br>
	 *       behind dangling pointers.<br>
	 * @see av_freep()<br>
	 * Original signature : <code>void av_free(void*)</code><br>
	 * <i>native declaration : libavutil\mem.h:222</i>
	 */
	void av_free(Pointer ptr);
	/**
	 * Free a memory block which has been allocated with a function of av_malloc()<br>
	 * or av_realloc() family, and set the pointer pointing to it to `NULL`.<br>
	 * @code{.c}<br>
	 * uint8_t *buf = av_malloc(16);<br>
	 * av_free(buf);<br>
	 * // buf now contains a dangling pointer to freed memory, and accidental<br>
	 * // dereference of buf will result in a use-after-free, which may be a<br>
	 * // security risk.<br>
	 * uint8_t *buf = av_malloc(16);<br>
	 * av_freep(&buf);<br>
	 * // buf is now NULL, and accidental dereference will only result in a<br>
	 * // NULL-pointer dereference.<br>
	 * @endcode<br>
	 * @param ptr Pointer to the pointer to the memory block which should be freed<br>
	 * @note `*ptr = NULL` is safe and leads to no action.<br>
	 * @see av_free()<br>
	 * Original signature : <code>void av_freep(void*)</code><br>
	 * <i>native declaration : libavutil\mem.h:242</i>
	 */
	void av_freep(Pointer ptr);
	/**
	 * Duplicate a string.<br>
	 * @param s String to be duplicated<br>
	 * @return Pointer to a newly-allocated string containing a<br>
	 *         copy of `s` or `NULL` if the string cannot be allocated<br>
	 * @see av_strndup()<br>
	 * Original signature : <code>char* av_strdup(const char*)</code><br>
	 * <i>native declaration : libavutil\mem.h:251</i><br>
	 * @deprecated use the safer methods {@link #av_strdup(String)} and {@link #av_strdup(Pointer)} instead
	 */
	@Deprecated 
	Pointer av_strdup(Pointer s);
	/**
	 * Duplicate a string.<br>
	 * @param s String to be duplicated<br>
	 * @return Pointer to a newly-allocated string containing a<br>
	 *         copy of `s` or `NULL` if the string cannot be allocated<br>
	 * @see av_strndup()<br>
	 * Original signature : <code>char* av_strdup(const char*)</code><br>
	 * <i>native declaration : libavutil\mem.h:251</i>
	 */
	Pointer av_strdup(String s);
	/**
	 * Duplicate a substring of a string.<br>
	 * @param s   String to be duplicated<br>
	 * @param len Maximum length of the resulting string (not counting the<br>
	 *            terminating byte)<br>
	 * @return Pointer to a newly-allocated string containing a<br>
	 *         substring of `s` or `NULL` if the string cannot be allocated<br>
	 * Original signature : <code>char* av_strndup(const char*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:261</i><br>
	 * @deprecated use the safer methods {@link #av_strndup(String, NativeSize)} and {@link #av_strndup(Pointer, NativeSize)} instead
	 */
	@Deprecated 
	Pointer av_strndup(Pointer s, NativeSize len);
	/**
	 * Duplicate a substring of a string.<br>
	 * @param s   String to be duplicated<br>
	 * @param len Maximum length of the resulting string (not counting the<br>
	 *            terminating byte)<br>
	 * @return Pointer to a newly-allocated string containing a<br>
	 *         substring of `s` or `NULL` if the string cannot be allocated<br>
	 * Original signature : <code>char* av_strndup(const char*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:261</i>
	 */
	Pointer av_strndup(String s, NativeSize len);
	/**
	 * Duplicate a buffer with av_malloc().<br>
	 * @param p    Buffer to be duplicated<br>
	 * @param size Size in bytes of the buffer copied<br>
	 * @return Pointer to a newly allocated buffer containing a<br>
	 *         copy of `p` or `NULL` if the buffer cannot be allocated<br>
	 * Original signature : <code>void* av_memdup(const void*, size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:270</i>
	 */
	Pointer av_memdup(Pointer p, NativeSize size);
	/**
	 * Overlapping memcpy() implementation.<br>
	 * @param dst  Destination buffer<br>
	 * @param back Number of bytes back to start copying (i.e. the initial size of<br>
	 *             the overlapping window); must be > 0<br>
	 * @param cnt  Number of bytes to copy; must be >= 0<br>
	 * @note `cnt > back` is valid, this will copy the bytes we just copied,<br>
	 *       thus creating a repeating pattern with a period length of `back`.<br>
	 * Original signature : <code>void av_memcpy_backptr(uint8_t*, int, int)</code><br>
	 * <i>native declaration : libavutil\mem.h:281</i><br>
	 * @deprecated use the safer methods {@link #av_memcpy_backptr(ByteBuffer, int, int)} and {@link #av_memcpy_backptr(Pointer, int, int)} instead
	 */
	@Deprecated 
	void av_memcpy_backptr(Pointer dst, int back, int cnt);
	/**
	 * Overlapping memcpy() implementation.<br>
	 * @param dst  Destination buffer<br>
	 * @param back Number of bytes back to start copying (i.e. the initial size of<br>
	 *             the overlapping window); must be > 0<br>
	 * @param cnt  Number of bytes to copy; must be >= 0<br>
	 * @note `cnt > back` is valid, this will copy the bytes we just copied,<br>
	 *       thus creating a repeating pattern with a period length of `back`.<br>
	 * Original signature : <code>void av_memcpy_backptr(uint8_t*, int, int)</code><br>
	 * <i>native declaration : libavutil\mem.h:281</i>
	 */
	void av_memcpy_backptr(ByteBuffer dst, int back, int cnt);
	/**
	 * Add the pointer to an element to a dynamic array.<br>
	 * The array to grow is supposed to be an array of pointers to<br>
	 * structures, and the element to add must be a pointer to an already<br>
	 * allocated structure.<br>
	 * The array is reallocated when its size reaches powers of 2.<br>
	 * Therefore, the amortized cost of adding an element is constant.<br>
	 * In case of success, the pointer to the array is updated in order to<br>
	 * point to the new grown array, and the number pointed to by `nb_ptr`<br>
	 * is incremented.<br>
	 * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and<br>
	 * `*nb_ptr` is set to 0.<br>
	 * @param[in,out] tab_ptr Pointer to the array to grow<br>
	 * @param[in,out] nb_ptr  Pointer to the number of elements in the array<br>
	 * @param[in]     elem    Element to add<br>
	 * @see av_dynarray_add_nofree(), av_dynarray2_add()<br>
	 * Original signature : <code>void av_dynarray_add(void*, int*, void*)</code><br>
	 * <i>native declaration : libavutil\mem.h:300</i><br>
	 * @deprecated use the safer methods {@link #av_dynarray_add(Pointer, IntBuffer, Pointer)} and {@link #av_dynarray_add(Pointer, IntByReference, Pointer)} instead
	 */
	@Deprecated 
	void av_dynarray_add(Pointer tab_ptr, IntByReference nb_ptr, Pointer elem);
	/**
	 * Add the pointer to an element to a dynamic array.<br>
	 * The array to grow is supposed to be an array of pointers to<br>
	 * structures, and the element to add must be a pointer to an already<br>
	 * allocated structure.<br>
	 * The array is reallocated when its size reaches powers of 2.<br>
	 * Therefore, the amortized cost of adding an element is constant.<br>
	 * In case of success, the pointer to the array is updated in order to<br>
	 * point to the new grown array, and the number pointed to by `nb_ptr`<br>
	 * is incremented.<br>
	 * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and<br>
	 * `*nb_ptr` is set to 0.<br>
	 * @param[in,out] tab_ptr Pointer to the array to grow<br>
	 * @param[in,out] nb_ptr  Pointer to the number of elements in the array<br>
	 * @param[in]     elem    Element to add<br>
	 * @see av_dynarray_add_nofree(), av_dynarray2_add()<br>
	 * Original signature : <code>void av_dynarray_add(void*, int*, void*)</code><br>
	 * <i>native declaration : libavutil\mem.h:300</i>
	 */
	void av_dynarray_add(Pointer tab_ptr, IntBuffer nb_ptr, Pointer elem);
	/**
	 * Add an element to a dynamic array.<br>
	 * Function has the same functionality as av_dynarray_add(),<br>
	 * but it doesn't free memory on fails. It returns error code<br>
	 * instead and leave current buffer untouched.<br>
	 * @return >=0 on success, negative otherwise<br>
	 * @see av_dynarray_add(), av_dynarray2_add()<br>
	 * Original signature : <code>int av_dynarray_add_nofree(void*, int*, void*)</code><br>
	 * <i>native declaration : libavutil\mem.h:310</i><br>
	 * @deprecated use the safer methods {@link #av_dynarray_add_nofree(Pointer, IntBuffer, Pointer)} and {@link #av_dynarray_add_nofree(Pointer, IntByReference, Pointer)} instead
	 */
	@Deprecated 
	int av_dynarray_add_nofree(Pointer tab_ptr, IntByReference nb_ptr, Pointer elem);
	/**
	 * Add an element to a dynamic array.<br>
	 * Function has the same functionality as av_dynarray_add(),<br>
	 * but it doesn't free memory on fails. It returns error code<br>
	 * instead and leave current buffer untouched.<br>
	 * @return >=0 on success, negative otherwise<br>
	 * @see av_dynarray_add(), av_dynarray2_add()<br>
	 * Original signature : <code>int av_dynarray_add_nofree(void*, int*, void*)</code><br>
	 * <i>native declaration : libavutil\mem.h:310</i>
	 */
	int av_dynarray_add_nofree(Pointer tab_ptr, IntBuffer nb_ptr, Pointer elem);
	/**
	 * Add an element of size `elem_size` to a dynamic array.<br>
	 * The array is reallocated when its number of elements reaches powers of 2.<br>
	 * Therefore, the amortized cost of adding an element is constant.<br>
	 * In case of success, the pointer to the array is updated in order to<br>
	 * point to the new grown array, and the number pointed to by `nb_ptr`<br>
	 * is incremented.<br>
	 * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and<br>
	 * `*nb_ptr` is set to 0.<br>
	 * @param[in,out] tab_ptr   Pointer to the array to grow<br>
	 * @param[in,out] nb_ptr    Pointer to the number of elements in the array<br>
	 * @param[in]     elem_size Size in bytes of an element in the array<br>
	 * @param[in]     elem_data Pointer to the data of the element to add. If<br>
	 *                          `NULL`, the space of the newly added element is<br>
	 *                          allocated but left uninitialized.<br>
	 * @return Pointer to the data of the element to copy in the newly allocated<br>
	 *         space<br>
	 * @see av_dynarray_add(), av_dynarray_add_nofree()<br>
	 * Original signature : <code>void* av_dynarray2_add(void**, int*, size_t, const uint8_t*)</code><br>
	 * <i>native declaration : libavutil\mem.h:331</i><br>
	 * @deprecated use the safer methods {@link #av_dynarray2_add(PointerByReference, IntBuffer, NativeSize, byte[])} and {@link #av_dynarray2_add(PointerByReference, IntByReference, NativeSize, Pointer)} instead
	 */
	@Deprecated 
	Pointer av_dynarray2_add(PointerByReference tab_ptr, IntByReference nb_ptr, NativeSize elem_size, Pointer elem_data);
	/**
	 * Add an element of size `elem_size` to a dynamic array.<br>
	 * The array is reallocated when its number of elements reaches powers of 2.<br>
	 * Therefore, the amortized cost of adding an element is constant.<br>
	 * In case of success, the pointer to the array is updated in order to<br>
	 * point to the new grown array, and the number pointed to by `nb_ptr`<br>
	 * is incremented.<br>
	 * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and<br>
	 * `*nb_ptr` is set to 0.<br>
	 * @param[in,out] tab_ptr   Pointer to the array to grow<br>
	 * @param[in,out] nb_ptr    Pointer to the number of elements in the array<br>
	 * @param[in]     elem_size Size in bytes of an element in the array<br>
	 * @param[in]     elem_data Pointer to the data of the element to add. If<br>
	 *                          `NULL`, the space of the newly added element is<br>
	 *                          allocated but left uninitialized.<br>
	 * @return Pointer to the data of the element to copy in the newly allocated<br>
	 *         space<br>
	 * @see av_dynarray_add(), av_dynarray_add_nofree()<br>
	 * Original signature : <code>void* av_dynarray2_add(void**, int*, size_t, const uint8_t*)</code><br>
	 * <i>native declaration : libavutil\mem.h:331</i>
	 */
	Pointer av_dynarray2_add(PointerByReference tab_ptr, IntBuffer nb_ptr, NativeSize elem_size, byte elem_data[]);
	/**
	 * Multiply two `size_t` values checking for overflow.<br>
	 * @param[in]  a,b Operands of multiplication<br>
	 * @param[out] r   Pointer to the result of the operation<br>
	 * @return 0 on success, AVERROR(EINVAL) on overflow<br>
	 * Original signature : <code>int av_size_mult(size_t, size_t, size_t*)</code><br>
	 * <i>native declaration : libavutil\mem.h:345</i>
	 */
	int av_size_mult(NativeSize a, NativeSize b, NativeSizeByReference r);
	/**
	 * Set the maximum size that may be allocated in one block.<br>
	 * The value specified with this function is effective for all libavutil's @ref<br>
	 * lavu_mem_funcs "heap management functions."<br>
	 * By default, the max value is defined as `INT_MAX`.<br>
	 * @param max Value to be set as the new maximum size<br>
	 * @warning Exercise extreme caution when using this function. Don't touch<br>
	 *          this if you do not understand the full consequence of doing so.<br>
	 * Original signature : <code>void av_max_alloc(size_t)</code><br>
	 * <i>native declaration : libavutil\mem.h:356</i>
	 */
	void av_max_alloc(NativeSize max);
	/**
	 * Create an AVRational.<br>
	 * Useful for compilers that do not support compound literals.<br>
	 * @note The return value is not reduced.<br>
	 * @see av_reduce()<br>
	 * Original signature : <code>AVRational av_make_q(int, int)</code><br>
	 * <i>native declaration : libavutil\rational.h:17</i>
	 */
	AVRational.ByValue av_make_q(int num, int den);
	/**
	 * Compare two rationals.<br>
	 * @param a First rational<br>
	 * @param b Second rational<br>
	 * @return One of the following values:<br>
	 *         - 0 if `a == b`<br>
	 *         - 1 if `a > b`<br>
	 *         - -1 if `a < b`<br>
	 *         - `INT_MIN` if one of the values is of the form `0 / 0`<br>
	 * Original signature : <code>int av_cmp_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil\rational.h:41</i>
	 */
	int av_cmp_q(AVRational.ByValue a, AVRational.ByValue b);
	/**
	 * Convert an AVRational to a `double`.<br>
	 * @param a AVRational to convert<br>
	 * @return `a` in floating-point form<br>
	 * @see av_d2q()<br>
	 * Original signature : <code>double av_q2d(AVRational)</code><br>
	 * <i>native declaration : libavutil\rational.h:51</i>
	 */
	double av_q2d(AVRational.ByValue a);
	/**
	 * Reduce a fraction.<br>
	 * This is useful for framerate calculations.<br>
	 * @param[out] dst_num Destination numerator<br>
	 * @param[out] dst_den Destination denominator<br>
	 * @param[in]      num Source numerator<br>
	 * @param[in]      den Source denominator<br>
	 * @param[in]      max Maximum allowed values for `dst_num` & `dst_den`<br>
	 * @return 1 if the operation is exact, 0 otherwise<br>
	 * Original signature : <code>int av_reduce(int*, int*, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil\rational.h:63</i><br>
	 * @deprecated use the safer methods {@link #av_reduce(IntBuffer, IntBuffer, long, long, long)} and {@link #av_reduce(IntByReference, IntByReference, long, long, long)} instead
	 */
	@Deprecated 
	int av_reduce(IntByReference dst_num, IntByReference dst_den, long num, long den, long max);
	/**
	 * Reduce a fraction.<br>
	 * This is useful for framerate calculations.<br>
	 * @param[out] dst_num Destination numerator<br>
	 * @param[out] dst_den Destination denominator<br>
	 * @param[in]      num Source numerator<br>
	 * @param[in]      den Source denominator<br>
	 * @param[in]      max Maximum allowed values for `dst_num` & `dst_den`<br>
	 * @return 1 if the operation is exact, 0 otherwise<br>
	 * Original signature : <code>int av_reduce(int*, int*, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil\rational.h:63</i>
	 */
	int av_reduce(IntBuffer dst_num, IntBuffer dst_den, long num, long den, long max);
	/**
	 * Multiply two rationals.<br>
	 * @param b First rational<br>
	 * @param c Second rational<br>
	 * @return b*c<br>
	 * Original signature : <code>AVRational av_mul_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil\rational.h:71</i>
	 */
	AVRational.ByValue av_mul_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Divide one rational by another.<br>
	 * @param b First rational<br>
	 * @param c Second rational<br>
	 * @return b/c<br>
	 * Original signature : <code>AVRational av_div_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil\rational.h:79</i>
	 */
	AVRational.ByValue av_div_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Add two rationals.<br>
	 * @param b First rational<br>
	 * @param c Second rational<br>
	 * @return b+c<br>
	 * Original signature : <code>AVRational av_add_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil\rational.h:87</i>
	 */
	AVRational.ByValue av_add_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Subtract one rational from another.<br>
	 * @param b First rational<br>
	 * @param c Second rational<br>
	 * @return b-c<br>
	 * Original signature : <code>AVRational av_sub_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil\rational.h:95</i>
	 */
	AVRational.ByValue av_sub_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Invert a rational.<br>
	 * @param q value<br>
	 * @return 1 / q<br>
	 * Original signature : <code>AVRational av_inv_q(AVRational)</code><br>
	 * <i>native declaration : libavutil\rational.h:105</i>
	 */
	AVRational.ByValue av_inv_q(AVRational.ByValue q);
	/**
	 * Convert a double precision floating point number to a rational.<br>
	 * In case of infinity, the returned value is expressed as `{1, 0}` or<br>
	 * `{-1, 0}` depending on the sign.<br>
	 * @param d   `double` to convert<br>
	 * @param max Maximum allowed numerator and denominator<br>
	 * @return `d` in AVRational form<br>
	 * @see av_q2d()<br>
	 * Original signature : <code>AVRational av_d2q(double, int)</code><br>
	 * <i>native declaration : libavutil\rational.h:116</i>
	 */
	AVRational.ByValue av_d2q(double d, int max);
	/**
	 * Find which of the two rationals is closer to another rational.<br>
	 * @param q     Rational to be compared against<br>
	 * @param q1,q2 Rationals to be tested<br>
	 * @return One of the following values:<br>
	 *         - 1 if `q1` is nearer to `q` than `q2`<br>
	 *         - -1 if `q2` is nearer to `q` than `q1`<br>
	 *         - 0 if they have the same distance<br>
	 * Original signature : <code>int av_nearer_q(AVRational, AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil\rational.h:127</i>
	 */
	int av_nearer_q(AVRational.ByValue q, AVRational.ByValue q1, AVRational.ByValue q2);
	/**
	 * Find the value in a list of rationals nearest a given reference rational.<br>
	 * @param q      Reference rational<br>
	 * @param q_list Array of rationals terminated by `{0, 0}`<br>
	 * @return Index of the nearest value found in the array<br>
	 * Original signature : <code>int av_find_nearest_q_idx(AVRational, const AVRational*)</code><br>
	 * <i>native declaration : libavutil\rational.h:135</i>
	 */
	int av_find_nearest_q_idx(AVRational.ByValue q, AVRational q_list);
	/**
	 * Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point<br>
	 * format.<br>
	 * @param q Rational to be converted<br>
	 * @return Equivalent floating-point value, expressed as an unsigned 32-bit<br>
	 *         integer.<br>
	 * @note The returned value is platform-indepedant.<br>
	 * Original signature : <code>uint32_t av_q2intfloat(AVRational)</code><br>
	 * <i>native declaration : libavutil\rational.h:145</i>
	 */
	int av_q2intfloat(AVRational.ByValue q);
	/**
	 * Reinterpret a 32-bit integer as a float.<br>
	 * Original signature : <code>float av_int2float(uint32_t)</code><br>
	 * <i>native declaration : libavutil\intfloat.h:16</i>
	 */
	float av_int2float(int i);
	/**
	 * Reinterpret a float as a 32-bit integer.<br>
	 * Original signature : <code>uint32_t av_float2int(float)</code><br>
	 * <i>native declaration : libavutil\intfloat.h:25</i>
	 */
	int av_float2int(float f);
	/**
	 * Reinterpret a 64-bit integer as a double.<br>
	 * Original signature : <code>double av_int2double(uint64_t)</code><br>
	 * <i>native declaration : libavutil\intfloat.h:34</i>
	 */
	double av_int2double(long i);
	/**
	 * Reinterpret a double as a 64-bit integer.<br>
	 * Original signature : <code>uint64_t av_double2int(double)</code><br>
	 * <i>native declaration : libavutil\intfloat.h:43</i>
	 */
	long av_double2int(double f);
	/**
	 * Compute the greatest common divisor of two integer operands.<br>
	 * @param a,b Operands<br>
	 * @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;<br>
	 * if a == 0 and b == 0, returns 0.<br>
	 * Original signature : <code>int64_t av_gcd(int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil\mathematics.h:21</i>
	 */
	long av_gcd(long a, long b);
	/**
	 * Rescale a 64-bit integer with rounding to nearest.<br>
	 * The operation is mathematically equivalent to `a * b / c`, but writing that<br>
	 * directly can overflow.<br>
	 * This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.<br>
	 * @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()<br>
	 * Original signature : <code>int64_t av_rescale(int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil\mathematics.h:30</i>
	 */
	long av_rescale(long a, long b, long c);
	/**
	 * Rescale a 64-bit integer with specified rounding.<br>
	 * The operation is mathematically equivalent to `a * b / c`, but writing that<br>
	 * directly can overflow, and does not support different rounding methods.<br>
	 * @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()<br>
	 * Original signature : <code>int64_t av_rescale_rnd(int64_t, int64_t, int64_t, AVRounding)</code><br>
	 * <i>native declaration : libavutil\mathematics.h:38</i>
	 */
	long av_rescale_rnd(long a, long b, long c, int rnd);
	/**
	 * Rescale a 64-bit integer by 2 rational numbers.<br>
	 * The operation is mathematically equivalent to `a * bq / cq`.<br>
	 * This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.<br>
	 * @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()<br>
	 * Original signature : <code>int64_t av_rescale_q(int64_t, AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil\mathematics.h:46</i>
	 */
	long av_rescale_q(long a, AVRational.ByValue bq, AVRational.ByValue cq);
	/**
	 * Rescale a 64-bit integer by 2 rational numbers with specified rounding.<br>
	 * The operation is mathematically equivalent to `a * bq / cq`.<br>
	 * @see av_rescale(), av_rescale_rnd(), av_rescale_q()<br>
	 * Original signature : <code>int64_t av_rescale_q_rnd(int64_t, AVRational, AVRational, AVRounding)</code><br>
	 * <i>native declaration : libavutil\mathematics.h:53</i>
	 */
	long av_rescale_q_rnd(long a, AVRational.ByValue bq, AVRational.ByValue cq, int rnd);
	/**
	 * Compare two timestamps each in its own time base.<br>
	 * @return One of the following values:<br>
	 *         - -1 if `ts_a` is before `ts_b`<br>
	 *         - 1 if `ts_a` is after `ts_b`<br>
	 *         - 0 if they represent the same position<br>
	 * @warning<br>
	 * The result of the function is undefined if one of the timestamps is outside<br>
	 * the `int64_t` range when represented in the other's timebase.<br>
	 * Original signature : <code>int av_compare_ts(int64_t, AVRational, int64_t, AVRational)</code><br>
	 * <i>native declaration : libavutil\mathematics.h:65</i>
	 */
	int av_compare_ts(long ts_a, AVRational.ByValue tb_a, long ts_b, AVRational.ByValue tb_b);
	/**
	 * Compare the remainders of two integer operands divided by a common divisor.<br>
	 * In other words, compare the least significant `log2(mod)` bits of integers<br>
	 * `a` and `b`.<br>
	 * @code{.c}<br>
	 * av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)<br>
	 * av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)<br>
	 * @endcode<br>
	 * @param a,b Operands<br>
	 * @param mod Divisor; must be a power of 2<br>
	 * @return<br>
	 *         - a negative value if `a % mod < b % mod`<br>
	 *         - a positive value if `a % mod > b % mod`<br>
	 *         - zero             if `a % mod == b % mod`<br>
	 * Original signature : <code>int64_t av_compare_mod(uint64_t, uint64_t, uint64_t)</code><br>
	 * <i>native declaration : libavutil\mathematics.h:82</i>
	 */
	long av_compare_mod(long a, long b, long mod);
	/**
	 * Rescale a timestamp while preserving known durations.<br>
	 * This function is designed to be called per audio packet to scale the input<br>
	 * timestamp to a different time base. Compared to a simple av_rescale_q()<br>
	 * call, this function is robust against possible inconsistent frame durations.<br>
	 * The `last` parameter is a state variable that must be preserved for all<br>
	 * subsequent calls for the same stream. For the first call, `*last` should be<br>
	 * initialized to #AV_NOPTS_VALUE.<br>
	 * @param[in]     in_tb    Input time base<br>
	 * @param[in]     in_ts    Input timestamp<br>
	 * @param[in]     fs_tb    Duration time base; typically this is finer-grained<br>
	 *                         (greater) than `in_tb` and `out_tb`<br>
	 * @param[in]     duration Duration till the next call to this function (i.e.<br>
	 *                         duration of the current packet/frame)<br>
	 * @param[in,out] last     Pointer to a timestamp expressed in terms of<br>
	 *                         `fs_tb`, acting as a state variable<br>
	 * @param[in]     out_tb   Output timebase<br>
	 * @return        Timestamp expressed in terms of `out_tb`<br>
	 * @note In the context of this function, "duration" is in term of samples, not<br>
	 *       seconds.<br>
	 * Original signature : <code>int64_t av_rescale_delta(AVRational, int64_t, AVRational, int, int64_t*, AVRational)</code><br>
	 * <i>native declaration : libavutil\mathematics.h:105</i><br>
	 * @deprecated use the safer methods {@link #av_rescale_delta(org.ffmpeg.avutil55.AVRational.ByValue, long, org.ffmpeg.avutil55.AVRational.ByValue, int, LongBuffer, org.ffmpeg.avutil55.AVRational.ByValue)} and {@link #av_rescale_delta(org.ffmpeg.avutil55.AVRational.ByValue, long, org.ffmpeg.avutil55.AVRational.ByValue, int, LongByReference, org.ffmpeg.avutil55.AVRational.ByValue)} instead
	 */
	@Deprecated 
	long av_rescale_delta(AVRational.ByValue in_tb, long in_ts, AVRational.ByValue fs_tb, int duration, LongByReference last, AVRational.ByValue out_tb);
	/**
	 * Rescale a timestamp while preserving known durations.<br>
	 * This function is designed to be called per audio packet to scale the input<br>
	 * timestamp to a different time base. Compared to a simple av_rescale_q()<br>
	 * call, this function is robust against possible inconsistent frame durations.<br>
	 * The `last` parameter is a state variable that must be preserved for all<br>
	 * subsequent calls for the same stream. For the first call, `*last` should be<br>
	 * initialized to #AV_NOPTS_VALUE.<br>
	 * @param[in]     in_tb    Input time base<br>
	 * @param[in]     in_ts    Input timestamp<br>
	 * @param[in]     fs_tb    Duration time base; typically this is finer-grained<br>
	 *                         (greater) than `in_tb` and `out_tb`<br>
	 * @param[in]     duration Duration till the next call to this function (i.e.<br>
	 *                         duration of the current packet/frame)<br>
	 * @param[in,out] last     Pointer to a timestamp expressed in terms of<br>
	 *                         `fs_tb`, acting as a state variable<br>
	 * @param[in]     out_tb   Output timebase<br>
	 * @return        Timestamp expressed in terms of `out_tb`<br>
	 * @note In the context of this function, "duration" is in term of samples, not<br>
	 *       seconds.<br>
	 * Original signature : <code>int64_t av_rescale_delta(AVRational, int64_t, AVRational, int, int64_t*, AVRational)</code><br>
	 * <i>native declaration : libavutil\mathematics.h:105</i>
	 */
	long av_rescale_delta(AVRational.ByValue in_tb, long in_ts, AVRational.ByValue fs_tb, int duration, LongBuffer last, AVRational.ByValue out_tb);
	/**
	 * Add a value to a timestamp.<br>
	 * This function guarantees that when the same value is repeatly added that<br>
	 * no accumulation of rounding errors occurs.<br>
	 * @param[in] ts     Input timestamp<br>
	 * @param[in] ts_tb  Input timestamp time base<br>
	 * @param[in] inc    Value to be added<br>
	 * @param[in] inc_tb Time base of `inc`<br>
	 * Original signature : <code>int64_t av_add_stable(AVRational, int64_t, AVRational, int64_t)</code><br>
	 * <i>native declaration : libavutil\mathematics.h:116</i>
	 */
	long av_add_stable(AVRational.ByValue ts_tb, long ts, AVRational.ByValue inc_tb, long inc);
	/**
	 * Send the specified message to the log if the level is less than or equal<br>
	 * to the current av_log_level. By default, all logging messages are sent to<br>
	 * stderr. This behavior can be altered by setting a different logging callback<br>
	 * function.<br>
	 * @see av_log_set_callback<br>
	 * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 *        pointer to an AVClass struct or NULL if general log.<br>
	 * @param level The importance level of the message expressed using a @ref<br>
	 *        lavu_log_constants "Logging Constant".<br>
	 * @param fmt The format string (printf-compatible) that specifies how<br>
	 *        subsequent arguments are converted to output.<br>
	 * Original signature : <code>void av_log(void*, int, const char*, null)</code><br>
	 * <i>native declaration : libavutil\log.h:59</i><br>
	 * @deprecated use the safer methods {@link #av_log(Pointer, int, String, Object)} and {@link #av_log(Pointer, int, Pointer, Object)} instead
	 */
	@Deprecated 
	void av_log(Pointer avcl, int level, Pointer fmt, Object... varArgs1);
	/**
	 * Send the specified message to the log if the level is less than or equal<br>
	 * to the current av_log_level. By default, all logging messages are sent to<br>
	 * stderr. This behavior can be altered by setting a different logging callback<br>
	 * function.<br>
	 * @see av_log_set_callback<br>
	 * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 *        pointer to an AVClass struct or NULL if general log.<br>
	 * @param level The importance level of the message expressed using a @ref<br>
	 *        lavu_log_constants "Logging Constant".<br>
	 * @param fmt The format string (printf-compatible) that specifies how<br>
	 *        subsequent arguments are converted to output.<br>
	 * Original signature : <code>void av_log(void*, int, const char*, null)</code><br>
	 * <i>native declaration : libavutil\log.h:59</i>
	 */
	void av_log(Pointer avcl, int level, String fmt, Object... varArgs1);
	/**
	 * Send the specified message to the log if the level is less than or equal<br>
	 * to the current av_log_level. By default, all logging messages are sent to<br>
	 * stderr. This behavior can be altered by setting a different logging callback<br>
	 * function.<br>
	 * @see av_log_set_callback<br>
	 * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 *        pointer to an AVClass struct.<br>
	 * @param level The importance level of the message expressed using a @ref<br>
	 *        lavu_log_constants "Logging Constant".<br>
	 * @param fmt The format string (printf-compatible) that specifies how<br>
	 *        subsequent arguments are converted to output.<br>
	 * @param vl The arguments referenced by the format string.<br>
	 * Original signature : <code>void av_vlog(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : libavutil\log.h:75</i><br>
	 * @deprecated use the safer methods {@link #av_vlog(Pointer, int, String, Object)} and {@link #av_vlog(Pointer, int, Pointer, Object)} instead
	 */
	@Deprecated 
	void av_vlog(Pointer avcl, int level, Pointer fmt, Object... vl);
	/**
	 * Send the specified message to the log if the level is less than or equal<br>
	 * to the current av_log_level. By default, all logging messages are sent to<br>
	 * stderr. This behavior can be altered by setting a different logging callback<br>
	 * function.<br>
	 * @see av_log_set_callback<br>
	 * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 *        pointer to an AVClass struct.<br>
	 * @param level The importance level of the message expressed using a @ref<br>
	 *        lavu_log_constants "Logging Constant".<br>
	 * @param fmt The format string (printf-compatible) that specifies how<br>
	 *        subsequent arguments are converted to output.<br>
	 * @param vl The arguments referenced by the format string.<br>
	 * Original signature : <code>void av_vlog(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : libavutil\log.h:75</i>
	 */
	void av_vlog(Pointer avcl, int level, String fmt, Object... vl);
	/**
	 * Get the current log level<br>
	 * @see lavu_log_constants<br>
	 * @return Current log level<br>
	 * Original signature : <code>int av_log_get_level()</code><br>
	 * <i>native declaration : libavutil\log.h:82</i>
	 */
	int av_log_get_level();
	/**
	 * Set the log level<br>
	 * @see lavu_log_constants<br>
	 * @param level Logging level<br>
	 * Original signature : <code>void av_log_set_level(int)</code><br>
	 * <i>native declaration : libavutil\log.h:89</i>
	 */
	void av_log_set_level(int level);
	/**
	 * Set the logging callback<br>
	 * @note The callback must be thread safe, even if the application does not use<br>
	 *       threads itself as some codecs are multithreaded.<br>
	 * @see av_log_default_callback<br>
	 * @param callback A logging function with a compatible signature.<br>
	 * Original signature : <code>void av_log_set_callback(av_log_set_callback_callback_callback*)</code><br>
	 * <i>native declaration : libavutil\log.h:98</i>
	 */
	void av_log_set_callback(av_log_set_callback_callback_callback callback);
	/**
	 * Default logging callback<br>
	 * It prints the message to stderr, optionally colorizing it.<br>
	 * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 *        pointer to an AVClass struct.<br>
	 * @param level The importance level of the message expressed using a @ref<br>
	 *        lavu_log_constants "Logging Constant".<br>
	 * @param fmt The format string (printf-compatible) that specifies how<br>
	 *        subsequent arguments are converted to output.<br>
	 * @param vl The arguments referenced by the format string.<br>
	 * Original signature : <code>void av_log_default_callback(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : libavutil\log.h:111</i><br>
	 * @deprecated use the safer methods {@link #av_log_default_callback(Pointer, int, String, Object)} and {@link #av_log_default_callback(Pointer, int, Pointer, Object)} instead
	 */
	@Deprecated 
	void av_log_default_callback(Pointer avcl, int level, Pointer fmt, Object... vl);
	/**
	 * Default logging callback<br>
	 * It prints the message to stderr, optionally colorizing it.<br>
	 * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 *        pointer to an AVClass struct.<br>
	 * @param level The importance level of the message expressed using a @ref<br>
	 *        lavu_log_constants "Logging Constant".<br>
	 * @param fmt The format string (printf-compatible) that specifies how<br>
	 *        subsequent arguments are converted to output.<br>
	 * @param vl The arguments referenced by the format string.<br>
	 * Original signature : <code>void av_log_default_callback(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : libavutil\log.h:111</i>
	 */
	void av_log_default_callback(Pointer avcl, int level, String fmt, Object... vl);
	/**
	 * Return the context name<br>
	 * @param  ctx The AVClass context<br>
	 * @return The AVClass class_name<br>
	 * Original signature : <code>char* av_default_item_name(void*)</code><br>
	 * <i>native declaration : libavutil\log.h:118</i>
	 */
	String av_default_item_name(Pointer ctx);
	/**
	 * Original signature : <code>AVClassCategory av_default_get_category(void*)</code><br>
	 * <i>native declaration : libavutil\log.h:120</i>
	 */
	int av_default_get_category(Pointer ptr);
	/**
	 * Format a line of log the same way as the default callback.<br>
	 * @param line          buffer to receive the formatted line<br>
	 * @param line_size     size of the buffer<br>
	 * @param print_prefix  used to store whether the prefix must be printed;<br>
	 *                      must point to a persistent integer initially set to 1<br>
	 * Original signature : <code>void av_log_format_line(void*, int, const char*, va_list, char*, int, int*)</code><br>
	 * <i>native declaration : libavutil\log.h:129</i><br>
	 * use the safer methods {@link #av_log_format_line(Pointer, int, String, Pointer, ByteBuffer, int, IntBuffer)} and {@link #av_log_format_line(Pointer, int, Pointer, Pointer, Pointer, int, IntByReference)} instead
	 */
	void av_log_format_line(Pointer ptr, int level, Pointer fmt, Pointer vl, Pointer line, int line_size, IntBuffer print_prefix);
	/**
	 * Format a line of log the same way as the default callback.<br>
	 * @param line          buffer to receive the formatted line<br>
	 * @param line_size     size of the buffer<br>
	 * @param print_prefix  used to store whether the prefix must be printed;<br>
	 *                      must point to a persistent integer initially set to 1<br>
	 * Original signature : <code>void av_log_format_line(void*, int, const char*, va_list, char*, int, int*)</code><br>
	 * <i>native declaration : libavutil\log.h:129</i>
	 */
	void av_log_format_line(Pointer ptr, int level, Pointer fmt, Pointer vl, ByteBuffer line, int line_size, IntBuffer print_prefix);
	/**
	 * Format a line of log the same way as the default callback.<br>
	 * @param line          buffer to receive the formatted line;<br>
	 *                      may be NULL if line_size is 0<br>
	 * @param line_size     size of the buffer; at most line_size-1 characters will<br>
	 *                      be written to the buffer, plus one null terminator<br>
	 * @param print_prefix  used to store whether the prefix must be printed;<br>
	 *                      must point to a persistent integer initially set to 1<br>
	 * @return Returns a negative value if an error occurred, otherwise returns<br>
	 *         the number of characters that would have been written for a<br>
	 *         sufficiently large buffer, not including the terminating null<br>
	 *         character. If the return value is not less than line_size, it means<br>
	 *         that the log message was truncated to fit the buffer.<br>
	 * Original signature : <code>int av_log_format_line2(void*, int, const char*, va_list, char*, int, int*)</code><br>
	 * <i>native declaration : libavutil\log.h:145</i><br>
	 * @deprecated use the safer methods {@link #av_log_format_line2(Pointer, int, String, Pointer, ByteBuffer, int, IntBuffer)} and {@link #av_log_format_line2(Pointer, int, Pointer, Pointer, Pointer, int, IntByReference)} instead
	 */
	@Deprecated 
	int av_log_format_line2(Pointer ptr, int level, Pointer fmt, Pointer vl, Pointer line, int line_size, IntByReference print_prefix);
	/**
	 * Format a line of log the same way as the default callback.<br>
	 * @param line          buffer to receive the formatted line;<br>
	 *                      may be NULL if line_size is 0<br>
	 * @param line_size     size of the buffer; at most line_size-1 characters will<br>
	 *                      be written to the buffer, plus one null terminator<br>
	 * @param print_prefix  used to store whether the prefix must be printed;<br>
	 *                      must point to a persistent integer initially set to 1<br>
	 * @return Returns a negative value if an error occurred, otherwise returns<br>
	 *         the number of characters that would have been written for a<br>
	 *         sufficiently large buffer, not including the terminating null<br>
	 *         character. If the return value is not less than line_size, it means<br>
	 *         that the log message was truncated to fit the buffer.<br>
	 * Original signature : <code>int av_log_format_line2(void*, int, const char*, va_list, char*, int, int*)</code><br>
	 * <i>native declaration : libavutil\log.h:145</i>
	 */
	int av_log_format_line2(Pointer ptr, int level, String fmt, Pointer vl, ByteBuffer line, int line_size, IntBuffer print_prefix);
	/**
	 * Include the log severity in messages originating from codecs.<br>
	 * Results in messages such as:<br>
	 * [rawvideo @ 0xDEADBEEF] [error] encode did not produce valid pts<br>
	 * Original signature : <code>void av_log_set_flags(int)</code><br>
	 * <i>native declaration : libavutil\log.h:152</i>
	 */
	void av_log_set_flags(int arg);
	/**
	 * Original signature : <code>int av_log_get_flags()</code><br>
	 * <i>native declaration : libavutil\log.h:154</i>
	 */
	int av_log_get_flags();
	/**
	 * Return x default pointer in case p is NULL.<br>
	 * Original signature : <code>void* av_x_if_null(const void*, const void*)</code><br>
	 * <i>native declaration : libavutil\avutil.h:6</i>
	 */
	Pointer av_x_if_null(Pointer p, Pointer x);
	/**
	 * Compute the length of an integer list.<br>
	 * @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)<br>
	 * @param term    list terminator (usually 0 or -1)<br>
	 * @param list    pointer to the list<br>
	 * @return  length of the list, in elements, not counting the terminator<br>
	 * Original signature : <code>int av_int_list_length_for_size(unsigned, const void*, uint64_t)</code><br>
	 * <i>native declaration : libavutil\avutil.h:15</i>
	 */
	int av_int_list_length_for_size(int elsize, Pointer list, long term);
	/**
	 * Open a file using a UTF-8 filename.<br>
	 * The API of this function matches POSIX fopen(), errors are returned through<br>
	 * errno.<br>
	 * Original signature : <code>FILE* av_fopen_utf8(const char*, const char*)</code><br>
	 * <i>native declaration : libavutil\avutil.h:22</i><br>
	 * @deprecated use the safer methods {@link #av_fopen_utf8(String, String)} and {@link #av_fopen_utf8(Pointer, Pointer)} instead
	 */
	@Deprecated 
	FILE av_fopen_utf8(Pointer path, Pointer mode);
	/**
	 * Open a file using a UTF-8 filename.<br>
	 * The API of this function matches POSIX fopen(), errors are returned through<br>
	 * errno.<br>
	 * Original signature : <code>FILE* av_fopen_utf8(const char*, const char*)</code><br>
	 * <i>native declaration : libavutil\avutil.h:22</i>
	 */
	FILE av_fopen_utf8(String path, String mode);
	/**
	 * Return the fractional representation of the internal time base.<br>
	 * Original signature : <code>AVRational av_get_time_base_q()</code><br>
	 * <i>native declaration : libavutil\avutil.h:27</i>
	 */
	AVRational.ByValue av_get_time_base_q();
	/**
	 * Fill the provided buffer with a string containing a FourCC (four-character<br>
	 * code) representation.<br>
	 * @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE<br>
	 * @param fourcc the fourcc to represent<br>
	 * @return the buffer in input<br>
	 * Original signature : <code>char* av_fourcc_make_string(char*, uint32_t)</code><br>
	 * <i>native declaration : libavutil\avutil.h:36</i><br>
	 * @deprecated use the safer methods {@link #av_fourcc_make_string(ByteBuffer, int)} and {@link #av_fourcc_make_string(Pointer, int)} instead
	 */
	@Deprecated 
	Pointer av_fourcc_make_string(Pointer buf, int fourcc);
	/**
	 * Fill the provided buffer with a string containing a FourCC (four-character<br>
	 * code) representation.<br>
	 * @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE<br>
	 * @param fourcc the fourcc to represent<br>
	 * @return the buffer in input<br>
	 * Original signature : <code>char* av_fourcc_make_string(char*, uint32_t)</code><br>
	 * <i>native declaration : libavutil\avutil.h:36</i>
	 */
	Pointer av_fourcc_make_string(ByteBuffer buf, int fourcc);
	/**
	 * Get a dictionary entry with matching key.<br>
	 * The returned entry key or value must not be changed, or it will<br>
	 * cause undefined behavior.<br>
	 * To iterate through all the dictionary entries, you can set the matching key<br>
	 * to the null string "" and set the AV_DICT_IGNORE_SUFFIX flag.<br>
	 * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param key matching key<br>
	 * @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved<br>
	 * @return found entry or NULL in case no matching entry was found in the dictionary<br>
	 * Original signature : <code>AVDictionaryEntry* av_dict_get(const AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:45</i><br>
	 * @deprecated use the safer methods {@link #av_dict_get(org.ffmpeg.avutil55.AVDictionary, String, org.ffmpeg.avutil55.AVDictionaryEntry, int)} and {@link #av_dict_get(org.ffmpeg.avutil55.AVDictionary, Pointer, org.ffmpeg.avutil55.AVDictionaryEntry, int)} instead
	 */
	@Deprecated 
	AVDictionaryEntry av_dict_get(AVDictionary m, Pointer key, AVDictionaryEntry prev, int flags);
	/**
	 * Get a dictionary entry with matching key.<br>
	 * The returned entry key or value must not be changed, or it will<br>
	 * cause undefined behavior.<br>
	 * To iterate through all the dictionary entries, you can set the matching key<br>
	 * to the null string "" and set the AV_DICT_IGNORE_SUFFIX flag.<br>
	 * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param key matching key<br>
	 * @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved<br>
	 * @return found entry or NULL in case no matching entry was found in the dictionary<br>
	 * Original signature : <code>AVDictionaryEntry* av_dict_get(const AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:45</i>
	 */
	AVDictionaryEntry av_dict_get(AVDictionary m, String key, AVDictionaryEntry prev, int flags);
	/**
	 * Get number of entries in dictionary.<br>
	 * @param m dictionary<br>
	 * @return  number of entries in dictionary<br>
	 * Original signature : <code>int av_dict_count(const AVDictionary*)</code><br>
	 * <i>native declaration : libavutil\dict.h:52</i>
	 */
	int av_dict_count(AVDictionary m);
	/**
	 * Set the given entry in *pm, overwriting an existing entry.<br>
	 * Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,<br>
	 * these arguments will be freed on error.<br>
	 * Warning: Adding a new entry to a dictionary invalidates all existing entries<br>
	 * previously returned with av_dict_get.<br>
	 * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL<br>
	 * a dictionary struct is allocated and put in *pm.<br>
	 * @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)<br>
	 * @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).<br>
	 *        Passing a NULL value will cause an existing entry to be deleted.<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_dict_set(AVDictionary**, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:67</i><br>
	 * @deprecated use the safer methods {@link #av_dict_set(org.ffmpeg.avutil55.AVDictionary.ByReference[], String, String, int)} and {@link #av_dict_set(org.ffmpeg.avutil55.AVDictionary.ByReference[], Pointer, Pointer, int)} instead
	 */
	@Deprecated 
	int av_dict_set(PointerByReference pm, Pointer key, Pointer value, int flags);
	/**
	 * Set the given entry in *pm, overwriting an existing entry.<br>
	 * Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,<br>
	 * these arguments will be freed on error.<br>
	 * Warning: Adding a new entry to a dictionary invalidates all existing entries<br>
	 * previously returned with av_dict_get.<br>
	 * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL<br>
	 * a dictionary struct is allocated and put in *pm.<br>
	 * @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)<br>
	 * @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).<br>
	 *        Passing a NULL value will cause an existing entry to be deleted.<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_dict_set(AVDictionary**, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:67</i>
	 */
	int av_dict_set(AVDictionary.ByReference pm[], String key, String value, int flags);
	/**
	 * Set the given entry in *pm, overwriting an existing entry.<br>
	 * Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,<br>
	 * these arguments will be freed on error.<br>
	 * Warning: Adding a new entry to a dictionary invalidates all existing entries<br>
	 * previously returned with av_dict_get.<br>
	 * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL<br>
	 * a dictionary struct is allocated and put in *pm.<br>
	 * @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)<br>
	 * @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).<br>
	 *        Passing a NULL value will cause an existing entry to be deleted.<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_dict_set(AVDictionary**, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:67</i>
	 */
	int av_dict_set(AVDictionary.ByReference pm[], Pointer key, Pointer value, int flags);
	/**
	 * Convenience wrapper for av_dict_set that converts the value to a string<br>
	 * and stores it.<br>
	 * Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.<br>
	 * Original signature : <code>int av_dict_set_int(AVDictionary**, const char*, int64_t, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:74</i><br>
	 * @deprecated use the safer methods {@link #av_dict_set_int(org.ffmpeg.avutil55.AVDictionary.ByReference[], String, long, int)} and {@link #av_dict_set_int(org.ffmpeg.avutil55.AVDictionary.ByReference[], Pointer, long, int)} instead
	 */
	@Deprecated 
	int av_dict_set_int(PointerByReference pm, Pointer key, long value, int flags);
	/**
	 * Convenience wrapper for av_dict_set that converts the value to a string<br>
	 * and stores it.<br>
	 * Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.<br>
	 * Original signature : <code>int av_dict_set_int(AVDictionary**, const char*, int64_t, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:74</i>
	 */
	int av_dict_set_int(AVDictionary.ByReference pm[], String key, long value, int flags);
	/**
	 * Convenience wrapper for av_dict_set that converts the value to a string<br>
	 * and stores it.<br>
	 * Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.<br>
	 * Original signature : <code>int av_dict_set_int(AVDictionary**, const char*, int64_t, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:74</i>
	 */
	int av_dict_set_int(AVDictionary.ByReference pm[], Pointer key, long value, int flags);
	/**
	 * Parse the key/value pairs list and add the parsed entries to a dictionary.<br>
	 * In case of failure, all the successfully set entries are stored in<br>
	 * *pm. You may need to manually free the created dictionary.<br>
	 * @param key_val_sep  a 0-terminated list of characters used to separate<br>
	 *                     key from value<br>
	 * @param pairs_sep    a 0-terminated list of characters used to separate<br>
	 *                     two pairs from each other<br>
	 * @param flags        flags to use when adding to dictionary.<br>
	 *                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL<br>
	 *                     are ignored since the key/value tokens will always<br>
	 *                     be duplicated.<br>
	 * @return             0 on success, negative AVERROR code on failure<br>
	 * Original signature : <code>int av_dict_parse_string(AVDictionary**, const char*, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:90</i><br>
	 * @deprecated use the safer methods {@link #av_dict_parse_string(org.ffmpeg.avutil55.AVDictionary.ByReference[], String, String, String, int)} and {@link #av_dict_parse_string(org.ffmpeg.avutil55.AVDictionary.ByReference[], Pointer, Pointer, Pointer, int)} instead
	 */
	@Deprecated 
	int av_dict_parse_string(PointerByReference pm, Pointer str, Pointer key_val_sep, Pointer pairs_sep, int flags);
	/**
	 * Parse the key/value pairs list and add the parsed entries to a dictionary.<br>
	 * In case of failure, all the successfully set entries are stored in<br>
	 * *pm. You may need to manually free the created dictionary.<br>
	 * @param key_val_sep  a 0-terminated list of characters used to separate<br>
	 *                     key from value<br>
	 * @param pairs_sep    a 0-terminated list of characters used to separate<br>
	 *                     two pairs from each other<br>
	 * @param flags        flags to use when adding to dictionary.<br>
	 *                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL<br>
	 *                     are ignored since the key/value tokens will always<br>
	 *                     be duplicated.<br>
	 * @return             0 on success, negative AVERROR code on failure<br>
	 * Original signature : <code>int av_dict_parse_string(AVDictionary**, const char*, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:90</i>
	 */
	int av_dict_parse_string(AVDictionary.ByReference pm[], String str, String key_val_sep, String pairs_sep, int flags);
	/**
	 * Parse the key/value pairs list and add the parsed entries to a dictionary.<br>
	 * In case of failure, all the successfully set entries are stored in<br>
	 * *pm. You may need to manually free the created dictionary.<br>
	 * @param key_val_sep  a 0-terminated list of characters used to separate<br>
	 *                     key from value<br>
	 * @param pairs_sep    a 0-terminated list of characters used to separate<br>
	 *                     two pairs from each other<br>
	 * @param flags        flags to use when adding to dictionary.<br>
	 *                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL<br>
	 *                     are ignored since the key/value tokens will always<br>
	 *                     be duplicated.<br>
	 * @return             0 on success, negative AVERROR code on failure<br>
	 * Original signature : <code>int av_dict_parse_string(AVDictionary**, const char*, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:90</i>
	 */
	int av_dict_parse_string(AVDictionary.ByReference pm[], Pointer str, Pointer key_val_sep, Pointer pairs_sep, int flags);
	/**
	 * Copy entries from one AVDictionary struct into another.<br>
	 * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,<br>
	 *            this function will allocate a struct for you and put it in *dst<br>
	 * @param src pointer to source AVDictionary struct<br>
	 * @param flags flags to use when setting entries in *dst<br>
	 * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag<br>
	 * @return 0 on success, negative AVERROR code on failure. If dst was allocated<br>
	 *           by this function, callers should free the associated memory.<br>
	 * Original signature : <code>int av_dict_copy(AVDictionary**, const AVDictionary*, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:102</i><br>
	 * @deprecated use the safer method {@link #av_dict_copy(org.ffmpeg.avutil55.AVDictionary.ByReference[], org.ffmpeg.avutil55.AVDictionary, int)} instead
	 */
	@Deprecated 
	int av_dict_copy(PointerByReference dst, AVDictionary src, int flags);
	/**
	 * Copy entries from one AVDictionary struct into another.<br>
	 * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,<br>
	 *            this function will allocate a struct for you and put it in *dst<br>
	 * @param src pointer to source AVDictionary struct<br>
	 * @param flags flags to use when setting entries in *dst<br>
	 * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag<br>
	 * @return 0 on success, negative AVERROR code on failure. If dst was allocated<br>
	 *           by this function, callers should free the associated memory.<br>
	 * Original signature : <code>int av_dict_copy(AVDictionary**, const AVDictionary*, int)</code><br>
	 * <i>native declaration : libavutil\dict.h:102</i>
	 */
	int av_dict_copy(AVDictionary.ByReference dst[], AVDictionary src, int flags);
	/**
	 * Free all the memory allocated for an AVDictionary struct<br>
	 * and all keys and values.<br>
	 * Original signature : <code>void av_dict_free(AVDictionary**)</code><br>
	 * <i>native declaration : libavutil\dict.h:108</i><br>
	 * @deprecated use the safer method {@link #av_dict_free(org.ffmpeg.avutil55.AVDictionary.ByReference[])} instead
	 */
	@Deprecated 
	void av_dict_free(PointerByReference m);
	/**
	 * Free all the memory allocated for an AVDictionary struct<br>
	 * and all keys and values.<br>
	 * Original signature : <code>void av_dict_free(AVDictionary**)</code><br>
	 * <i>native declaration : libavutil\dict.h:108</i>
	 */
	void av_dict_free(AVDictionary.ByReference m[]);
	/**
	 * Get dictionary entries as a string.<br>
	 * Create a string containing dictionary's entries.<br>
	 * Such string may be passed back to av_dict_parse_string().<br>
	 * @note String is escaped with backslashes ('\').<br>
	 * @param[in]  m             dictionary<br>
	 * @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.<br>
	 *                           Buffer must be freed by the caller when is no longer needed.<br>
	 * @param[in]  key_val_sep   character used to separate key from value<br>
	 * @param[in]  pairs_sep     character used to separate two pairs from each other<br>
	 * @return                   >= 0 on success, negative on error<br>
	 * @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.<br>
	 * Original signature : <code>int av_dict_get_string(const AVDictionary*, char**, const char, const char)</code><br>
	 * <i>native declaration : libavutil\dict.h:123</i>
	 */
	int av_dict_get_string(AVDictionary m, PointerByReference buffer, byte key_val_sep, byte pairs_sep);
	/**
	 * Allocate an AVBuffer of the given size using av_malloc().<br>
	 * @return an AVBufferRef of given size or NULL when out of memory<br>
	 * Original signature : <code>AVBufferRef* av_buffer_alloc(int)</code><br>
	 * <i>native declaration : libavutil\buffer.h:22</i>
	 */
	AVBufferRef av_buffer_alloc(int size);
	/**
	 * Same as av_buffer_alloc(), except the returned buffer will be initialized<br>
	 * to zero.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_allocz(int)</code><br>
	 * <i>native declaration : libavutil\buffer.h:28</i>
	 */
	AVBufferRef av_buffer_allocz(int size);
	/**
	 * Create an AVBuffer from an existing array.<br>
	 * If this function is successful, data is owned by the AVBuffer. The caller may<br>
	 * only access data through the returned AVBufferRef and references derived from<br>
	 * it.<br>
	 * If this function fails, data is left untouched.<br>
	 * @param data   data array<br>
	 * @param size   size of data in bytes<br>
	 * @param free   a callback for freeing this buffer's data<br>
	 * @param opaque parameter to be got for processing or passed to free<br>
	 * @param flags  a combination of AV_BUFFER_FLAG_*<br>
	 * @return an AVBufferRef referring to data on success, NULL on failure.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_create(uint8_t*, int, av_buffer_create_free_callback*, void*, int)</code><br>
	 * <i>native declaration : libavutil\buffer.h:43</i><br>
	 * @deprecated use the safer methods {@link #av_buffer_create(ByteBuffer, int, org.ffmpeg.avutil55.Avutil55Library.av_buffer_create_free_callback, Pointer, int)} and {@link #av_buffer_create(Pointer, int, org.ffmpeg.avutil55.Avutil55Library.av_buffer_create_free_callback, Pointer, int)} instead
	 */
	@Deprecated 
	AVBufferRef av_buffer_create(Pointer data, int size, av_buffer_create_free_callback free, Pointer opaque, int flags);
	/**
	 * Create an AVBuffer from an existing array.<br>
	 * If this function is successful, data is owned by the AVBuffer. The caller may<br>
	 * only access data through the returned AVBufferRef and references derived from<br>
	 * it.<br>
	 * If this function fails, data is left untouched.<br>
	 * @param data   data array<br>
	 * @param size   size of data in bytes<br>
	 * @param free   a callback for freeing this buffer's data<br>
	 * @param opaque parameter to be got for processing or passed to free<br>
	 * @param flags  a combination of AV_BUFFER_FLAG_*<br>
	 * @return an AVBufferRef referring to data on success, NULL on failure.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_create(uint8_t*, int, av_buffer_create_free_callback*, void*, int)</code><br>
	 * <i>native declaration : libavutil\buffer.h:43</i>
	 */
	AVBufferRef av_buffer_create(ByteBuffer data, int size, av_buffer_create_free_callback free, Pointer opaque, int flags);
	/**
	 * Default free callback, which calls av_free() on the buffer data.<br>
	 * This function is meant to be passed to av_buffer_create(), not called<br>
	 * directly.<br>
	 * Original signature : <code>void av_buffer_default_free(void*, uint8_t*)</code><br>
	 * <i>native declaration : libavutil\buffer.h:50</i><br>
	 * @deprecated use the safer methods {@link #av_buffer_default_free(Pointer, ByteBuffer)} and {@link #av_buffer_default_free(Pointer, Pointer)} instead
	 */
	@Deprecated 
	void av_buffer_default_free(Pointer opaque, Pointer data);
	/**
	 * Default free callback, which calls av_free() on the buffer data.<br>
	 * This function is meant to be passed to av_buffer_create(), not called<br>
	 * directly.<br>
	 * Original signature : <code>void av_buffer_default_free(void*, uint8_t*)</code><br>
	 * <i>native declaration : libavutil\buffer.h:50</i>
	 */
	void av_buffer_default_free(Pointer opaque, ByteBuffer data);
	/**
	 * Create a new reference to an AVBuffer.<br>
	 * @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on<br>
	 * failure.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_ref(AVBufferRef*)</code><br>
	 * <i>native declaration : libavutil\buffer.h:57</i>
	 */
	AVBufferRef av_buffer_ref(AVBufferRef buf);
	/**
	 * Free a given reference and automatically free the buffer if there are no more<br>
	 * references to it.<br>
	 * @param buf the reference to be freed. The pointer is set to NULL on return.<br>
	 * Original signature : <code>void av_buffer_unref(AVBufferRef**)</code><br>
	 * <i>native declaration : libavutil\buffer.h:64</i><br>
	 * @deprecated use the safer method {@link #av_buffer_unref(org.ffmpeg.avutil55.AVBufferRef.ByReference[])} instead
	 */
	@Deprecated 
	void av_buffer_unref(PointerByReference buf);
	/**
	 * Free a given reference and automatically free the buffer if there are no more<br>
	 * references to it.<br>
	 * @param buf the reference to be freed. The pointer is set to NULL on return.<br>
	 * Original signature : <code>void av_buffer_unref(AVBufferRef**)</code><br>
	 * <i>native declaration : libavutil\buffer.h:64</i>
	 */
	void av_buffer_unref(AVBufferRef.ByReference buf[]);
	/**
	 * @return 1 if the caller may write to the data referred to by buf (which is<br>
	 * true if and only if buf is the only reference to the underlying AVBuffer).<br>
	 * Return 0 otherwise.<br>
	 * A positive answer is valid until av_buffer_ref() is called on buf.<br>
	 * Original signature : <code>int av_buffer_is_writable(const AVBufferRef*)</code><br>
	 * <i>native declaration : libavutil\buffer.h:72</i>
	 */
	int av_buffer_is_writable(AVBufferRef buf);
	/**
	 * @return the opaque parameter set by av_buffer_create.<br>
	 * Original signature : <code>void* av_buffer_get_opaque(const AVBufferRef*)</code><br>
	 * <i>native declaration : libavutil\buffer.h:77</i>
	 */
	Pointer av_buffer_get_opaque(AVBufferRef buf);
	/**
	 * Original signature : <code>int av_buffer_get_ref_count(const AVBufferRef*)</code><br>
	 * <i>native declaration : libavutil\buffer.h:79</i>
	 */
	int av_buffer_get_ref_count(AVBufferRef buf);
	/**
	 * Create a writable reference from a given buffer reference, avoiding data copy<br>
	 * if possible.<br>
	 * @param buf buffer reference to make writable. On success, buf is either left<br>
	 *            untouched, or it is unreferenced and a new writable AVBufferRef is<br>
	 *            written in its place. On failure, buf is left untouched.<br>
	 * @return 0 on success, a negative AVERROR on failure.<br>
	 * Original signature : <code>int av_buffer_make_writable(AVBufferRef**)</code><br>
	 * <i>native declaration : libavutil\buffer.h:89</i><br>
	 * @deprecated use the safer method {@link #av_buffer_make_writable(org.ffmpeg.avutil55.AVBufferRef.ByReference[])} instead
	 */
	@Deprecated 
	int av_buffer_make_writable(PointerByReference buf);
	/**
	 * Create a writable reference from a given buffer reference, avoiding data copy<br>
	 * if possible.<br>
	 * @param buf buffer reference to make writable. On success, buf is either left<br>
	 *            untouched, or it is unreferenced and a new writable AVBufferRef is<br>
	 *            written in its place. On failure, buf is left untouched.<br>
	 * @return 0 on success, a negative AVERROR on failure.<br>
	 * Original signature : <code>int av_buffer_make_writable(AVBufferRef**)</code><br>
	 * <i>native declaration : libavutil\buffer.h:89</i>
	 */
	int av_buffer_make_writable(AVBufferRef.ByReference buf[]);
	/**
	 * Reallocate a given buffer.<br>
	 * @param buf  a buffer reference to reallocate. On success, buf will be<br>
	 *             unreferenced and a new reference with the required size will be<br>
	 *             written in its place. On failure buf will be left untouched. *buf<br>
	 *             may be NULL, then a new buffer is allocated.<br>
	 * @param size required new buffer size.<br>
	 * @return 0 on success, a negative AVERROR on failure.<br>
	 * @note the buffer is actually reallocated with av_realloc() only if it was<br>
	 * initially allocated through av_buffer_realloc(NULL) and there is only one<br>
	 * reference to it (i.e. the one passed to this function). In all other cases<br>
	 * a new buffer is allocated and the data is copied.<br>
	 * Original signature : <code>int av_buffer_realloc(AVBufferRef**, int)</code><br>
	 * <i>native declaration : libavutil\buffer.h:104</i><br>
	 * @deprecated use the safer method {@link #av_buffer_realloc(org.ffmpeg.avutil55.AVBufferRef.ByReference[], int)} instead
	 */
	@Deprecated 
	int av_buffer_realloc(PointerByReference buf, int size);
	/**
	 * Reallocate a given buffer.<br>
	 * @param buf  a buffer reference to reallocate. On success, buf will be<br>
	 *             unreferenced and a new reference with the required size will be<br>
	 *             written in its place. On failure buf will be left untouched. *buf<br>
	 *             may be NULL, then a new buffer is allocated.<br>
	 * @param size required new buffer size.<br>
	 * @return 0 on success, a negative AVERROR on failure.<br>
	 * @note the buffer is actually reallocated with av_realloc() only if it was<br>
	 * initially allocated through av_buffer_realloc(NULL) and there is only one<br>
	 * reference to it (i.e. the one passed to this function). In all other cases<br>
	 * a new buffer is allocated and the data is copied.<br>
	 * Original signature : <code>int av_buffer_realloc(AVBufferRef**, int)</code><br>
	 * <i>native declaration : libavutil\buffer.h:104</i>
	 */
	int av_buffer_realloc(AVBufferRef.ByReference buf[], int size);
	/**
	 * Allocate and initialize a buffer pool.<br>
	 * @param size size of each buffer in this pool<br>
	 * @param alloc a function that will be used to allocate new buffers when the<br>
	 * pool is empty. May be NULL, then the default allocator will be used<br>
	 * (av_buffer_alloc()).<br>
	 * @return newly created buffer pool on success, NULL on error.<br>
	 * Original signature : <code>AVBufferPool* av_buffer_pool_init(int, av_buffer_pool_init_alloc_callback*)</code><br>
	 * <i>native declaration : libavutil\buffer.h:122</i>
	 */
	AVBufferPool av_buffer_pool_init(int size, av_buffer_pool_init_alloc_callback alloc);
	/**
	 * Allocate and initialize a buffer pool with a more complex allocator.<br>
	 * @param size size of each buffer in this pool<br>
	 * @param opaque arbitrary user data used by the allocator<br>
	 * @param alloc a function that will be used to allocate new buffers when the<br>
	 *              pool is empty.<br>
	 * @param pool_free a function that will be called immediately before the pool<br>
	 *                  is freed. I.e. after av_buffer_pool_uninit() is called<br>
	 *                  by the caller and all the frames are returned to the pool<br>
	 *                  and freed. It is intended to uninitialize the user opaque<br>
	 *                  data.<br>
	 * @return newly created buffer pool on success, NULL on error.<br>
	 * Original signature : <code>AVBufferPool* av_buffer_pool_init2(int, void*, av_buffer_pool_init2_alloc_callback*, av_buffer_pool_init2_pool_free_callback*)</code><br>
	 * <i>native declaration : libavutil\buffer.h:137</i>
	 */
	AVBufferPool av_buffer_pool_init2(int size, Pointer opaque, av_buffer_pool_init2_alloc_callback alloc, av_buffer_pool_init2_pool_free_callback pool_free);
	/**
	 * Mark the pool as being available for freeing. It will actually be freed only<br>
	 * once all the allocated buffers associated with the pool are released. Thus it<br>
	 * is safe to call this function while some of the allocated buffers are still<br>
	 * in use.<br>
	 * @param pool pointer to the pool to be freed. It will be set to NULL.<br>
	 * Original signature : <code>void av_buffer_pool_uninit(AVBufferPool**)</code><br>
	 * <i>native declaration : libavutil\buffer.h:146</i><br>
	 * @deprecated use the safer method {@link #av_buffer_pool_uninit(org.ffmpeg.avutil55.AVBufferPool.ByReference[])} instead
	 */
	@Deprecated 
	void av_buffer_pool_uninit(PointerByReference pool);
	/**
	 * Mark the pool as being available for freeing. It will actually be freed only<br>
	 * once all the allocated buffers associated with the pool are released. Thus it<br>
	 * is safe to call this function while some of the allocated buffers are still<br>
	 * in use.<br>
	 * @param pool pointer to the pool to be freed. It will be set to NULL.<br>
	 * Original signature : <code>void av_buffer_pool_uninit(AVBufferPool**)</code><br>
	 * <i>native declaration : libavutil\buffer.h:146</i>
	 */
	void av_buffer_pool_uninit(AVBufferPool.ByReference pool[]);
	/**
	 * Allocate a new AVBuffer, reusing an old buffer from the pool when available.<br>
	 * This function may be called simultaneously from multiple threads.<br>
	 * @return a reference to the new buffer on success, NULL on error.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_pool_get(AVBufferPool*)</code><br>
	 * <i>native declaration : libavutil\buffer.h:153</i>
	 */
	AVBufferRef av_buffer_pool_get(AVBufferPool pool);
	/**
	 * Return the name of sample_fmt, or NULL if sample_fmt is not<br>
	 * recognized.<br>
	 * Original signature : <code>char* av_get_sample_fmt_name(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:50</i>
	 */
	String av_get_sample_fmt_name(int sample_fmt);
	/**
	 * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE<br>
	 * on error.<br>
	 * Original signature : <code>AVSampleFormat av_get_sample_fmt(const char*)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:56</i><br>
	 * @deprecated use the safer methods {@link #av_get_sample_fmt(String)} and {@link #av_get_sample_fmt(Pointer)} instead
	 */
	@Deprecated 
	int av_get_sample_fmt(Pointer name);
	/**
	 * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE<br>
	 * on error.<br>
	 * Original signature : <code>AVSampleFormat av_get_sample_fmt(const char*)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:56</i>
	 */
	int av_get_sample_fmt(String name);
	/**
	 * Return the planar<->packed alternative form of the given sample format, or<br>
	 * AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the<br>
	 * requested planar/packed format, the format returned is the same as the<br>
	 * input.<br>
	 * Original signature : <code>AVSampleFormat av_get_alt_sample_fmt(AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:64</i>
	 */
	int av_get_alt_sample_fmt(int sample_fmt, int planar);
	/**
	 * Get the packed alternative form of the given sample format.<br>
	 * If the passed sample_fmt is already in packed format, the format returned is<br>
	 * the same as the input.<br>
	 * @return  the packed alternative form of the given sample format or<br>
	 * AV_SAMPLE_FMT_NONE on error.<br>
	 * Original signature : <code>AVSampleFormat av_get_packed_sample_fmt(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:73</i>
	 */
	int av_get_packed_sample_fmt(int sample_fmt);
	/**
	 * Get the planar alternative form of the given sample format.<br>
	 * If the passed sample_fmt is already in planar format, the format returned is<br>
	 * the same as the input.<br>
	 * @return  the planar alternative form of the given sample format or<br>
	 * AV_SAMPLE_FMT_NONE on error.<br>
	 * Original signature : <code>AVSampleFormat av_get_planar_sample_fmt(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:82</i>
	 */
	int av_get_planar_sample_fmt(int sample_fmt);
	/**
	 * Generate a string corresponding to the sample format with<br>
	 * sample_fmt, or a header if sample_fmt is negative.<br>
	 * @param buf the buffer where to write the string<br>
	 * @param buf_size the size of buf<br>
	 * @param sample_fmt the number of the sample format to print the<br>
	 * corresponding info string, or a negative value to print the<br>
	 * corresponding header.<br>
	 * @return the pointer to the filled buffer or NULL if sample_fmt is<br>
	 * unknown or in case of other errors<br>
	 * Original signature : <code>char* av_get_sample_fmt_string(char*, int, AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:95</i><br>
	 * @deprecated use the safer methods {@link #av_get_sample_fmt_string(ByteBuffer, int, int)} and {@link #av_get_sample_fmt_string(Pointer, int, int)} instead
	 */
	@Deprecated 
	Pointer av_get_sample_fmt_string(Pointer buf, int buf_size, int sample_fmt);
	/**
	 * Generate a string corresponding to the sample format with<br>
	 * sample_fmt, or a header if sample_fmt is negative.<br>
	 * @param buf the buffer where to write the string<br>
	 * @param buf_size the size of buf<br>
	 * @param sample_fmt the number of the sample format to print the<br>
	 * corresponding info string, or a negative value to print the<br>
	 * corresponding header.<br>
	 * @return the pointer to the filled buffer or NULL if sample_fmt is<br>
	 * unknown or in case of other errors<br>
	 * Original signature : <code>char* av_get_sample_fmt_string(char*, int, AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:95</i>
	 */
	Pointer av_get_sample_fmt_string(ByteBuffer buf, int buf_size, int sample_fmt);
	/**
	 * Return number of bytes per sample.<br>
	 * @param sample_fmt the sample format<br>
	 * @return number of bytes per sample or zero if unknown for the given<br>
	 * sample format<br>
	 * Original signature : <code>int av_get_bytes_per_sample(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:103</i>
	 */
	int av_get_bytes_per_sample(int sample_fmt);
	/**
	 * Check if the sample format is planar.<br>
	 * @param sample_fmt the sample format to inspect<br>
	 * @return 1 if the sample format is planar, 0 if it is interleaved<br>
	 * Original signature : <code>int av_sample_fmt_is_planar(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:110</i>
	 */
	int av_sample_fmt_is_planar(int sample_fmt);
	/**
	 * Get the required buffer size for the given audio parameters.<br>
	 * @param[out] linesize calculated linesize, may be NULL<br>
	 * @param nb_channels   the number of channels<br>
	 * @param nb_samples    the number of samples in a single channel<br>
	 * @param sample_fmt    the sample format<br>
	 * @param align         buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return              required buffer size, or negative error code on failure<br>
	 * Original signature : <code>int av_samples_get_buffer_size(int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:121</i><br>
	 * @deprecated use the safer methods {@link #av_samples_get_buffer_size(IntBuffer, int, int, int, int)} and {@link #av_samples_get_buffer_size(IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_get_buffer_size(IntByReference linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Get the required buffer size for the given audio parameters.<br>
	 * @param[out] linesize calculated linesize, may be NULL<br>
	 * @param nb_channels   the number of channels<br>
	 * @param nb_samples    the number of samples in a single channel<br>
	 * @param sample_fmt    the sample format<br>
	 * @param align         buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return              required buffer size, or negative error code on failure<br>
	 * Original signature : <code>int av_samples_get_buffer_size(int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:121</i>
	 */
	int av_samples_get_buffer_size(IntBuffer linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Fill plane data pointers and linesize for samples with sample<br>
	 * format sample_fmt.<br>
	 * The audio_data array is filled with the pointers to the samples data planes:<br>
	 * for planar, set the start point of each channel's data within the buffer,<br>
	 * for packed, set the start point of the entire buffer only.<br>
	 * The value pointed to by linesize is set to the aligned size of each<br>
	 * channel's data buffer for planar layout, or to the aligned size of the<br>
	 * buffer for all channels for packed layout.<br>
	 * The buffer in buf must be big enough to contain all the samples<br>
	 * (use av_samples_get_buffer_size() to compute its minimum size),<br>
	 * otherwise the audio_data pointers will point to invalid data.<br>
	 * @see enum AVSampleFormat<br>
	 * The documentation for AVSampleFormat describes the data layout.<br>
	 * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    calculated linesize, may be NULL<br>
	 * @param buf              the pointer to a buffer containing the samples<br>
	 * @param nb_channels      the number of channels<br>
	 * @param nb_samples       the number of samples in a single channel<br>
	 * @param sample_fmt       the sample format<br>
	 * @param align            buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return                 >=0 on success or a negative error code on failure<br>
	 * @todo return minimum size in bytes required for the buffer in case<br>
	 * of success at the next bump<br>
	 * Original signature : <code>int av_samples_fill_arrays(uint8_t**, int*, const uint8_t*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:148</i><br>
	 * @deprecated use the safer methods {@link #av_samples_fill_arrays(PointerByReference, IntBuffer, byte[], int, int, int, int)} and {@link #av_samples_fill_arrays(PointerByReference, IntByReference, Pointer, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_fill_arrays(PointerByReference audio_data, IntByReference linesize, Pointer buf, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Fill plane data pointers and linesize for samples with sample<br>
	 * format sample_fmt.<br>
	 * The audio_data array is filled with the pointers to the samples data planes:<br>
	 * for planar, set the start point of each channel's data within the buffer,<br>
	 * for packed, set the start point of the entire buffer only.<br>
	 * The value pointed to by linesize is set to the aligned size of each<br>
	 * channel's data buffer for planar layout, or to the aligned size of the<br>
	 * buffer for all channels for packed layout.<br>
	 * The buffer in buf must be big enough to contain all the samples<br>
	 * (use av_samples_get_buffer_size() to compute its minimum size),<br>
	 * otherwise the audio_data pointers will point to invalid data.<br>
	 * @see enum AVSampleFormat<br>
	 * The documentation for AVSampleFormat describes the data layout.<br>
	 * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    calculated linesize, may be NULL<br>
	 * @param buf              the pointer to a buffer containing the samples<br>
	 * @param nb_channels      the number of channels<br>
	 * @param nb_samples       the number of samples in a single channel<br>
	 * @param sample_fmt       the sample format<br>
	 * @param align            buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return                 >=0 on success or a negative error code on failure<br>
	 * @todo return minimum size in bytes required for the buffer in case<br>
	 * of success at the next bump<br>
	 * Original signature : <code>int av_samples_fill_arrays(uint8_t**, int*, const uint8_t*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:148</i>
	 */
	int av_samples_fill_arrays(PointerByReference audio_data, IntBuffer linesize, byte buf[], int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Allocate a samples buffer for nb_samples samples, and fill data pointers and<br>
	 * linesize accordingly.<br>
	 * The allocated samples buffer can be freed by using av_freep(&audio_data[0])<br>
	 * Allocated data will be initialized to silence.<br>
	 * @see enum AVSampleFormat<br>
	 * The documentation for AVSampleFormat describes the data layout.<br>
	 * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    aligned size for audio buffer(s), may be NULL<br>
	 * @param nb_channels      number of audio channels<br>
	 * @param nb_samples       number of samples per channel<br>
	 * @param align            buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return                 >=0 on success or a negative error code on failure<br>
	 * @todo return the size of the allocated buffer in case of success at the next bump<br>
	 * @see av_samples_fill_arrays()<br>
	 * @see av_samples_alloc_array_and_samples()<br>
	 * Original signature : <code>int av_samples_alloc(uint8_t**, int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:167</i><br>
	 * @deprecated use the safer methods {@link #av_samples_alloc(PointerByReference, IntBuffer, int, int, int, int)} and {@link #av_samples_alloc(PointerByReference, IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_alloc(PointerByReference audio_data, IntByReference linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Allocate a samples buffer for nb_samples samples, and fill data pointers and<br>
	 * linesize accordingly.<br>
	 * The allocated samples buffer can be freed by using av_freep(&audio_data[0])<br>
	 * Allocated data will be initialized to silence.<br>
	 * @see enum AVSampleFormat<br>
	 * The documentation for AVSampleFormat describes the data layout.<br>
	 * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    aligned size for audio buffer(s), may be NULL<br>
	 * @param nb_channels      number of audio channels<br>
	 * @param nb_samples       number of samples per channel<br>
	 * @param align            buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return                 >=0 on success or a negative error code on failure<br>
	 * @todo return the size of the allocated buffer in case of success at the next bump<br>
	 * @see av_samples_fill_arrays()<br>
	 * @see av_samples_alloc_array_and_samples()<br>
	 * Original signature : <code>int av_samples_alloc(uint8_t**, int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:167</i>
	 */
	int av_samples_alloc(PointerByReference audio_data, IntBuffer linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Allocate a data pointers array, samples buffer for nb_samples<br>
	 * samples, and fill data pointers and linesize accordingly.<br>
	 * This is the same as av_samples_alloc(), but also allocates the data<br>
	 * pointers array.<br>
	 * @see av_samples_alloc()<br>
	 * Original signature : <code>int av_samples_alloc_array_and_samples(uint8_t***, int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:176</i><br>
	 * @deprecated use the safer methods {@link #av_samples_alloc_array_and_samples(PointerByReference, IntBuffer, int, int, int, int)} and {@link #av_samples_alloc_array_and_samples(PointerByReference, IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_alloc_array_and_samples(PointerByReference audio_data, IntByReference linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Allocate a data pointers array, samples buffer for nb_samples<br>
	 * samples, and fill data pointers and linesize accordingly.<br>
	 * This is the same as av_samples_alloc(), but also allocates the data<br>
	 * pointers array.<br>
	 * @see av_samples_alloc()<br>
	 * Original signature : <code>int av_samples_alloc_array_and_samples(uint8_t***, int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:176</i>
	 */
	int av_samples_alloc_array_and_samples(PointerByReference audio_data, IntBuffer linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Copy samples from src to dst.<br>
	 * @param dst destination array of pointers to data planes<br>
	 * @param src source array of pointers to data planes<br>
	 * @param dst_offset offset in samples at which the data will be written to dst<br>
	 * @param src_offset offset in samples at which the data will be read from src<br>
	 * @param nb_samples number of samples to be copied<br>
	 * @param nb_channels number of audio channels<br>
	 * @param sample_fmt audio sample format<br>
	 * Original signature : <code>int av_samples_copy(uint8_t**, const uint8_t**, int, int, int, int, AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:188</i><br>
	 * @deprecated use the safer methods {@link #av_samples_copy(PointerByReference, byte[][], int, int, int, int, int)} and {@link #av_samples_copy(PointerByReference, PointerByReference, int, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_copy(PointerByReference dst, PointerByReference src, int dst_offset, int src_offset, int nb_samples, int nb_channels, int sample_fmt);
	/**
	 * Copy samples from src to dst.<br>
	 * @param dst destination array of pointers to data planes<br>
	 * @param src source array of pointers to data planes<br>
	 * @param dst_offset offset in samples at which the data will be written to dst<br>
	 * @param src_offset offset in samples at which the data will be read from src<br>
	 * @param nb_samples number of samples to be copied<br>
	 * @param nb_channels number of audio channels<br>
	 * @param sample_fmt audio sample format<br>
	 * Original signature : <code>int av_samples_copy(uint8_t**, const uint8_t**, int, int, int, int, AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:188</i>
	 */
	int av_samples_copy(PointerByReference dst, byte[] src[], int dst_offset, int src_offset, int nb_samples, int nb_channels, int sample_fmt);
	/**
	 * Fill an audio buffer with silence.<br>
	 * @param audio_data  array of pointers to data planes<br>
	 * @param offset      offset in samples at which to start filling<br>
	 * @param nb_samples  number of samples to fill<br>
	 * @param nb_channels number of audio channels<br>
	 * @param sample_fmt  audio sample format<br>
	 * Original signature : <code>int av_samples_set_silence(uint8_t**, int, int, int, AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil\samplefmt.h:198</i>
	 */
	int av_samples_set_silence(PointerByReference audio_data, int offset, int nb_samples, int nb_channels, int sample_fmt);
	/**
	 * Accessors for some AVFrame fields. These used to be provided for ABI<br>
	 * compatibility, and do not need to be used anymore.<br>
	 * Original signature : <code>int64_t av_frame_get_best_effort_timestamp(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:138</i>
	 */
	long av_frame_get_best_effort_timestamp(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_best_effort_timestamp(AVFrame*, int64_t)</code><br>
	 * <i>native declaration : libavutil\frame.h:140</i>
	 */
	void av_frame_set_best_effort_timestamp(AVFrame frame, long val);
	/**
	 * Original signature : <code>int64_t av_frame_get_pkt_duration(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:142</i>
	 */
	long av_frame_get_pkt_duration(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_pkt_duration(AVFrame*, int64_t)</code><br>
	 * <i>native declaration : libavutil\frame.h:144</i>
	 */
	void av_frame_set_pkt_duration(AVFrame frame, long val);
	/**
	 * Original signature : <code>int64_t av_frame_get_pkt_pos(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:146</i>
	 */
	long av_frame_get_pkt_pos(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_pkt_pos(AVFrame*, int64_t)</code><br>
	 * <i>native declaration : libavutil\frame.h:148</i>
	 */
	void av_frame_set_pkt_pos(AVFrame frame, long val);
	/**
	 * Original signature : <code>int64_t av_frame_get_channel_layout(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:150</i>
	 */
	long av_frame_get_channel_layout(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_channel_layout(AVFrame*, int64_t)</code><br>
	 * <i>native declaration : libavutil\frame.h:152</i>
	 */
	void av_frame_set_channel_layout(AVFrame frame, long val);
	/**
	 * Original signature : <code>int av_frame_get_channels(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:154</i>
	 */
	int av_frame_get_channels(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_channels(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil\frame.h:156</i>
	 */
	void av_frame_set_channels(AVFrame frame, int val);
	/**
	 * Original signature : <code>int av_frame_get_sample_rate(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:158</i>
	 */
	int av_frame_get_sample_rate(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_sample_rate(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil\frame.h:160</i>
	 */
	void av_frame_set_sample_rate(AVFrame frame, int val);
	/**
	 * Original signature : <code>AVDictionary* av_frame_get_metadata(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:162</i>
	 */
	AVDictionary av_frame_get_metadata(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_metadata(AVFrame*, AVDictionary*)</code><br>
	 * <i>native declaration : libavutil\frame.h:164</i>
	 */
	void av_frame_set_metadata(AVFrame frame, AVDictionary val);
	/**
	 * Original signature : <code>int av_frame_get_decode_error_flags(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:166</i>
	 */
	int av_frame_get_decode_error_flags(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_decode_error_flags(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil\frame.h:168</i>
	 */
	void av_frame_set_decode_error_flags(AVFrame frame, int val);
	/**
	 * Original signature : <code>int av_frame_get_pkt_size(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:170</i>
	 */
	int av_frame_get_pkt_size(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_pkt_size(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil\frame.h:172</i>
	 */
	void av_frame_set_pkt_size(AVFrame frame, int val);
	/**
	 * Original signature : <code>AVDictionary** avpriv_frame_get_metadatap(AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:174</i>
	 */
	AVDictionary.ByReference[] avpriv_frame_get_metadatap(AVFrame frame);
	/**
	 * Original signature : <code>int8_t* av_frame_get_qp_table(AVFrame*, int*, int*)</code><br>
	 * <i>native declaration : libavutil\frame.h:176</i><br>
	 * @deprecated use the safer methods {@link #av_frame_get_qp_table(org.ffmpeg.avutil55.AVFrame, IntBuffer, IntBuffer)} and {@link #av_frame_get_qp_table(org.ffmpeg.avutil55.AVFrame, IntByReference, IntByReference)} instead
	 */
	@Deprecated 
	Pointer av_frame_get_qp_table(AVFrame f, IntByReference stride, IntByReference type);
	/**
	 * Original signature : <code>int8_t* av_frame_get_qp_table(AVFrame*, int*, int*)</code><br>
	 * <i>native declaration : libavutil\frame.h:176</i>
	 */
	Pointer av_frame_get_qp_table(AVFrame f, IntBuffer stride, IntBuffer type);
	/**
	 * Original signature : <code>int av_frame_set_qp_table(AVFrame*, AVBufferRef*, int, int)</code><br>
	 * <i>native declaration : libavutil\frame.h:178</i>
	 */
	int av_frame_set_qp_table(AVFrame f, AVBufferRef buf, int stride, int type);
	/**
	 * Original signature : <code>AVColorSpace av_frame_get_colorspace(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:180</i>
	 */
	int av_frame_get_colorspace(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_colorspace(AVFrame*, AVColorSpace)</code><br>
	 * <i>native declaration : libavutil\frame.h:182</i>
	 */
	void av_frame_set_colorspace(AVFrame frame, int val);
	/**
	 * Original signature : <code>AVColorRange av_frame_get_color_range(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:184</i>
	 */
	int av_frame_get_color_range(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_color_range(AVFrame*, AVColorRange)</code><br>
	 * <i>native declaration : libavutil\frame.h:186</i>
	 */
	void av_frame_set_color_range(AVFrame frame, int val);
	/**
	 * Get the name of a colorspace.<br>
	 * @return a static string identifying the colorspace; can be NULL.<br>
	 * Original signature : <code>char* av_get_colorspace_name(AVColorSpace)</code><br>
	 * <i>native declaration : libavutil\frame.h:192</i>
	 */
	String av_get_colorspace_name(int val);
	/**
	 * Allocate an AVFrame and set its fields to default values.  The resulting<br>
	 * struct must be freed using av_frame_free().<br>
	 * @return An AVFrame filled with default values or NULL on failure.<br>
	 * @note this only allocates the AVFrame itself, not the data buffers. Those<br>
	 * must be allocated through other means, e.g. with av_frame_get_buffer() or<br>
	 * manually.<br>
	 * Original signature : <code>AVFrame* av_frame_alloc()</code><br>
	 * <i>native declaration : libavutil\frame.h:202</i>
	 */
	AVFrame av_frame_alloc();
	/**
	 * Free the frame and any dynamically allocated objects in it,<br>
	 * e.g. extended_data. If the frame is reference counted, it will be<br>
	 * unreferenced first.<br>
	 * @param frame frame to be freed. The pointer will be set to NULL.<br>
	 * Original signature : <code>void av_frame_free(AVFrame**)</code><br>
	 * <i>native declaration : libavutil\frame.h:210</i><br>
	 *  use the safer method {@link #av_frame_free(org.ffmpeg.avutil55.AVFrame.ByReference[])} instead
	 */
	void av_frame_free(PointerByReference frame);
	/**
	 * Free the frame and any dynamically allocated objects in it,<br>
	 * e.g. extended_data. If the frame is reference counted, it will be<br>
	 * unreferenced first.<br>
	 * @param frame frame to be freed. The pointer will be set to NULL.<br>
	 * Original signature : <code>void av_frame_free(AVFrame**)</code><br>
	 * <i>native declaration : libavutil\frame.h:210</i>
	 */
	void av_frame_free(AVFrame.ByReference frame[]);
	/**
	 * Set up a new reference to the data described by the source frame.<br>
	 * Copy frame properties from src to dst and create a new reference for each<br>
	 * AVBufferRef from src.<br>
	 * If src is not reference counted, new buffers are allocated and the data is<br>
	 * copied.<br>
	 * @warning: dst MUST have been either unreferenced with av_frame_unref(dst),<br>
	 *           or newly allocated with av_frame_alloc() before calling this<br>
	 *           function, or undefined behavior will occur.<br>
	 * @return 0 on success, a negative AVERROR on error<br>
	 * Original signature : <code>int av_frame_ref(AVFrame*, const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:223</i>
	 */
	int av_frame_ref(AVFrame dst, AVFrame src);
	/**
	 * Create a new frame that references the same data as src.<br>
	 * This is a shortcut for av_frame_alloc()+av_frame_ref().<br>
	 * @return newly created AVFrame on success, NULL on error.<br>
	 * Original signature : <code>AVFrame* av_frame_clone(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:230</i>
	 */
	AVFrame av_frame_clone(AVFrame src);
	/**
	 * Unreference all the buffers referenced by frame and reset the frame fields.<br>
	 * Original signature : <code>void av_frame_unref(AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:235</i>
	 */
	void av_frame_unref(AVFrame frame);
	/**
	 * Move everything contained in src to dst and reset src.<br>
	 * @warning: dst is not unreferenced, but directly overwritten without reading<br>
	 *           or deallocating its contents. Call av_frame_unref(dst) manually<br>
	 *           before calling this function to ensure that no memory is leaked.<br>
	 * Original signature : <code>void av_frame_move_ref(AVFrame*, AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:243</i>
	 */
	void av_frame_move_ref(AVFrame dst, AVFrame src);
	/**
	 * Allocate new buffer(s) for audio or video data.<br>
	 * The following fields must be set on frame before calling this function:<br>
	 * - format (pixel format for video, sample format for audio)<br>
	 * - width and height for video<br>
	 * - nb_samples and channel_layout for audio<br>
	 * This function will fill AVFrame.data and AVFrame.buf arrays and, if<br>
	 * necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.<br>
	 * For planar formats, one buffer will be allocated for each plane.<br>
	 * @warning: if frame already has been allocated, calling this function will<br>
	 *           leak memory. In addition, undefined behavior can occur in certain<br>
	 *           cases.<br>
	 * @param frame frame in which to store the new buffers.<br>
	 * @param align required buffer size alignment<br>
	 * @return 0 on success, a negative AVERROR on error.<br>
	 * Original signature : <code>int av_frame_get_buffer(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil\frame.h:261</i>
	 */
	int av_frame_get_buffer(AVFrame frame, int align);
	/**
	 * Check if the frame data is writable.<br>
	 * @return A positive value if the frame data is writable (which is true if and<br>
	 * only if each of the underlying buffers has only one reference, namely the one<br>
	 * stored in this frame). Return 0 otherwise.<br>
	 * If 1 is returned the answer is valid until av_buffer_ref() is called on any<br>
	 * of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).<br>
	 * @see av_frame_make_writable(), av_buffer_is_writable()<br>
	 * Original signature : <code>int av_frame_is_writable(AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:272</i>
	 */
	int av_frame_is_writable(AVFrame frame);
	/**
	 * Ensure that the frame data is writable, avoiding data copy if possible.<br>
	 * Do nothing if the frame is writable, allocate new buffers and copy the data<br>
	 * if it is not.<br>
	 * @return 0 on success, a negative AVERROR on error.<br>
	 * @see av_frame_is_writable(), av_buffer_is_writable(),<br>
	 * av_buffer_make_writable()<br>
	 * Original signature : <code>int av_frame_make_writable(AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:282</i>
	 */
	int av_frame_make_writable(AVFrame frame);
	/**
	 * Copy the frame data from src to dst.<br>
	 * This function does not allocate anything, dst must be already initialized and<br>
	 * allocated with the same parameters as src.<br>
	 * This function only copies the frame data (i.e. the contents of the data /<br>
	 * extended data arrays), not any other properties.<br>
	 * @return >= 0 on success, a negative AVERROR on error.<br>
	 * Original signature : <code>int av_frame_copy(AVFrame*, const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:292</i>
	 */
	int av_frame_copy(AVFrame dst, AVFrame src);
	/**
	 * Copy only "metadata" fields from src to dst.<br>
	 * Metadata for the purpose of this function are those fields that do not affect<br>
	 * the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample<br>
	 * aspect ratio (for video), but not width/height or channel layout.<br>
	 * Side data is also copied.<br>
	 * Original signature : <code>int av_frame_copy_props(AVFrame*, const AVFrame*)</code><br>
	 * <i>native declaration : libavutil\frame.h:301</i>
	 */
	int av_frame_copy_props(AVFrame dst, AVFrame src);
	/**
	 * Get the buffer reference a given data plane is stored in.<br>
	 * @param plane index of the data plane of interest in frame->extended_data.<br>
	 * @return the buffer reference that contains the plane or NULL if the input<br>
	 * frame is not valid.<br>
	 * Original signature : <code>AVBufferRef* av_frame_get_plane_buffer(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil\frame.h:309</i>
	 */
	AVBufferRef av_frame_get_plane_buffer(AVFrame frame, int plane);
	/**
	 * Add a new side data to a frame.<br>
	 * @param frame a frame to which the side data should be added<br>
	 * @param type type of the added side data<br>
	 * @param size size of the side data<br>
	 * @return newly added side data on success, NULL on error<br>
	 * Original signature : <code>AVFrameSideData* av_frame_new_side_data(AVFrame*, AVFrameSideDataType, int)</code><br>
	 * <i>native declaration : libavutil\frame.h:318</i>
	 */
	AVFrameSideData av_frame_new_side_data(AVFrame frame, int type, int size);
	/**
	 * @return a pointer to the side data of a given type on success, NULL if there<br>
	 * is no side data with such type in this frame.<br>
	 * Original signature : <code>AVFrameSideData* av_frame_get_side_data(const AVFrame*, AVFrameSideDataType)</code><br>
	 * <i>native declaration : libavutil\frame.h:324</i>
	 */
	AVFrameSideData av_frame_get_side_data(AVFrame frame, int type);
	/**
	 * If side data of the supplied type exists in the frame, free it and remove it<br>
	 * from the frame.<br>
	 * Original signature : <code>void av_frame_remove_side_data(AVFrame*, AVFrameSideDataType)</code><br>
	 * <i>native declaration : libavutil\frame.h:330</i>
	 */
	void av_frame_remove_side_data(AVFrame frame, int type);
	/**
	 * @return a string identifying the side data type<br>
	 * Original signature : <code>char* av_frame_side_data_name(AVFrameSideDataType)</code><br>
	 * <i>native declaration : libavutil\frame.h:335</i>
	 */
	String av_frame_side_data_name(int type);
	/**
	 * Show the obj options.<br>
	 * @param req_flags requested flags for the options to show. Show only the<br>
	 * options for which it is opt->flags & req_flags.<br>
	 * @param rej_flags rejected flags for the options to show. Show only the<br>
	 * options for which it is !(opt->flags & req_flags).<br>
	 * @param av_log_obj log context to use for showing the options<br>
	 * Original signature : <code>int av_opt_show2(void*, void*, int, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:231</i>
	 */
	int av_opt_show2(Pointer obj, Pointer av_log_obj, int req_flags, int rej_flags);
	/**
	 * Set the values of all AVOption fields to their default values.<br>
	 * @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)<br>
	 * Original signature : <code>void av_opt_set_defaults(void*)</code><br>
	 * <i>native declaration : libavutil\opt.h:237</i>
	 */
	void av_opt_set_defaults(Pointer s);
	/**
	 * Set the values of all AVOption fields to their default values. Only these<br>
	 * AVOption fields for which (opt->flags & mask) == flags will have their<br>
	 * default applied to s.<br>
	 * @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)<br>
	 * @param mask combination of AV_OPT_FLAG_*<br>
	 * @param flags combination of AV_OPT_FLAG_*<br>
	 * Original signature : <code>void av_opt_set_defaults2(void*, int, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:247</i>
	 */
	void av_opt_set_defaults2(Pointer s, int mask, int flags);
	/**
	 * Parse the key/value pairs list in opts. For each key/value pair<br>
	 * found, stores the value in the field in ctx that is named like the<br>
	 * key. ctx must be an AVClass context, storing is done using<br>
	 * AVOptions.<br>
	 * @param opts options string to parse, may be NULL<br>
	 * @param key_val_sep a 0-terminated list of characters used to<br>
	 * separate key from value<br>
	 * @param pairs_sep a 0-terminated list of characters used to separate<br>
	 * two pairs from each other<br>
	 * @return the number of successfully set key/value pairs, or a negative<br>
	 * value corresponding to an AVERROR code in case of error:<br>
	 * AVERROR(EINVAL) if opts cannot be parsed,<br>
	 * the error code issued by av_opt_set() if a key/value pair<br>
	 * cannot be set<br>
	 * Original signature : <code>int av_set_options_string(void*, const char*, const char*, const char*)</code><br>
	 * <i>native declaration : libavutil\opt.h:265</i><br>
	 * @deprecated use the safer methods {@link #av_set_options_string(Pointer, String, String, String)} and {@link #av_set_options_string(Pointer, Pointer, Pointer, Pointer)} instead
	 */
	@Deprecated 
	int av_set_options_string(Pointer ctx, Pointer opts, Pointer key_val_sep, Pointer pairs_sep);
	/**
	 * Parse the key/value pairs list in opts. For each key/value pair<br>
	 * found, stores the value in the field in ctx that is named like the<br>
	 * key. ctx must be an AVClass context, storing is done using<br>
	 * AVOptions.<br>
	 * @param opts options string to parse, may be NULL<br>
	 * @param key_val_sep a 0-terminated list of characters used to<br>
	 * separate key from value<br>
	 * @param pairs_sep a 0-terminated list of characters used to separate<br>
	 * two pairs from each other<br>
	 * @return the number of successfully set key/value pairs, or a negative<br>
	 * value corresponding to an AVERROR code in case of error:<br>
	 * AVERROR(EINVAL) if opts cannot be parsed,<br>
	 * the error code issued by av_opt_set() if a key/value pair<br>
	 * cannot be set<br>
	 * Original signature : <code>int av_set_options_string(void*, const char*, const char*, const char*)</code><br>
	 * <i>native declaration : libavutil\opt.h:265</i>
	 */
	int av_set_options_string(Pointer ctx, String opts, String key_val_sep, String pairs_sep);
	/**
	 * Parse the key-value pairs list in opts. For each key=value pair found,<br>
	 * set the value of the corresponding option in ctx.<br>
	 * @param ctx          the AVClass object to set options on<br>
	 * @param opts         the options string, key-value pairs separated by a<br>
	 *                     delimiter<br>
	 * @param shorthand    a NULL-terminated array of options names for shorthand<br>
	 *                     notation: if the first field in opts has no key part,<br>
	 *                     the key is taken from the first element of shorthand;<br>
	 *                     then again for the second, etc., until either opts is<br>
	 *                     finished, shorthand is finished or a named option is<br>
	 *                     found; after that, all options must be named<br>
	 * @param key_val_sep  a 0-terminated list of characters used to separate<br>
	 *                     key from value, for example '='<br>
	 * @param pairs_sep    a 0-terminated list of characters used to separate<br>
	 *                     two pairs from each other, for example ':' or ','<br>
	 * @return  the number of successfully set key=value pairs, or a negative<br>
	 *          value corresponding to an AVERROR code in case of error:<br>
	 *          AVERROR(EINVAL) if opts cannot be parsed,<br>
	 *          the error code issued by av_set_string3() if a key/value pair<br>
	 *          cannot be set<br>
	 * Options names must use only the following characters: a-z A-Z 0-9 - . / _<br>
	 * Separators must use characters distinct from option names and from each<br>
	 * other.<br>
	 * Original signature : <code>int av_opt_set_from_string(void*, const char*, const const char**, const char*, const char*)</code><br>
	 * <i>native declaration : libavutil\opt.h:292</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_from_string(Pointer, String, String[], String, String)} and {@link #av_opt_set_from_string(Pointer, Pointer, PointerByReference, Pointer, Pointer)} instead
	 */
	@Deprecated 
	int av_opt_set_from_string(Pointer ctx, Pointer opts, PointerByReference shorthand, Pointer key_val_sep, Pointer pairs_sep);
	/**
	 * Parse the key-value pairs list in opts. For each key=value pair found,<br>
	 * set the value of the corresponding option in ctx.<br>
	 * @param ctx          the AVClass object to set options on<br>
	 * @param opts         the options string, key-value pairs separated by a<br>
	 *                     delimiter<br>
	 * @param shorthand    a NULL-terminated array of options names for shorthand<br>
	 *                     notation: if the first field in opts has no key part,<br>
	 *                     the key is taken from the first element of shorthand;<br>
	 *                     then again for the second, etc., until either opts is<br>
	 *                     finished, shorthand is finished or a named option is<br>
	 *                     found; after that, all options must be named<br>
	 * @param key_val_sep  a 0-terminated list of characters used to separate<br>
	 *                     key from value, for example '='<br>
	 * @param pairs_sep    a 0-terminated list of characters used to separate<br>
	 *                     two pairs from each other, for example ':' or ','<br>
	 * @return  the number of successfully set key=value pairs, or a negative<br>
	 *          value corresponding to an AVERROR code in case of error:<br>
	 *          AVERROR(EINVAL) if opts cannot be parsed,<br>
	 *          the error code issued by av_set_string3() if a key/value pair<br>
	 *          cannot be set<br>
	 * Options names must use only the following characters: a-z A-Z 0-9 - . / _<br>
	 * Separators must use characters distinct from option names and from each<br>
	 * other.<br>
	 * Original signature : <code>int av_opt_set_from_string(void*, const char*, const const char**, const char*, const char*)</code><br>
	 * <i>native declaration : libavutil\opt.h:292</i>
	 */
	int av_opt_set_from_string(Pointer ctx, String opts, String shorthand[], String key_val_sep, String pairs_sep);
	/**
	 * Free all allocated objects in obj.<br>
	 * Original signature : <code>void av_opt_free(void*)</code><br>
	 * <i>native declaration : libavutil\opt.h:297</i>
	 */
	void av_opt_free(Pointer obj);
	/**
	 * Check whether a particular flag is set in a flags field.<br>
	 * @param field_name the name of the flag field option<br>
	 * @param flag_name the name of the flag to check<br>
	 * @return non-zero if the flag is set, zero if the flag isn't set,<br>
	 *         isn't of the right type, or the flags field doesn't exist.<br>
	 * Original signature : <code>int av_opt_flag_is_set(void*, const char*, const char*)</code><br>
	 * <i>native declaration : libavutil\opt.h:306</i><br>
	 * @deprecated use the safer methods {@link #av_opt_flag_is_set(Pointer, String, String)} and {@link #av_opt_flag_is_set(Pointer, Pointer, Pointer)} instead
	 */
	@Deprecated 
	int av_opt_flag_is_set(Pointer obj, Pointer field_name, Pointer flag_name);
	/**
	 * Check whether a particular flag is set in a flags field.<br>
	 * @param field_name the name of the flag field option<br>
	 * @param flag_name the name of the flag to check<br>
	 * @return non-zero if the flag is set, zero if the flag isn't set,<br>
	 *         isn't of the right type, or the flags field doesn't exist.<br>
	 * Original signature : <code>int av_opt_flag_is_set(void*, const char*, const char*)</code><br>
	 * <i>native declaration : libavutil\opt.h:306</i>
	 */
	int av_opt_flag_is_set(Pointer obj, String field_name, String flag_name);
	/**
	 * Set all the options from a given dictionary on an object.<br>
	 * @param obj a struct whose first element is a pointer to AVClass<br>
	 * @param options options to process. This dictionary will be freed and replaced<br>
	 *                by a new one containing all options not found in obj.<br>
	 *                Of course this new dictionary needs to be freed by caller<br>
	 *                with av_dict_free().<br>
	 * @return 0 on success, a negative AVERROR if some option was found in obj,<br>
	 *         but could not be set.<br>
	 * @see av_dict_copy()<br>
	 * Original signature : <code>int av_opt_set_dict(void*, AVDictionary**)</code><br>
	 * <i>native declaration : libavutil\opt.h:319</i><br>
	 * @deprecated use the safer method {@link #av_opt_set_dict(Pointer, org.ffmpeg.avutil55.AVDictionary.ByReference[])} instead
	 */
	@Deprecated 
	int av_opt_set_dict(Pointer obj, PointerByReference options);
	/**
	 * Set all the options from a given dictionary on an object.<br>
	 * @param obj a struct whose first element is a pointer to AVClass<br>
	 * @param options options to process. This dictionary will be freed and replaced<br>
	 *                by a new one containing all options not found in obj.<br>
	 *                Of course this new dictionary needs to be freed by caller<br>
	 *                with av_dict_free().<br>
	 * @return 0 on success, a negative AVERROR if some option was found in obj,<br>
	 *         but could not be set.<br>
	 * @see av_dict_copy()<br>
	 * Original signature : <code>int av_opt_set_dict(void*, AVDictionary**)</code><br>
	 * <i>native declaration : libavutil\opt.h:319</i>
	 */
	int av_opt_set_dict(Pointer obj, AVDictionary.ByReference options[]);
	/**
	 * Set all the options from a given dictionary on an object.<br>
	 * @param obj a struct whose first element is a pointer to AVClass<br>
	 * @param options options to process. This dictionary will be freed and replaced<br>
	 *                by a new one containing all options not found in obj.<br>
	 *                Of course this new dictionary needs to be freed by caller<br>
	 *                with av_dict_free().<br>
	 * @param search_flags A combination of AV_OPT_SEARCH_*.<br>
	 * @return 0 on success, a negative AVERROR if some option was found in obj,<br>
	 *         but could not be set.<br>
	 * @see av_dict_copy()<br>
	 * Original signature : <code>int av_opt_set_dict2(void*, AVDictionary**, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:333</i><br>
	 * @deprecated use the safer method {@link #av_opt_set_dict2(Pointer, org.ffmpeg.avutil55.AVDictionary.ByReference[], int)} instead
	 */
	@Deprecated 
	int av_opt_set_dict2(Pointer obj, PointerByReference options, int search_flags);
	/**
	 * Set all the options from a given dictionary on an object.<br>
	 * @param obj a struct whose first element is a pointer to AVClass<br>
	 * @param options options to process. This dictionary will be freed and replaced<br>
	 *                by a new one containing all options not found in obj.<br>
	 *                Of course this new dictionary needs to be freed by caller<br>
	 *                with av_dict_free().<br>
	 * @param search_flags A combination of AV_OPT_SEARCH_*.<br>
	 * @return 0 on success, a negative AVERROR if some option was found in obj,<br>
	 *         but could not be set.<br>
	 * @see av_dict_copy()<br>
	 * Original signature : <code>int av_opt_set_dict2(void*, AVDictionary**, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:333</i>
	 */
	int av_opt_set_dict2(Pointer obj, AVDictionary.ByReference options[], int search_flags);
	/**
	 * Extract a key-value pair from the beginning of a string.<br>
	 * @param ropts        pointer to the options string, will be updated to<br>
	 *                     point to the rest of the string (one of the pairs_sep<br>
	 *                     or the final NUL)<br>
	 * @param key_val_sep  a 0-terminated list of characters used to separate<br>
	 *                     key from value, for example '='<br>
	 * @param pairs_sep    a 0-terminated list of characters used to separate<br>
	 *                     two pairs from each other, for example ':' or ','<br>
	 * @param flags        flags; see the AV_OPT_FLAG_* values below<br>
	 * @param rkey         parsed key; must be freed using av_free()<br>
	 * @param rval         parsed value; must be freed using av_free()<br>
	 * @return  >=0 for success, or a negative value corresponding to an<br>
	 *          AVERROR code in case of error; in particular:<br>
	 *          AVERROR(EINVAL) if no key is present<br>
	 * Original signature : <code>int av_opt_get_key_value(const char**, const char*, const char*, unsigned, char**, char**)</code><br>
	 * <i>native declaration : libavutil\opt.h:351</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get_key_value(String[], String, String, int, PointerByReference, PointerByReference)} and {@link #av_opt_get_key_value(PointerByReference, Pointer, Pointer, int, PointerByReference, PointerByReference)} instead
	 */
	@Deprecated 
	int av_opt_get_key_value(PointerByReference ropts, Pointer key_val_sep, Pointer pairs_sep, int flags, PointerByReference rkey, PointerByReference rval);
	/**
	 * Extract a key-value pair from the beginning of a string.<br>
	 * @param ropts        pointer to the options string, will be updated to<br>
	 *                     point to the rest of the string (one of the pairs_sep<br>
	 *                     or the final NUL)<br>
	 * @param key_val_sep  a 0-terminated list of characters used to separate<br>
	 *                     key from value, for example '='<br>
	 * @param pairs_sep    a 0-terminated list of characters used to separate<br>
	 *                     two pairs from each other, for example ':' or ','<br>
	 * @param flags        flags; see the AV_OPT_FLAG_* values below<br>
	 * @param rkey         parsed key; must be freed using av_free()<br>
	 * @param rval         parsed value; must be freed using av_free()<br>
	 * @return  >=0 for success, or a negative value corresponding to an<br>
	 *          AVERROR code in case of error; in particular:<br>
	 *          AVERROR(EINVAL) if no key is present<br>
	 * Original signature : <code>int av_opt_get_key_value(const char**, const char*, const char*, unsigned, char**, char**)</code><br>
	 * <i>native declaration : libavutil\opt.h:351</i>
	 */
	int av_opt_get_key_value(String ropts[], String key_val_sep, String pairs_sep, int flags, PointerByReference rkey, PointerByReference rval);
	/**
	 * @defgroup opt_eval_funcs Evaluating option strings<br>
	 * @{<br>
	 * This group of functions can be used to evaluate option strings<br>
	 * and get numbers out of them. They do the same thing as av_opt_set(),<br>
	 * except the result is written into the caller-supplied pointer.<br>
	 * @param obj a struct whose first element is a pointer to AVClass.<br>
	 * @param o an option for which the string is to be evaluated.<br>
	 * @param val string to be evaluated.<br>
	 * @param *_out value of the string will be written here.<br>
	 * @return 0 on success, a negative number on failure.<br>
	 * Original signature : <code>int av_opt_eval_flags(void*, const AVOption*, const char*, int*)</code><br>
	 * <i>native declaration : libavutil\opt.h:368</i><br>
	 * @deprecated use the safer methods {@link #av_opt_eval_flags(Pointer, org.ffmpeg.avutil55.AVOption, String, IntBuffer)} and {@link #av_opt_eval_flags(Pointer, org.ffmpeg.avutil55.AVOption, Pointer, IntByReference)} instead
	 */
	@Deprecated 
	int av_opt_eval_flags(Pointer obj, AVOption o, Pointer val, IntByReference flags_out);
	/**
	 * @defgroup opt_eval_funcs Evaluating option strings<br>
	 * @{<br>
	 * This group of functions can be used to evaluate option strings<br>
	 * and get numbers out of them. They do the same thing as av_opt_set(),<br>
	 * except the result is written into the caller-supplied pointer.<br>
	 * @param obj a struct whose first element is a pointer to AVClass.<br>
	 * @param o an option for which the string is to be evaluated.<br>
	 * @param val string to be evaluated.<br>
	 * @param *_out value of the string will be written here.<br>
	 * @return 0 on success, a negative number on failure.<br>
	 * Original signature : <code>int av_opt_eval_flags(void*, const AVOption*, const char*, int*)</code><br>
	 * <i>native declaration : libavutil\opt.h:368</i>
	 */
	int av_opt_eval_flags(Pointer obj, AVOption o, String val, IntBuffer flags_out);
	/**
	 * Original signature : <code>int av_opt_eval_int(void*, const AVOption*, const char*, int*)</code><br>
	 * <i>native declaration : libavutil\opt.h:370</i><br>
	 * @deprecated use the safer methods {@link #av_opt_eval_int(Pointer, org.ffmpeg.avutil55.AVOption, String, IntBuffer)} and {@link #av_opt_eval_int(Pointer, org.ffmpeg.avutil55.AVOption, Pointer, IntByReference)} instead
	 */
	@Deprecated 
	int av_opt_eval_int(Pointer obj, AVOption o, Pointer val, IntByReference int_out);
	/**
	 * Original signature : <code>int av_opt_eval_int(void*, const AVOption*, const char*, int*)</code><br>
	 * <i>native declaration : libavutil\opt.h:370</i>
	 */
	int av_opt_eval_int(Pointer obj, AVOption o, String val, IntBuffer int_out);
	/**
	 * Original signature : <code>int av_opt_eval_int64(void*, const AVOption*, const char*, int64_t*)</code><br>
	 * <i>native declaration : libavutil\opt.h:372</i><br>
	 * @deprecated use the safer methods {@link #av_opt_eval_int64(Pointer, org.ffmpeg.avutil55.AVOption, String, LongBuffer)} and {@link #av_opt_eval_int64(Pointer, org.ffmpeg.avutil55.AVOption, Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int av_opt_eval_int64(Pointer obj, AVOption o, Pointer val, LongByReference int64_out);
	/**
	 * Original signature : <code>int av_opt_eval_int64(void*, const AVOption*, const char*, int64_t*)</code><br>
	 * <i>native declaration : libavutil\opt.h:372</i>
	 */
	int av_opt_eval_int64(Pointer obj, AVOption o, String val, LongBuffer int64_out);
	/**
	 * Original signature : <code>int av_opt_eval_float(void*, const AVOption*, const char*, float*)</code><br>
	 * <i>native declaration : libavutil\opt.h:374</i><br>
	 * @deprecated use the safer methods {@link #av_opt_eval_float(Pointer, org.ffmpeg.avutil55.AVOption, String, FloatBuffer)} and {@link #av_opt_eval_float(Pointer, org.ffmpeg.avutil55.AVOption, Pointer, FloatByReference)} instead
	 */
	@Deprecated 
	int av_opt_eval_float(Pointer obj, AVOption o, Pointer val, FloatByReference float_out);
	/**
	 * Original signature : <code>int av_opt_eval_float(void*, const AVOption*, const char*, float*)</code><br>
	 * <i>native declaration : libavutil\opt.h:374</i>
	 */
	int av_opt_eval_float(Pointer obj, AVOption o, String val, FloatBuffer float_out);
	/**
	 * Original signature : <code>int av_opt_eval_double(void*, const AVOption*, const char*, double*)</code><br>
	 * <i>native declaration : libavutil\opt.h:376</i><br>
	 * @deprecated use the safer methods {@link #av_opt_eval_double(Pointer, org.ffmpeg.avutil55.AVOption, String, DoubleBuffer)} and {@link #av_opt_eval_double(Pointer, org.ffmpeg.avutil55.AVOption, Pointer, DoubleByReference)} instead
	 */
	@Deprecated 
	int av_opt_eval_double(Pointer obj, AVOption o, Pointer val, DoubleByReference double_out);
	/**
	 * Original signature : <code>int av_opt_eval_double(void*, const AVOption*, const char*, double*)</code><br>
	 * <i>native declaration : libavutil\opt.h:376</i>
	 */
	int av_opt_eval_double(Pointer obj, AVOption o, String val, DoubleBuffer double_out);
	/**
	 * Original signature : <code>int av_opt_eval_q(void*, const AVOption*, const char*, AVRational*)</code><br>
	 * <i>native declaration : libavutil\opt.h:378</i><br>
	 * @deprecated use the safer methods {@link #av_opt_eval_q(Pointer, org.ffmpeg.avutil55.AVOption, String, org.ffmpeg.avutil55.AVRational)} and {@link #av_opt_eval_q(Pointer, org.ffmpeg.avutil55.AVOption, Pointer, org.ffmpeg.avutil55.AVRational)} instead
	 */
	@Deprecated 
	int av_opt_eval_q(Pointer obj, AVOption o, Pointer val, AVRational q_out);
	/**
	 * Original signature : <code>int av_opt_eval_q(void*, const AVOption*, const char*, AVRational*)</code><br>
	 * <i>native declaration : libavutil\opt.h:378</i>
	 */
	int av_opt_eval_q(Pointer obj, AVOption o, String val, AVRational q_out);
	/**
	 * Look for an option in an object. Consider only options which<br>
	 * have all the specified flags set.<br>
	 * @param[in] obj A pointer to a struct whose first element is a<br>
	 *                pointer to an AVClass.<br>
	 *                Alternatively a double pointer to an AVClass, if<br>
	 *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.<br>
	 * @param[in] name The name of the option to look for.<br>
	 * @param[in] unit When searching for named constants, name of the unit<br>
	 *                 it belongs to.<br>
	 * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).<br>
	 * @param search_flags A combination of AV_OPT_SEARCH_*.<br>
	 * @return A pointer to the option found, or NULL if no option<br>
	 *         was found.<br>
	 * @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable<br>
	 * directly with av_opt_set(). Use special calls which take an options<br>
	 * AVDictionary (e.g. avformat_open_input()) to set options found with this<br>
	 * flag.<br>
	 * Original signature : <code>AVOption* av_opt_find(void*, const char*, const char*, int, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:399</i><br>
	 * @deprecated use the safer methods {@link #av_opt_find(Pointer, String, String, int, int)} and {@link #av_opt_find(Pointer, Pointer, Pointer, int, int)} instead
	 */
	@Deprecated 
	AVOption av_opt_find(Pointer obj, Pointer name, Pointer unit, int opt_flags, int search_flags);
	/**
	 * Look for an option in an object. Consider only options which<br>
	 * have all the specified flags set.<br>
	 * @param[in] obj A pointer to a struct whose first element is a<br>
	 *                pointer to an AVClass.<br>
	 *                Alternatively a double pointer to an AVClass, if<br>
	 *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.<br>
	 * @param[in] name The name of the option to look for.<br>
	 * @param[in] unit When searching for named constants, name of the unit<br>
	 *                 it belongs to.<br>
	 * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).<br>
	 * @param search_flags A combination of AV_OPT_SEARCH_*.<br>
	 * @return A pointer to the option found, or NULL if no option<br>
	 *         was found.<br>
	 * @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable<br>
	 * directly with av_opt_set(). Use special calls which take an options<br>
	 * AVDictionary (e.g. avformat_open_input()) to set options found with this<br>
	 * flag.<br>
	 * Original signature : <code>AVOption* av_opt_find(void*, const char*, const char*, int, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:399</i>
	 */
	AVOption av_opt_find(Pointer obj, String name, String unit, int opt_flags, int search_flags);
	/**
	 * Look for an option in an object. Consider only options which<br>
	 * have all the specified flags set.<br>
	 * @param[in] obj A pointer to a struct whose first element is a<br>
	 *                pointer to an AVClass.<br>
	 *                Alternatively a double pointer to an AVClass, if<br>
	 *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.<br>
	 * @param[in] name The name of the option to look for.<br>
	 * @param[in] unit When searching for named constants, name of the unit<br>
	 *                 it belongs to.<br>
	 * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).<br>
	 * @param search_flags A combination of AV_OPT_SEARCH_*.<br>
	 * @param[out] target_obj if non-NULL, an object to which the option belongs will be<br>
	 * written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present<br>
	 * in search_flags. This parameter is ignored if search_flags contain<br>
	 * AV_OPT_SEARCH_FAKE_OBJ.<br>
	 * @return A pointer to the option found, or NULL if no option<br>
	 *         was found.<br>
	 * Original signature : <code>AVOption* av_opt_find2(void*, const char*, const char*, int, int, void**)</code><br>
	 * <i>native declaration : libavutil\opt.h:420</i><br>
	 * @deprecated use the safer methods {@link #av_opt_find2(Pointer, String, String, int, int, PointerByReference)} and {@link #av_opt_find2(Pointer, Pointer, Pointer, int, int, PointerByReference)} instead
	 */
	@Deprecated 
	AVOption av_opt_find2(Pointer obj, Pointer name, Pointer unit, int opt_flags, int search_flags, PointerByReference target_obj);
	/**
	 * Look for an option in an object. Consider only options which<br>
	 * have all the specified flags set.<br>
	 * @param[in] obj A pointer to a struct whose first element is a<br>
	 *                pointer to an AVClass.<br>
	 *                Alternatively a double pointer to an AVClass, if<br>
	 *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.<br>
	 * @param[in] name The name of the option to look for.<br>
	 * @param[in] unit When searching for named constants, name of the unit<br>
	 *                 it belongs to.<br>
	 * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).<br>
	 * @param search_flags A combination of AV_OPT_SEARCH_*.<br>
	 * @param[out] target_obj if non-NULL, an object to which the option belongs will be<br>
	 * written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present<br>
	 * in search_flags. This parameter is ignored if search_flags contain<br>
	 * AV_OPT_SEARCH_FAKE_OBJ.<br>
	 * @return A pointer to the option found, or NULL if no option<br>
	 *         was found.<br>
	 * Original signature : <code>AVOption* av_opt_find2(void*, const char*, const char*, int, int, void**)</code><br>
	 * <i>native declaration : libavutil\opt.h:420</i>
	 */
	AVOption av_opt_find2(Pointer obj, String name, String unit, int opt_flags, int search_flags, PointerByReference target_obj);
	/**
	 * Iterate over all AVOptions belonging to obj.<br>
	 * @param obj an AVOptions-enabled struct or a double pointer to an<br>
	 *            AVClass describing it.<br>
	 * @param prev result of the previous call to av_opt_next() on this object<br>
	 *             or NULL<br>
	 * @return next AVOption or NULL<br>
	 * Original signature : <code>AVOption* av_opt_next(const void*, const AVOption*)</code><br>
	 * <i>native declaration : libavutil\opt.h:430</i>
	 */
	AVOption av_opt_next(Pointer obj, AVOption prev);
	/**
	 * Iterate over AVOptions-enabled children of obj.<br>
	 * @param prev result of a previous call to this function or NULL<br>
	 * @return next AVOptions-enabled child or NULL<br>
	 * Original signature : <code>void* av_opt_child_next(void*, void*)</code><br>
	 * <i>native declaration : libavutil\opt.h:437</i>
	 */
	Pointer av_opt_child_next(Pointer obj, Pointer prev);
	/**
	 * Iterate over potential AVOptions-enabled children of parent.<br>
	 * @param prev result of a previous call to this function or NULL<br>
	 * @return AVClass corresponding to next potential child or NULL<br>
	 * Original signature : <code>AVClass* av_opt_child_class_next(const AVClass*, const AVClass*)</code><br>
	 * <i>native declaration : libavutil\opt.h:444</i>
	 */
	Pointer av_opt_child_class_next(Pointer parent, Pointer prev);
	/**
	 * @defgroup opt_set_funcs Option setting functions<br>
	 * @{<br>
	 * Those functions set the field of obj with the given name to value.<br>
	 * @param[in] obj A struct whose first element is a pointer to an AVClass.<br>
	 * @param[in] name the name of the field to set<br>
	 * @param[in] val The value to set. In case of av_opt_set() if the field is not<br>
	 * of a string type, then the given string is parsed.<br>
	 * SI postfixes and some named scalars are supported.<br>
	 * If the field is of a numeric type, it has to be a numeric or named<br>
	 * scalar. Behavior with more than one scalar and +- infix operators<br>
	 * is undefined.<br>
	 * If the field is of a flags type, it has to be a sequence of numeric<br>
	 * scalars or named flags separated by '+' or '-'. Prefixing a flag<br>
	 * with '+' causes it to be set without affecting the other flags;<br>
	 * similarly, '-' unsets a flag.<br>
	 * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN<br>
	 * is passed here, then the option may be set on a child of obj.<br>
	 * @return 0 if the value has been set, or an AVERROR code in case of<br>
	 * error:<br>
	 * AVERROR_OPTION_NOT_FOUND if no matching option exists<br>
	 * AVERROR(ERANGE) if the value is out of range<br>
	 * AVERROR(EINVAL) if the value is not valid<br>
	 * Original signature : <code>int av_opt_set(void*, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:470</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set(Pointer, String, String, int)} and {@link #av_opt_set(Pointer, Pointer, Pointer, int)} instead
	 */
	@Deprecated 
	int av_opt_set(Pointer obj, Pointer name, Pointer val, int search_flags);
	/**
	 * @defgroup opt_set_funcs Option setting functions<br>
	 * @{<br>
	 * Those functions set the field of obj with the given name to value.<br>
	 * @param[in] obj A struct whose first element is a pointer to an AVClass.<br>
	 * @param[in] name the name of the field to set<br>
	 * @param[in] val The value to set. In case of av_opt_set() if the field is not<br>
	 * of a string type, then the given string is parsed.<br>
	 * SI postfixes and some named scalars are supported.<br>
	 * If the field is of a numeric type, it has to be a numeric or named<br>
	 * scalar. Behavior with more than one scalar and +- infix operators<br>
	 * is undefined.<br>
	 * If the field is of a flags type, it has to be a sequence of numeric<br>
	 * scalars or named flags separated by '+' or '-'. Prefixing a flag<br>
	 * with '+' causes it to be set without affecting the other flags;<br>
	 * similarly, '-' unsets a flag.<br>
	 * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN<br>
	 * is passed here, then the option may be set on a child of obj.<br>
	 * @return 0 if the value has been set, or an AVERROR code in case of<br>
	 * error:<br>
	 * AVERROR_OPTION_NOT_FOUND if no matching option exists<br>
	 * AVERROR(ERANGE) if the value is out of range<br>
	 * AVERROR(EINVAL) if the value is not valid<br>
	 * Original signature : <code>int av_opt_set(void*, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:470</i>
	 */
	int av_opt_set(Pointer obj, String name, String val, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_int(void*, const char*, int64_t, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:472</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_int(Pointer, String, long, int)} and {@link #av_opt_set_int(Pointer, Pointer, long, int)} instead
	 */
	@Deprecated 
	int av_opt_set_int(Pointer obj, Pointer name, long val, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_int(void*, const char*, int64_t, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:472</i>
	 */
	int av_opt_set_int(Pointer obj, String name, long val, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_double(void*, const char*, double, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:474</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_double(Pointer, String, double, int)} and {@link #av_opt_set_double(Pointer, Pointer, double, int)} instead
	 */
	@Deprecated 
	int av_opt_set_double(Pointer obj, Pointer name, double val, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_double(void*, const char*, double, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:474</i>
	 */
	int av_opt_set_double(Pointer obj, String name, double val, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_q(void*, const char*, AVRational, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:476</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_q(Pointer, String, org.ffmpeg.avutil55.AVRational.ByValue, int)} and {@link #av_opt_set_q(Pointer, Pointer, org.ffmpeg.avutil55.AVRational.ByValue, int)} instead
	 */
	@Deprecated 
	int av_opt_set_q(Pointer obj, Pointer name, AVRational.ByValue val, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_q(void*, const char*, AVRational, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:476</i>
	 */
	int av_opt_set_q(Pointer obj, String name, AVRational.ByValue val, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_bin(void*, const char*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:478</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_bin(Pointer, String, byte[], int, int)} and {@link #av_opt_set_bin(Pointer, Pointer, Pointer, int, int)} instead
	 */
	@Deprecated 
	int av_opt_set_bin(Pointer obj, Pointer name, Pointer val, int size, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_bin(void*, const char*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:478</i>
	 */
	int av_opt_set_bin(Pointer obj, String name, byte val[], int size, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_image_size(void*, const char*, int, int, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:480</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_image_size(Pointer, String, int, int, int)} and {@link #av_opt_set_image_size(Pointer, Pointer, int, int, int)} instead
	 */
	@Deprecated 
	int av_opt_set_image_size(Pointer obj, Pointer name, int w, int h, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_image_size(void*, const char*, int, int, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:480</i>
	 */
	int av_opt_set_image_size(Pointer obj, String name, int w, int h, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_pixel_fmt(void*, const char*, AVPixelFormat, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:482</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_pixel_fmt(Pointer, String, int, int)} and {@link #av_opt_set_pixel_fmt(Pointer, Pointer, int, int)} instead
	 */
	@Deprecated 
	int av_opt_set_pixel_fmt(Pointer obj, Pointer name, int fmt, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_pixel_fmt(void*, const char*, AVPixelFormat, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:482</i>
	 */
	int av_opt_set_pixel_fmt(Pointer obj, String name, int fmt, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_sample_fmt(void*, const char*, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:484</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_sample_fmt(Pointer, String, int, int)} and {@link #av_opt_set_sample_fmt(Pointer, Pointer, int, int)} instead
	 */
	@Deprecated 
	int av_opt_set_sample_fmt(Pointer obj, Pointer name, int fmt, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_sample_fmt(void*, const char*, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:484</i>
	 */
	int av_opt_set_sample_fmt(Pointer obj, String name, int fmt, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_video_rate(void*, const char*, AVRational, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:486</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_video_rate(Pointer, String, org.ffmpeg.avutil55.AVRational.ByValue, int)} and {@link #av_opt_set_video_rate(Pointer, Pointer, org.ffmpeg.avutil55.AVRational.ByValue, int)} instead
	 */
	@Deprecated 
	int av_opt_set_video_rate(Pointer obj, Pointer name, AVRational.ByValue val, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_video_rate(void*, const char*, AVRational, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:486</i>
	 */
	int av_opt_set_video_rate(Pointer obj, String name, AVRational.ByValue val, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_channel_layout(void*, const char*, int64_t, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:488</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_channel_layout(Pointer, String, long, int)} and {@link #av_opt_set_channel_layout(Pointer, Pointer, long, int)} instead
	 */
	@Deprecated 
	int av_opt_set_channel_layout(Pointer obj, Pointer name, long ch_layout, int search_flags);
	/**
	 * Original signature : <code>int av_opt_set_channel_layout(void*, const char*, int64_t, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:488</i>
	 */
	int av_opt_set_channel_layout(Pointer obj, String name, long ch_layout, int search_flags);
	/**
	 * @note Any old dictionary present is discarded and replaced with a copy of the new one. The<br>
	 * caller still owns val is and responsible for freeing it.<br>
	 * Original signature : <code>int av_opt_set_dict_val(void*, const char*, const AVDictionary*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:494</i><br>
	 * @deprecated use the safer methods {@link #av_opt_set_dict_val(Pointer, String, org.ffmpeg.avutil55.AVDictionary, int)} and {@link #av_opt_set_dict_val(Pointer, Pointer, org.ffmpeg.avutil55.AVDictionary, int)} instead
	 */
	@Deprecated 
	int av_opt_set_dict_val(Pointer obj, Pointer name, AVDictionary val, int search_flags);
	/**
	 * @note Any old dictionary present is discarded and replaced with a copy of the new one. The<br>
	 * caller still owns val is and responsible for freeing it.<br>
	 * Original signature : <code>int av_opt_set_dict_val(void*, const char*, const AVDictionary*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:494</i>
	 */
	int av_opt_set_dict_val(Pointer obj, String name, AVDictionary val, int search_flags);
	/**
	 * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller<br>
	 * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the option has<br>
	 * AV_OPT_TYPE_STRING or AV_OPT_TYPE_BINARY and is set to NULL, *out_val will be set<br>
	 * to NULL instead of an allocated empty string.<br>
	 * Original signature : <code>int av_opt_get(void*, const char*, int, uint8_t**)</code><br>
	 * <i>native declaration : libavutil\opt.h:502</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get(Pointer, String, int, PointerByReference)} and {@link #av_opt_get(Pointer, Pointer, int, PointerByReference)} instead
	 */
	@Deprecated 
	int av_opt_get(Pointer obj, Pointer name, int search_flags, PointerByReference out_val);
	/**
	 * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller<br>
	 * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the option has<br>
	 * AV_OPT_TYPE_STRING or AV_OPT_TYPE_BINARY and is set to NULL, *out_val will be set<br>
	 * to NULL instead of an allocated empty string.<br>
	 * Original signature : <code>int av_opt_get(void*, const char*, int, uint8_t**)</code><br>
	 * <i>native declaration : libavutil\opt.h:502</i>
	 */
	int av_opt_get(Pointer obj, String name, int search_flags, PointerByReference out_val);
	/**
	 * Original signature : <code>int av_opt_get_int(void*, const char*, int, int64_t*)</code><br>
	 * <i>native declaration : libavutil\opt.h:504</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get_int(Pointer, String, int, LongBuffer)} and {@link #av_opt_get_int(Pointer, Pointer, int, LongByReference)} instead
	 */
	@Deprecated 
	int av_opt_get_int(Pointer obj, Pointer name, int search_flags, LongByReference out_val);
	/**
	 * Original signature : <code>int av_opt_get_int(void*, const char*, int, int64_t*)</code><br>
	 * <i>native declaration : libavutil\opt.h:504</i>
	 */
	int av_opt_get_int(Pointer obj, String name, int search_flags, LongBuffer out_val);
	/**
	 * Original signature : <code>int av_opt_get_double(void*, const char*, int, double*)</code><br>
	 * <i>native declaration : libavutil\opt.h:506</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get_double(Pointer, String, int, DoubleBuffer)} and {@link #av_opt_get_double(Pointer, Pointer, int, DoubleByReference)} instead
	 */
	@Deprecated 
	int av_opt_get_double(Pointer obj, Pointer name, int search_flags, DoubleByReference out_val);
	/**
	 * Original signature : <code>int av_opt_get_double(void*, const char*, int, double*)</code><br>
	 * <i>native declaration : libavutil\opt.h:506</i>
	 */
	int av_opt_get_double(Pointer obj, String name, int search_flags, DoubleBuffer out_val);
	/**
	 * Original signature : <code>int av_opt_get_q(void*, const char*, int, AVRational*)</code><br>
	 * <i>native declaration : libavutil\opt.h:508</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get_q(Pointer, String, int, org.ffmpeg.avutil55.AVRational)} and {@link #av_opt_get_q(Pointer, Pointer, int, org.ffmpeg.avutil55.AVRational)} instead
	 */
	@Deprecated 
	int av_opt_get_q(Pointer obj, Pointer name, int search_flags, AVRational out_val);
	/**
	 * Original signature : <code>int av_opt_get_q(void*, const char*, int, AVRational*)</code><br>
	 * <i>native declaration : libavutil\opt.h:508</i>
	 */
	int av_opt_get_q(Pointer obj, String name, int search_flags, AVRational out_val);
	/**
	 * Original signature : <code>int av_opt_get_image_size(void*, const char*, int, int*, int*)</code><br>
	 * <i>native declaration : libavutil\opt.h:510</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get_image_size(Pointer, String, int, IntBuffer, IntBuffer)} and {@link #av_opt_get_image_size(Pointer, Pointer, int, IntByReference, IntByReference)} instead
	 */
	@Deprecated 
	int av_opt_get_image_size(Pointer obj, Pointer name, int search_flags, IntByReference w_out, IntByReference h_out);
	/**
	 * Original signature : <code>int av_opt_get_image_size(void*, const char*, int, int*, int*)</code><br>
	 * <i>native declaration : libavutil\opt.h:510</i>
	 */
	int av_opt_get_image_size(Pointer obj, String name, int search_flags, IntBuffer w_out, IntBuffer h_out);
	/**
	 * Original signature : <code>int av_opt_get_pixel_fmt(void*, const char*, int, AVPixelFormat*)</code><br>
	 * <i>native declaration : libavutil\opt.h:512</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get_pixel_fmt(Pointer, String, int, IntBuffer)} and {@link #av_opt_get_pixel_fmt(Pointer, Pointer, int, IntByReference)} instead
	 */
	@Deprecated 
	int av_opt_get_pixel_fmt(Pointer obj, Pointer name, int search_flags, IntByReference out_fmt);
	/**
	 * Original signature : <code>int av_opt_get_pixel_fmt(void*, const char*, int, AVPixelFormat*)</code><br>
	 * <i>native declaration : libavutil\opt.h:512</i>
	 */
	int av_opt_get_pixel_fmt(Pointer obj, String name, int search_flags, IntBuffer out_fmt);
	/**
	 * Original signature : <code>int av_opt_get_sample_fmt(void*, const char*, int, AVSampleFormat*)</code><br>
	 * <i>native declaration : libavutil\opt.h:514</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get_sample_fmt(Pointer, String, int, IntBuffer)} and {@link #av_opt_get_sample_fmt(Pointer, Pointer, int, IntByReference)} instead
	 */
	@Deprecated 
	int av_opt_get_sample_fmt(Pointer obj, Pointer name, int search_flags, IntByReference out_fmt);
	/**
	 * Original signature : <code>int av_opt_get_sample_fmt(void*, const char*, int, AVSampleFormat*)</code><br>
	 * <i>native declaration : libavutil\opt.h:514</i>
	 */
	int av_opt_get_sample_fmt(Pointer obj, String name, int search_flags, IntBuffer out_fmt);
	/**
	 * Original signature : <code>int av_opt_get_video_rate(void*, const char*, int, AVRational*)</code><br>
	 * <i>native declaration : libavutil\opt.h:516</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get_video_rate(Pointer, String, int, org.ffmpeg.avutil55.AVRational)} and {@link #av_opt_get_video_rate(Pointer, Pointer, int, org.ffmpeg.avutil55.AVRational)} instead
	 */
	@Deprecated 
	int av_opt_get_video_rate(Pointer obj, Pointer name, int search_flags, AVRational out_val);
	/**
	 * Original signature : <code>int av_opt_get_video_rate(void*, const char*, int, AVRational*)</code><br>
	 * <i>native declaration : libavutil\opt.h:516</i>
	 */
	int av_opt_get_video_rate(Pointer obj, String name, int search_flags, AVRational out_val);
	/**
	 * Original signature : <code>int av_opt_get_channel_layout(void*, const char*, int, int64_t*)</code><br>
	 * <i>native declaration : libavutil\opt.h:518</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get_channel_layout(Pointer, String, int, LongBuffer)} and {@link #av_opt_get_channel_layout(Pointer, Pointer, int, LongByReference)} instead
	 */
	@Deprecated 
	int av_opt_get_channel_layout(Pointer obj, Pointer name, int search_flags, LongByReference ch_layout);
	/**
	 * Original signature : <code>int av_opt_get_channel_layout(void*, const char*, int, int64_t*)</code><br>
	 * <i>native declaration : libavutil\opt.h:518</i>
	 */
	int av_opt_get_channel_layout(Pointer obj, String name, int search_flags, LongBuffer ch_layout);
	/**
	 * @param[out] out_val The returned dictionary is a copy of the actual value and must<br>
	 * be freed with av_dict_free() by the caller<br>
	 * Original signature : <code>int av_opt_get_dict_val(void*, const char*, int, AVDictionary**)</code><br>
	 * <i>native declaration : libavutil\opt.h:524</i><br>
	 * @deprecated use the safer methods {@link #av_opt_get_dict_val(Pointer, String, int, org.ffmpeg.avutil55.AVDictionary.ByReference[])} and {@link #av_opt_get_dict_val(Pointer, Pointer, int, org.ffmpeg.avutil55.AVDictionary.ByReference[])} instead
	 */
	@Deprecated 
	int av_opt_get_dict_val(Pointer obj, Pointer name, int search_flags, PointerByReference out_val);
	/**
	 * @param[out] out_val The returned dictionary is a copy of the actual value and must<br>
	 * be freed with av_dict_free() by the caller<br>
	 * Original signature : <code>int av_opt_get_dict_val(void*, const char*, int, AVDictionary**)</code><br>
	 * <i>native declaration : libavutil\opt.h:524</i>
	 */
	int av_opt_get_dict_val(Pointer obj, String name, int search_flags, AVDictionary.ByReference out_val[]);
	/**
	 * @param[out] out_val The returned dictionary is a copy of the actual value and must<br>
	 * be freed with av_dict_free() by the caller<br>
	 * Original signature : <code>int av_opt_get_dict_val(void*, const char*, int, AVDictionary**)</code><br>
	 * <i>native declaration : libavutil\opt.h:524</i>
	 */
	int av_opt_get_dict_val(Pointer obj, Pointer name, int search_flags, AVDictionary.ByReference out_val[]);
	/**
	 * Gets a pointer to the requested field in a struct.<br>
	 * This function allows accessing a struct even when its fields are moved or<br>
	 * renamed since the application making the access has been compiled,<br>
	 * @returns a pointer to the field, it can be cast to the correct type and read<br>
	 *          or written to.<br>
	 * Original signature : <code>void* av_opt_ptr(const AVClass*, void*, const char*)</code><br>
	 * <i>native declaration : libavutil\opt.h:533</i><br>
	 * @deprecated use the safer methods {@link #av_opt_ptr(org.ffmpeg.avutil55.Pointer, Pointer, String)} and {@link #av_opt_ptr(org.ffmpeg.avutil55.Pointer, Pointer, Pointer)} instead
	 */
	@Deprecated 
	Pointer av_opt_ptr(Pointer avclass, Pointer obj, Pointer name);
	/**
	 * Gets a pointer to the requested field in a struct.<br>
	 * This function allows accessing a struct even when its fields are moved or<br>
	 * renamed since the application making the access has been compiled,<br>
	 * @returns a pointer to the field, it can be cast to the correct type and read<br>
	 *          or written to.<br>
	 * Original signature : <code>void* av_opt_ptr(const AVClass*, void*, const char*)</code><br>
	 * <i>native declaration : libavutil\opt.h:533</i>
	 */
	Pointer av_opt_ptr(Pointer avclass, Pointer obj, String name);
	/**
	 * Free an AVOptionRanges struct and set it to NULL.<br>
	 * Original signature : <code>void av_opt_freep_ranges(AVOptionRanges**)</code><br>
	 * <i>native declaration : libavutil\opt.h:538</i><br>
	 * @deprecated use the safer method {@link #av_opt_freep_ranges(org.ffmpeg.avutil55.AVOptionRanges.ByReference[])} instead
	 */
	@Deprecated 
	void av_opt_freep_ranges(PointerByReference ranges);
	/**
	 * Free an AVOptionRanges struct and set it to NULL.<br>
	 * Original signature : <code>void av_opt_freep_ranges(AVOptionRanges**)</code><br>
	 * <i>native declaration : libavutil\opt.h:538</i>
	 */
	void av_opt_freep_ranges(org.ffmpeg.avutil55.AVOptionRanges.ByReference ranges[]);
	/**
	 * Get a list of allowed ranges for the given option.<br>
	 * The returned list may depend on other fields in obj like for example profile.<br>
	 * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored<br>
	 *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance<br>
	 *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges<br>
	 * The result must be freed with av_opt_freep_ranges.<br>
	 * @return number of compontents returned on success, a negative errro code otherwise<br>
	 * Original signature : <code>int av_opt_query_ranges(AVOptionRanges**, void*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:549</i><br>
	 * @deprecated use the safer methods {@link #av_opt_query_ranges(org.ffmpeg.avutil55.AVOptionRanges.ByReference[], Pointer, String, int)} and {@link #av_opt_query_ranges(org.ffmpeg.avutil55.AVOptionRanges.ByReference[], Pointer, Pointer, int)} instead
	 */
	@Deprecated 
	int av_opt_query_ranges(PointerByReference AVOptionRangesPtrPtr1, Pointer obj, Pointer key, int flags);
	/**
	 * Get a list of allowed ranges for the given option.<br>
	 * The returned list may depend on other fields in obj like for example profile.<br>
	 * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored<br>
	 *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance<br>
	 *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges<br>
	 * The result must be freed with av_opt_freep_ranges.<br>
	 * @return number of compontents returned on success, a negative errro code otherwise<br>
	 * Original signature : <code>int av_opt_query_ranges(AVOptionRanges**, void*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:549</i>
	 */
	int av_opt_query_ranges(org.ffmpeg.avutil55.AVOptionRanges.ByReference AVOptionRangesPtrPtr1[], Pointer obj, String key, int flags);
	/**
	 * Get a list of allowed ranges for the given option.<br>
	 * The returned list may depend on other fields in obj like for example profile.<br>
	 * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored<br>
	 *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance<br>
	 *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges<br>
	 * The result must be freed with av_opt_freep_ranges.<br>
	 * @return number of compontents returned on success, a negative errro code otherwise<br>
	 * Original signature : <code>int av_opt_query_ranges(AVOptionRanges**, void*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:549</i>
	 */
	int av_opt_query_ranges(org.ffmpeg.avutil55.AVOptionRanges.ByReference AVOptionRangesPtrPtr1[], Pointer obj, Pointer key, int flags);
	/**
	 * Copy options from src object into dest object.<br>
	 * Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.<br>
	 * Original memory allocated for such options is freed unless both src and dest options points to the same memory.<br>
	 * @param dest Object to copy from<br>
	 * @param src  Object to copy into<br>
	 * @return 0 on success, negative on error<br>
	 * Original signature : <code>int av_opt_copy(void*, const void*)</code><br>
	 * <i>native declaration : libavutil\opt.h:559</i>
	 */
	int av_opt_copy(Pointer dest, Pointer src);
	/**
	 * Get a default list of allowed ranges for the given option.<br>
	 * This list is constructed without using the AVClass.query_ranges() callback<br>
	 * and can be used as fallback from within the callback.<br>
	 * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored<br>
	 *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance<br>
	 *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges<br>
	 * The result must be freed with av_opt_free_ranges.<br>
	 * @return number of compontents returned on success, a negative errro code otherwise<br>
	 * Original signature : <code>int av_opt_query_ranges_default(AVOptionRanges**, void*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:571</i><br>
	 * @deprecated use the safer methods {@link #av_opt_query_ranges_default(org.ffmpeg.avutil55.AVOptionRanges.ByReference[], Pointer, String, int)} and {@link #av_opt_query_ranges_default(org.ffmpeg.avutil55.AVOptionRanges.ByReference[], Pointer, Pointer, int)} instead
	 */
	@Deprecated 
	int av_opt_query_ranges_default(PointerByReference AVOptionRangesPtrPtr1, Pointer obj, Pointer key, int flags);
	/**
	 * Get a default list of allowed ranges for the given option.<br>
	 * This list is constructed without using the AVClass.query_ranges() callback<br>
	 * and can be used as fallback from within the callback.<br>
	 * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored<br>
	 *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance<br>
	 *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges<br>
	 * The result must be freed with av_opt_free_ranges.<br>
	 * @return number of compontents returned on success, a negative errro code otherwise<br>
	 * Original signature : <code>int av_opt_query_ranges_default(AVOptionRanges**, void*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:571</i>
	 */
	int av_opt_query_ranges_default(org.ffmpeg.avutil55.AVOptionRanges.ByReference AVOptionRangesPtrPtr1[], Pointer obj, String key, int flags);
	/**
	 * Get a default list of allowed ranges for the given option.<br>
	 * This list is constructed without using the AVClass.query_ranges() callback<br>
	 * and can be used as fallback from within the callback.<br>
	 * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored<br>
	 *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance<br>
	 *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges<br>
	 * The result must be freed with av_opt_free_ranges.<br>
	 * @return number of compontents returned on success, a negative errro code otherwise<br>
	 * Original signature : <code>int av_opt_query_ranges_default(AVOptionRanges**, void*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:571</i>
	 */
	int av_opt_query_ranges_default(org.ffmpeg.avutil55.AVOptionRanges.ByReference AVOptionRangesPtrPtr1[], Pointer obj, Pointer key, int flags);
	/**
	 * Check if given option is set to its default value.<br>
	 * Options o must belong to the obj. This function must not be called to check child's options state.<br>
	 * @see av_opt_is_set_to_default_by_name().<br>
	 * @param obj  AVClass object to check option on<br>
	 * @param o    option to be checked<br>
	 * @return     >0 when option is set to its default,<br>
	 *              0 when option is not set its default,<br>
	 *             <0 on error<br>
	 * Original signature : <code>int av_opt_is_set_to_default(void*, const AVOption*)</code><br>
	 * <i>native declaration : libavutil\opt.h:583</i>
	 */
	int av_opt_is_set_to_default(Pointer obj, AVOption o);
	/**
	 * Check if given option is set to its default value.<br>
	 * @param obj          AVClass object to check option on<br>
	 * @param name         option name<br>
	 * @param search_flags combination of AV_OPT_SEARCH_*<br>
	 * @return             >0 when option is set to its default,<br>
	 *                     0 when option is not set its default,<br>
	 *                     <0 on error<br>
	 * Original signature : <code>int av_opt_is_set_to_default_by_name(void*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:594</i><br>
	 * @deprecated use the safer methods {@link #av_opt_is_set_to_default_by_name(Pointer, String, int)} and {@link #av_opt_is_set_to_default_by_name(Pointer, Pointer, int)} instead
	 */
	@Deprecated 
	int av_opt_is_set_to_default_by_name(Pointer obj, Pointer name, int search_flags);
	/**
	 * Check if given option is set to its default value.<br>
	 * @param obj          AVClass object to check option on<br>
	 * @param name         option name<br>
	 * @param search_flags combination of AV_OPT_SEARCH_*<br>
	 * @return             >0 when option is set to its default,<br>
	 *                     0 when option is not set its default,<br>
	 *                     <0 on error<br>
	 * Original signature : <code>int av_opt_is_set_to_default_by_name(void*, const char*, int)</code><br>
	 * <i>native declaration : libavutil\opt.h:594</i>
	 */
	int av_opt_is_set_to_default_by_name(Pointer obj, String name, int search_flags);
	/**
	 * Serialize object's options.<br>
	 * Create a string containing object's serialized options.<br>
	 * Such string may be passed back to av_opt_set_from_string() in order to restore option values.<br>
	 * A key/value or pairs separator occurring in the serialized value or<br>
	 * name string are escaped through the av_escape() function.<br>
	 * @param[in]  obj           AVClass object to serialize<br>
	 * @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)<br>
	 * @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags<br>
	 * @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options.<br>
	 *                           Buffer must be freed by the caller when is no longer needed.<br>
	 * @param[in]  key_val_sep   character used to separate key from value<br>
	 * @param[in]  pairs_sep     character used to separate two pairs from each other<br>
	 * @return                   >= 0 on success, negative on error<br>
	 * @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.<br>
	 * Original signature : <code>int av_opt_serialize(void*, int, int, char**, const char, const char)</code><br>
	 * <i>native declaration : libavutil\opt.h:612</i>
	 */
	int av_opt_serialize(Pointer obj, int opt_flags, int flags, PointerByReference buffer, byte key_val_sep, byte pairs_sep);
	/**
	 * Return the number of bits per pixel used by the pixel format<br>
	 * described by pixdesc. Note that this is not the same as the number<br>
	 * of bits per sample.<br>
	 * The returned number of bits refers to the number of bits actually<br>
	 * used for storing the pixel information, that is padding bits are<br>
	 * not counted.<br>
	 * Original signature : <code>int av_get_bits_per_pixel(const AVPixFmtDescriptor*)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:37</i>
	 */
	int av_get_bits_per_pixel(AVPixFmtDescriptor pixdesc);
	/**
	 * Return the number of bits per pixel for the pixel format<br>
	 * described by pixdesc, including any padding or unused bits.<br>
	 * Original signature : <code>int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor*)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:43</i>
	 */
	int av_get_padded_bits_per_pixel(AVPixFmtDescriptor pixdesc);
	/**
	 * @return a pixel format descriptor for provided pixel format or NULL if<br>
	 * this pixel format is unknown.<br>
	 * Original signature : <code>AVPixFmtDescriptor* av_pix_fmt_desc_get(AVPixelFormat)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:49</i>
	 */
	AVPixFmtDescriptor av_pix_fmt_desc_get(int pix_fmt);
	/**
	 * Iterate over all pixel format descriptors known to libavutil.<br>
	 * @param prev previous descriptor. NULL to get the first descriptor.<br>
	 * @return next descriptor or NULL after the last descriptor<br>
	 * Original signature : <code>AVPixFmtDescriptor* av_pix_fmt_desc_next(const AVPixFmtDescriptor*)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:56</i>
	 */
	AVPixFmtDescriptor av_pix_fmt_desc_next(AVPixFmtDescriptor prev);
	/**
	 * @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc<br>
	 * is not a valid pointer to a pixel format descriptor.<br>
	 * Original signature : <code>AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor*)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:62</i>
	 */
	int av_pix_fmt_desc_get_id(AVPixFmtDescriptor desc);
	/**
	 * Utility function to access log2_chroma_w log2_chroma_h from<br>
	 * the pixel format AVPixFmtDescriptor.<br>
	 * See av_get_chroma_sub_sample() for a function that asserts a<br>
	 * valid pixel format instead of returning an error code.<br>
	 * Its recommended that you use avcodec_get_chroma_sub_sample unless<br>
	 * you do check the return code!<br>
	 * @param[in]  pix_fmt the pixel format<br>
	 * @param[out] h_shift store log2_chroma_w (horizontal/width shift)<br>
	 * @param[out] v_shift store log2_chroma_h (vertical/height shift)<br>
	 * @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format<br>
	 * Original signature : <code>int av_pix_fmt_get_chroma_sub_sample(AVPixelFormat, int*, int*)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:76</i><br>
	 * @deprecated use the safer methods {@link #av_pix_fmt_get_chroma_sub_sample(int, IntBuffer, IntBuffer)} and {@link #av_pix_fmt_get_chroma_sub_sample(int, IntByReference, IntByReference)} instead
	 */
	@Deprecated 
	int av_pix_fmt_get_chroma_sub_sample(int pix_fmt, IntByReference h_shift, IntByReference v_shift);
	/**
	 * Utility function to access log2_chroma_w log2_chroma_h from<br>
	 * the pixel format AVPixFmtDescriptor.<br>
	 * See av_get_chroma_sub_sample() for a function that asserts a<br>
	 * valid pixel format instead of returning an error code.<br>
	 * Its recommended that you use avcodec_get_chroma_sub_sample unless<br>
	 * you do check the return code!<br>
	 * @param[in]  pix_fmt the pixel format<br>
	 * @param[out] h_shift store log2_chroma_w (horizontal/width shift)<br>
	 * @param[out] v_shift store log2_chroma_h (vertical/height shift)<br>
	 * @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format<br>
	 * Original signature : <code>int av_pix_fmt_get_chroma_sub_sample(AVPixelFormat, int*, int*)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:76</i>
	 */
	int av_pix_fmt_get_chroma_sub_sample(int pix_fmt, IntBuffer h_shift, IntBuffer v_shift);
	/**
	 * @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a<br>
	 * valid pixel format.<br>
	 * Original signature : <code>int av_pix_fmt_count_planes(AVPixelFormat)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:82</i>
	 */
	int av_pix_fmt_count_planes(int pix_fmt);
	/**
	 * @return the name for provided color range or NULL if unknown.<br>
	 * Original signature : <code>char* av_color_range_name(AVColorRange)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:87</i>
	 */
	String av_color_range_name(int range);
	/**
	 * @return the name for provided color primaries or NULL if unknown.<br>
	 * Original signature : <code>char* av_color_primaries_name(AVColorPrimaries)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:92</i>
	 */
	String av_color_primaries_name(int primaries);
	/**
	 * @return the name for provided color transfer or NULL if unknown.<br>
	 * Original signature : <code>char* av_color_transfer_name(AVColorTransferCharacteristic)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:97</i>
	 */
	String av_color_transfer_name(int transfer);
	/**
	 * @return the name for provided color space or NULL if unknown.<br>
	 * Original signature : <code>char* av_color_space_name(AVColorSpace)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:102</i>
	 */
	String av_color_space_name(int space);
	/**
	 * @return the name for provided chroma location or NULL if unknown.<br>
	 * Original signature : <code>char* av_chroma_location_name(AVChromaLocation)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:107</i>
	 */
	String av_chroma_location_name(int location);
	/**
	 * Return the pixel format corresponding to name.<br>
	 * If there is no pixel format with name name, then looks for a<br>
	 * pixel format with the name corresponding to the native endian<br>
	 * format of name.<br>
	 * For example in a little-endian system, first looks for "gray16",<br>
	 * then for "gray16le".<br>
	 * Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.<br>
	 * Original signature : <code>AVPixelFormat av_get_pix_fmt(const char*)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:118</i><br>
	 * @deprecated use the safer methods {@link #av_get_pix_fmt(String)} and {@link #av_get_pix_fmt(Pointer)} instead
	 */
	@Deprecated 
	int av_get_pix_fmt(Pointer name);
	/**
	 * Return the pixel format corresponding to name.<br>
	 * If there is no pixel format with name name, then looks for a<br>
	 * pixel format with the name corresponding to the native endian<br>
	 * format of name.<br>
	 * For example in a little-endian system, first looks for "gray16",<br>
	 * then for "gray16le".<br>
	 * Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.<br>
	 * Original signature : <code>AVPixelFormat av_get_pix_fmt(const char*)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:118</i>
	 */
	int av_get_pix_fmt(String name);
	/**
	 * Return the short name for a pixel format, NULL in case pix_fmt is<br>
	 * unknown.<br>
	 * @see av_get_pix_fmt(), av_get_pix_fmt_string()<br>
	 * Original signature : <code>char* av_get_pix_fmt_name(AVPixelFormat)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:125</i>
	 */
	String av_get_pix_fmt_name(int pix_fmt);
	/**
	 * Print in buf the string corresponding to the pixel format with<br>
	 * number pix_fmt, or a header if pix_fmt is negative.<br>
	 * @param buf the buffer where to write the string<br>
	 * @param buf_size the size of buf<br>
	 * @param pix_fmt the number of the pixel format to print the<br>
	 * corresponding info string, or a negative value to print the<br>
	 * corresponding header.<br>
	 * Original signature : <code>char* av_get_pix_fmt_string(char*, int, AVPixelFormat)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:136</i><br>
	 * @deprecated use the safer methods {@link #av_get_pix_fmt_string(ByteBuffer, int, int)} and {@link #av_get_pix_fmt_string(Pointer, int, int)} instead
	 */
	@Deprecated 
	Pointer av_get_pix_fmt_string(Pointer buf, int buf_size, int pix_fmt);
	/**
	 * Print in buf the string corresponding to the pixel format with<br>
	 * number pix_fmt, or a header if pix_fmt is negative.<br>
	 * @param buf the buffer where to write the string<br>
	 * @param buf_size the size of buf<br>
	 * @param pix_fmt the number of the pixel format to print the<br>
	 * corresponding info string, or a negative value to print the<br>
	 * corresponding header.<br>
	 * Original signature : <code>char* av_get_pix_fmt_string(char*, int, AVPixelFormat)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:136</i>
	 */
	Pointer av_get_pix_fmt_string(ByteBuffer buf, int buf_size, int pix_fmt);
	/**
	 * Read a line from an image, and write the values of the<br>
	 * pixel format component c to dst.<br>
	 * @param data the array containing the pointers to the planes of the image<br>
	 * @param linesize the array containing the linesizes of the image<br>
	 * @param desc the pixel format descriptor for the image<br>
	 * @param x the horizontal coordinate of the first pixel to read<br>
	 * @param y the vertical coordinate of the first pixel to read<br>
	 * @param w the width of the line to read, that is the number of<br>
	 * values to write to dst<br>
	 * @param read_pal_component if not zero and the format is a paletted<br>
	 * format writes the values corresponding to the palette<br>
	 * component c in data[1] to dst, rather than the palette indexes in<br>
	 * data[0]. The behavior is undefined if the format is not paletted.<br>
	 * Original signature : <code>void av_read_image_line(uint16_t*, const uint8_t*[4], const int[4], const AVPixFmtDescriptor*, int, int, int, int, int)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:153</i><br>
	 * @deprecated use the safer methods {@link #av_read_image_line(ShortBuffer, byte[], int[], org.ffmpeg.avutil55.AVPixFmtDescriptor, int, int, int, int, int)} and {@link #av_read_image_line(ShortByReference, PointerByReference, IntByReference, org.ffmpeg.avutil55.AVPixFmtDescriptor, int, int, int, int, int)} instead
	 */
	@Deprecated 
	void av_read_image_line(ShortByReference dst, PointerByReference data, IntByReference linesize, AVPixFmtDescriptor desc, int x, int y, int c, int w, int read_pal_component);
	/**
	 * Read a line from an image, and write the values of the<br>
	 * pixel format component c to dst.<br>
	 * @param data the array containing the pointers to the planes of the image<br>
	 * @param linesize the array containing the linesizes of the image<br>
	 * @param desc the pixel format descriptor for the image<br>
	 * @param x the horizontal coordinate of the first pixel to read<br>
	 * @param y the vertical coordinate of the first pixel to read<br>
	 * @param w the width of the line to read, that is the number of<br>
	 * values to write to dst<br>
	 * @param read_pal_component if not zero and the format is a paletted<br>
	 * format writes the values corresponding to the palette<br>
	 * component c in data[1] to dst, rather than the palette indexes in<br>
	 * data[0]. The behavior is undefined if the format is not paletted.<br>
	 * Original signature : <code>void av_read_image_line(uint16_t*, const uint8_t*[4], const int[4], const AVPixFmtDescriptor*, int, int, int, int, int)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:153</i>
	 */
	void av_read_image_line(ShortBuffer dst, byte data[], int linesize[], AVPixFmtDescriptor desc, int x, int y, int c, int w, int read_pal_component);
	/**
	 * Write the values from src to the pixel format component c of an<br>
	 * image line.<br>
	 * @param src array containing the values to write<br>
	 * @param data the array containing the pointers to the planes of the<br>
	 * image to write into. It is supposed to be zeroed.<br>
	 * @param linesize the array containing the linesizes of the image<br>
	 * @param desc the pixel format descriptor for the image<br>
	 * @param x the horizontal coordinate of the first pixel to write<br>
	 * @param y the vertical coordinate of the first pixel to write<br>
	 * @param w the width of the line to write, that is the number of<br>
	 * values to write to the image line<br>
	 * Original signature : <code>void av_write_image_line(const uint16_t*, uint8_t*[4], const int[4], const AVPixFmtDescriptor*, int, int, int, int)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:168</i><br>
	 * @deprecated use the safer methods {@link #av_write_image_line(short[], ByteBuffer[], int[], org.ffmpeg.avutil55.AVPixFmtDescriptor, int, int, int, int)} and {@link #av_write_image_line(ShortByReference, PointerByReference, IntByReference, org.ffmpeg.avutil55.AVPixFmtDescriptor, int, int, int, int)} instead
	 */
	@Deprecated 
	void av_write_image_line(ShortByReference src, PointerByReference data, IntByReference linesize, AVPixFmtDescriptor desc, int x, int y, int c, int w);
	/**
	 * Write the values from src to the pixel format component c of an<br>
	 * image line.<br>
	 * @param src array containing the values to write<br>
	 * @param data the array containing the pointers to the planes of the<br>
	 * image to write into. It is supposed to be zeroed.<br>
	 * @param linesize the array containing the linesizes of the image<br>
	 * @param desc the pixel format descriptor for the image<br>
	 * @param x the horizontal coordinate of the first pixel to write<br>
	 * @param y the vertical coordinate of the first pixel to write<br>
	 * @param w the width of the line to write, that is the number of<br>
	 * values to write to the image line<br>
	 * Original signature : <code>void av_write_image_line(const uint16_t*, uint8_t*[4], const int[4], const AVPixFmtDescriptor*, int, int, int, int)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:168</i>
	 */
	void av_write_image_line(short src[], ByteBuffer data[], int linesize[], AVPixFmtDescriptor desc, int x, int y, int c, int w);
	/**
	 * Utility function to swap the endianness of a pixel format.<br>
	 * @param[in]  pix_fmt the pixel format<br>
	 * @return pixel format with swapped endianness if it exists,<br>
	 * otherwise AV_PIX_FMT_NONE<br>
	 * Original signature : <code>AVPixelFormat av_pix_fmt_swap_endianness(AVPixelFormat)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:176</i>
	 */
	int av_pix_fmt_swap_endianness(int pix_fmt);
	/**
	 * Compute what kind of losses will occur when converting from one specific<br>
	 * pixel format to another.<br>
	 * When converting from one pixel format to another, information loss may occur.<br>
	 * For example, when converting from RGB24 to GRAY, the color information will<br>
	 * be lost. Similarly, other losses occur when converting from some formats to<br>
	 * other formats. These losses can involve loss of chroma, but also loss of<br>
	 * resolution, loss of color depth, loss due to the color space conversion, loss<br>
	 * of the alpha bits or loss due to color quantization.<br>
	 * av_get_fix_fmt_loss() informs you about the various types of losses<br>
	 * which will occur when converting from one pixel format to another.<br>
	 * @param[in] dst_pix_fmt destination pixel format<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @return Combination of flags informing you what kind of losses will occur<br>
	 * (maximum loss for an invalid dst_pix_fmt).<br>
	 * Original signature : <code>int av_get_pix_fmt_loss(AVPixelFormat, AVPixelFormat, int)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:195</i>
	 */
	int av_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt, int has_alpha);
	/**
	 * Compute what kind of losses will occur when converting from one specific<br>
	 * pixel format to another.<br>
	 * When converting from one pixel format to another, information loss may occur.<br>
	 * For example, when converting from RGB24 to GRAY, the color information will<br>
	 * be lost. Similarly, other losses occur when converting from some formats to<br>
	 * other formats. These losses can involve loss of chroma, but also loss of<br>
	 * resolution, loss of color depth, loss due to the color space conversion, loss<br>
	 * of the alpha bits or loss due to color quantization.<br>
	 * av_get_fix_fmt_loss() informs you about the various types of losses<br>
	 * which will occur when converting from one pixel format to another.<br>
	 * @param[in] dst_pix_fmt destination pixel format<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @return Combination of flags informing you what kind of losses will occur<br>
	 * (maximum loss for an invalid dst_pix_fmt).<br>
	 * Original signature : <code>AVPixelFormat av_find_best_pix_fmt_of_2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:214</i><br>
	 * @deprecated use the safer methods {@link #av_find_best_pix_fmt_of_2(int, int, int, int, IntBuffer)} and {@link #av_find_best_pix_fmt_of_2(int, int, int, int, IntByReference)} instead
	 */
	@Deprecated 
	int av_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, IntByReference loss_ptr);
	/**
	 * Compute what kind of losses will occur when converting from one specific<br>
	 * pixel format to another.<br>
	 * When converting from one pixel format to another, information loss may occur.<br>
	 * For example, when converting from RGB24 to GRAY, the color information will<br>
	 * be lost. Similarly, other losses occur when converting from some formats to<br>
	 * other formats. These losses can involve loss of chroma, but also loss of<br>
	 * resolution, loss of color depth, loss due to the color space conversion, loss<br>
	 * of the alpha bits or loss due to color quantization.<br>
	 * av_get_fix_fmt_loss() informs you about the various types of losses<br>
	 * which will occur when converting from one pixel format to another.<br>
	 * @param[in] dst_pix_fmt destination pixel format<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @return Combination of flags informing you what kind of losses will occur<br>
	 * (maximum loss for an invalid dst_pix_fmt).<br>
	 * Original signature : <code>AVPixelFormat av_find_best_pix_fmt_of_2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : libavutil\pixdesc.h:214</i>
	 */
	int av_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, IntBuffer loss_ptr);
	/**
	 * Compute the max pixel step for each plane of an image with a<br>
	 * format described by pixdesc.<br>
	 * The pixel step is the distance in bytes between the first byte of<br>
	 * the group of bytes which describe a pixel component and the first<br>
	 * byte of the successive group in the same plane for the same<br>
	 * component.<br>
	 * @param max_pixsteps an array which is filled with the max pixel step<br>
	 * for each plane. Since a plane may contain different pixel<br>
	 * components, the computed max_pixsteps[plane] is relative to the<br>
	 * component in the plane with the max pixel step.<br>
	 * @param max_pixstep_comps an array which is filled with the component<br>
	 * for each plane which has the max pixel step. May be NULL.<br>
	 * Original signature : <code>void av_image_fill_max_pixsteps(int[4], int[4], const AVPixFmtDescriptor*)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:15</i><br>
	 * @deprecated use the safer methods {@link #av_image_fill_max_pixsteps(IntBuffer, IntBuffer, org.ffmpeg.avutil55.AVPixFmtDescriptor)} and {@link #av_image_fill_max_pixsteps(IntByReference, IntByReference, org.ffmpeg.avutil55.AVPixFmtDescriptor)} instead
	 */
	@Deprecated 
	void av_image_fill_max_pixsteps(IntByReference max_pixsteps, IntByReference max_pixstep_comps, AVPixFmtDescriptor pixdesc);
	/**
	 * Compute the max pixel step for each plane of an image with a<br>
	 * format described by pixdesc.<br>
	 * The pixel step is the distance in bytes between the first byte of<br>
	 * the group of bytes which describe a pixel component and the first<br>
	 * byte of the successive group in the same plane for the same<br>
	 * component.<br>
	 * @param max_pixsteps an array which is filled with the max pixel step<br>
	 * for each plane. Since a plane may contain different pixel<br>
	 * components, the computed max_pixsteps[plane] is relative to the<br>
	 * component in the plane with the max pixel step.<br>
	 * @param max_pixstep_comps an array which is filled with the component<br>
	 * for each plane which has the max pixel step. May be NULL.<br>
	 * Original signature : <code>void av_image_fill_max_pixsteps(int[4], int[4], const AVPixFmtDescriptor*)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:15</i>
	 */
	void av_image_fill_max_pixsteps(IntBuffer max_pixsteps, IntBuffer max_pixstep_comps, AVPixFmtDescriptor pixdesc);
	/**
	 * Compute the size of an image line with format pix_fmt and width<br>
	 * width for the plane plane.<br>
	 * @return the computed size in bytes<br>
	 * Original signature : <code>int av_image_get_linesize(AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:22</i>
	 */
	int av_image_get_linesize(int pix_fmt, int width, int plane);
	/**
	 * Fill plane linesizes for an image with pixel format pix_fmt and<br>
	 * width width.<br>
	 * @param linesizes array to be filled with the linesize for each plane<br>
	 * @return >= 0 in case of success, a negative error code otherwise<br>
	 * Original signature : <code>int av_image_fill_linesizes(int[4], AVPixelFormat, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:30</i><br>
	 * @deprecated use the safer methods {@link #av_image_fill_linesizes(IntBuffer, int, int)} and {@link #av_image_fill_linesizes(IntByReference, int, int)} instead
	 */
	@Deprecated 
	int av_image_fill_linesizes(IntByReference linesizes, int pix_fmt, int width);
	/**
	 * Fill plane linesizes for an image with pixel format pix_fmt and<br>
	 * width width.<br>
	 * @param linesizes array to be filled with the linesize for each plane<br>
	 * @return >= 0 in case of success, a negative error code otherwise<br>
	 * Original signature : <code>int av_image_fill_linesizes(int[4], AVPixelFormat, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:30</i>
	 */
	int av_image_fill_linesizes(IntBuffer linesizes, int pix_fmt, int width);
	/**
	 * Fill plane data pointers for an image with pixel format pix_fmt and<br>
	 * height height.<br>
	 * @param data pointers array to be filled with the pointer for each image plane<br>
	 * @param ptr the pointer to a buffer which will contain the image<br>
	 * @param linesizes the array containing the linesize for each<br>
	 * plane, should be filled by av_image_fill_linesizes()<br>
	 * @return the size in bytes required for the image buffer, a negative<br>
	 * error code in case of failure<br>
	 * Original signature : <code>int av_image_fill_pointers(uint8_t*[4], AVPixelFormat, int, uint8_t*, const int[4])</code><br>
	 * <i>native declaration : libavutil\imgutils.h:42</i><br>
	 * @deprecated use the safer methods {@link #av_image_fill_pointers(ByteBuffer[], int, int, ByteBuffer, int[])} and {@link #av_image_fill_pointers(PointerByReference, int, int, Pointer, IntByReference)} instead
	 */
	@Deprecated 
	int av_image_fill_pointers(PointerByReference data, int pix_fmt, int height, Pointer ptr, IntByReference linesizes);
	/**
	 * Fill plane data pointers for an image with pixel format pix_fmt and<br>
	 * height height.<br>
	 * @param data pointers array to be filled with the pointer for each image plane<br>
	 * @param ptr the pointer to a buffer which will contain the image<br>
	 * @param linesizes the array containing the linesize for each<br>
	 * plane, should be filled by av_image_fill_linesizes()<br>
	 * @return the size in bytes required for the image buffer, a negative<br>
	 * error code in case of failure<br>
	 * Original signature : <code>int av_image_fill_pointers(uint8_t*[4], AVPixelFormat, int, uint8_t*, const int[4])</code><br>
	 * <i>native declaration : libavutil\imgutils.h:42</i>
	 */
	int av_image_fill_pointers(ByteBuffer data[], int pix_fmt, int height, ByteBuffer ptr, int linesizes[]);
	/**
	 * Allocate an image with size w and h and pixel format pix_fmt, and<br>
	 * fill pointers and linesizes accordingly.<br>
	 * The allocated image buffer has to be freed by using<br>
	 * av_freep(&pointers[0]).<br>
	 * @param align the value to use for buffer size alignment<br>
	 * @return the size in bytes required for the image buffer, a negative<br>
	 * error code in case of failure<br>
	 * Original signature : <code>int av_image_alloc(uint8_t*[4], int[4], int, int, AVPixelFormat, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:53</i><br>
	 * @deprecated use the safer methods {@link #av_image_alloc(ByteBuffer[], IntBuffer, int, int, int, int)} and {@link #av_image_alloc(PointerByReference, IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_image_alloc(PointerByReference pointers, IntByReference linesizes, int w, int h, int pix_fmt, int align);
	/**
	 * Allocate an image with size w and h and pixel format pix_fmt, and<br>
	 * fill pointers and linesizes accordingly.<br>
	 * The allocated image buffer has to be freed by using<br>
	 * av_freep(&pointers[0]).<br>
	 * @param align the value to use for buffer size alignment<br>
	 * @return the size in bytes required for the image buffer, a negative<br>
	 * error code in case of failure<br>
	 * Original signature : <code>int av_image_alloc(uint8_t*[4], int[4], int, int, AVPixelFormat, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:53</i>
	 */
	int av_image_alloc(ByteBuffer pointers[], IntBuffer linesizes, int w, int h, int pix_fmt, int align);
	/**
	 * Copy image plane from src to dst.<br>
	 * That is, copy "height" number of lines of "bytewidth" bytes each.<br>
	 * The first byte of each successive line is separated by *_linesize<br>
	 * bytes.<br>
	 * bytewidth must be contained by both absolute values of dst_linesize<br>
	 * and src_linesize, otherwise the function behavior is undefined.<br>
	 * @param dst_linesize linesize for the image plane in dst<br>
	 * @param src_linesize linesize for the image plane in src<br>
	 * Original signature : <code>void av_image_copy_plane(uint8_t*, int, const uint8_t*, int, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:65</i><br>
	 * @deprecated use the safer methods {@link #av_image_copy_plane(ByteBuffer, int, byte[], int, int, int)} and {@link #av_image_copy_plane(Pointer, int, Pointer, int, int, int)} instead
	 */
	@Deprecated 
	void av_image_copy_plane(Pointer dst, int dst_linesize, Pointer src, int src_linesize, int bytewidth, int height);
	/**
	 * Copy image plane from src to dst.<br>
	 * That is, copy "height" number of lines of "bytewidth" bytes each.<br>
	 * The first byte of each successive line is separated by *_linesize<br>
	 * bytes.<br>
	 * bytewidth must be contained by both absolute values of dst_linesize<br>
	 * and src_linesize, otherwise the function behavior is undefined.<br>
	 * @param dst_linesize linesize for the image plane in dst<br>
	 * @param src_linesize linesize for the image plane in src<br>
	 * Original signature : <code>void av_image_copy_plane(uint8_t*, int, const uint8_t*, int, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:65</i>
	 */
	void av_image_copy_plane(ByteBuffer dst, int dst_linesize, byte src[], int src_linesize, int bytewidth, int height);
	/**
	 * Copy image in src_data to dst_data.<br>
	 * @param dst_linesizes linesizes for the image in dst_data<br>
	 * @param src_linesizes linesizes for the image in src_data<br>
	 * Original signature : <code>void av_image_copy(uint8_t*[4], int[4], const uint8_t*[4], const int[4], AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:72</i><br>
	 * @deprecated use the safer methods {@link #av_image_copy(ByteBuffer[], IntBuffer, byte[], int[], int, int, int)} and {@link #av_image_copy(PointerByReference, IntByReference, PointerByReference, IntByReference, int, int, int)} instead
	 */
	@Deprecated 
	void av_image_copy(PointerByReference dst_data, IntByReference dst_linesizes, PointerByReference src_data, IntByReference src_linesizes, int pix_fmt, int width, int height);
	/**
	 * Copy image in src_data to dst_data.<br>
	 * @param dst_linesizes linesizes for the image in dst_data<br>
	 * @param src_linesizes linesizes for the image in src_data<br>
	 * Original signature : <code>void av_image_copy(uint8_t*[4], int[4], const uint8_t*[4], const int[4], AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:72</i>
	 */
	void av_image_copy(ByteBuffer dst_data[], IntBuffer dst_linesizes, byte src_data[], int src_linesizes[], int pix_fmt, int width, int height);
	/**
	 * Copy image data located in uncacheable (e.g. GPU mapped) memory. Where<br>
	 * available, this function will use special functionality for reading from such<br>
	 * memory, which may result in greatly improved performance compared to plain<br>
	 * av_image_copy().<br>
	 * The data pointers and the linesizes must be aligned to the maximum required<br>
	 * by the CPU architecture.<br>
	 * @note The linesize parameters have the type ptrdiff_t here, while they are<br>
	 *       int for av_image_copy().<br>
	 * @note On x86, the linesizes currently need to be aligned to the cacheline<br>
	 *       size (i.e. 64) to get improved performance.<br>
	 * Original signature : <code>void av_image_copy_uc_from(uint8_t*[4], const ptrdiff_t[4], const uint8_t*[4], const ptrdiff_t[4], AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:86</i><br>
	 * @deprecated use the safer methods {@link #av_image_copy_uc_from(ByteBuffer[], NativeSize[], byte[], NativeSize[], int, int, int)} and {@link #av_image_copy_uc_from(PointerByReference, NativeSizeByReference, PointerByReference, NativeSizeByReference, int, int, int)} instead
	 */
	@Deprecated 
	void av_image_copy_uc_from(PointerByReference dst_data, NativeSizeByReference dst_linesizes, PointerByReference src_data, NativeSizeByReference src_linesizes, int pix_fmt, int width, int height);
	/**
	 * Copy image data located in uncacheable (e.g. GPU mapped) memory. Where<br>
	 * available, this function will use special functionality for reading from such<br>
	 * memory, which may result in greatly improved performance compared to plain<br>
	 * av_image_copy().<br>
	 * The data pointers and the linesizes must be aligned to the maximum required<br>
	 * by the CPU architecture.<br>
	 * @note The linesize parameters have the type ptrdiff_t here, while they are<br>
	 *       int for av_image_copy().<br>
	 * @note On x86, the linesizes currently need to be aligned to the cacheline<br>
	 *       size (i.e. 64) to get improved performance.<br>
	 * Original signature : <code>void av_image_copy_uc_from(uint8_t*[4], const ptrdiff_t[4], const uint8_t*[4], const ptrdiff_t[4], AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:86</i>
	 */
	void av_image_copy_uc_from(ByteBuffer dst_data[], NativeSize dst_linesizes[], byte src_data[], NativeSize src_linesizes[], int pix_fmt, int width, int height);
	/**
	 * Setup the data pointers and linesizes based on the specified image<br>
	 * parameters and the provided array.<br>
	 * The fields of the given image are filled in by using the src<br>
	 * address which points to the image data buffer. Depending on the<br>
	 * specified pixel format, one or multiple image data pointers and<br>
	 * line sizes will be set.  If a planar format is specified, several<br>
	 * pointers will be set pointing to the different picture planes and<br>
	 * the line sizes of the different planes will be stored in the<br>
	 * lines_sizes array. Call with src == NULL to get the required<br>
	 * size for the src buffer.<br>
	 * To allocate the buffer and fill in the dst_data and dst_linesize in<br>
	 * one call, use av_image_alloc().<br>
	 * @param dst_data      data pointers to be filled in<br>
	 * @param dst_linesizes linesizes for the image in dst_data to be filled in<br>
	 * @param src           buffer which will contain or contains the actual image data, can be NULL<br>
	 * @param pix_fmt       the pixel format of the image<br>
	 * @param width         the width of the image in pixels<br>
	 * @param height        the height of the image in pixels<br>
	 * @param align         the value used in src for linesize alignment<br>
	 * @return the size in bytes required for src, a negative error code<br>
	 * in case of failure<br>
	 * Original signature : <code>int av_image_fill_arrays(uint8_t*[4], int[4], const uint8_t*, AVPixelFormat, int, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:111</i><br>
	 * @deprecated use the safer methods {@link #av_image_fill_arrays(ByteBuffer[], IntBuffer, byte[], int, int, int, int)} and {@link #av_image_fill_arrays(PointerByReference, IntByReference, Pointer, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_image_fill_arrays(PointerByReference dst_data, IntByReference dst_linesize, Pointer src, int pix_fmt, int width, int height, int align);
	/**
	 * Setup the data pointers and linesizes based on the specified image<br>
	 * parameters and the provided array.<br>
	 * The fields of the given image are filled in by using the src<br>
	 * address which points to the image data buffer. Depending on the<br>
	 * specified pixel format, one or multiple image data pointers and<br>
	 * line sizes will be set.  If a planar format is specified, several<br>
	 * pointers will be set pointing to the different picture planes and<br>
	 * the line sizes of the different planes will be stored in the<br>
	 * lines_sizes array. Call with src == NULL to get the required<br>
	 * size for the src buffer.<br>
	 * To allocate the buffer and fill in the dst_data and dst_linesize in<br>
	 * one call, use av_image_alloc().<br>
	 * @param dst_data      data pointers to be filled in<br>
	 * @param dst_linesizes linesizes for the image in dst_data to be filled in<br>
	 * @param src           buffer which will contain or contains the actual image data, can be NULL<br>
	 * @param pix_fmt       the pixel format of the image<br>
	 * @param width         the width of the image in pixels<br>
	 * @param height        the height of the image in pixels<br>
	 * @param align         the value used in src for linesize alignment<br>
	 * @return the size in bytes required for src, a negative error code<br>
	 * in case of failure<br>
	 * Original signature : <code>int av_image_fill_arrays(uint8_t*[4], int[4], const uint8_t*, AVPixelFormat, int, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:111</i>
	 */
	int av_image_fill_arrays(ByteBuffer dst_data[], IntBuffer dst_linesize, byte src[], int pix_fmt, int width, int height, int align);
	/**
	 * Return the size in bytes of the amount of data required to store an<br>
	 * image with the given parameters.<br>
	 * @param[in] align the assumed linesize alignment<br>
	 * Original signature : <code>int av_image_get_buffer_size(AVPixelFormat, int, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:118</i>
	 */
	int av_image_get_buffer_size(int pix_fmt, int width, int height, int align);
	/**
	 * Copy image data from an image into a buffer.<br>
	 * av_image_get_buffer_size() can be used to compute the required size<br>
	 * for the buffer to fill.<br>
	 * @param dst           a buffer into which picture data will be copied<br>
	 * @param dst_size      the size in bytes of dst<br>
	 * @param src_data      pointers containing the source image data<br>
	 * @param src_linesizes linesizes for the image in src_data<br>
	 * @param pix_fmt       the pixel format of the source image<br>
	 * @param width         the width of the source image in pixels<br>
	 * @param height        the height of the source image in pixels<br>
	 * @param align         the assumed linesize alignment for dst<br>
	 * @return the number of bytes written to dst, or a negative value<br>
	 * (error code) on error<br>
	 * Original signature : <code>int av_image_copy_to_buffer(uint8_t*, int, const const uint8_t*[4], const int[4], AVPixelFormat, int, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:135</i><br>
	 * @deprecated use the safer methods {@link #av_image_copy_to_buffer(ByteBuffer, int, byte[][], int[], int, int, int, int)} and {@link #av_image_copy_to_buffer(Pointer, int, PointerByReference, IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_image_copy_to_buffer(Pointer dst, int dst_size, PointerByReference src_data, IntByReference src_linesize, int pix_fmt, int width, int height, int align);
	/**
	 * Copy image data from an image into a buffer.<br>
	 * av_image_get_buffer_size() can be used to compute the required size<br>
	 * for the buffer to fill.<br>
	 * @param dst           a buffer into which picture data will be copied<br>
	 * @param dst_size      the size in bytes of dst<br>
	 * @param src_data      pointers containing the source image data<br>
	 * @param src_linesizes linesizes for the image in src_data<br>
	 * @param pix_fmt       the pixel format of the source image<br>
	 * @param width         the width of the source image in pixels<br>
	 * @param height        the height of the source image in pixels<br>
	 * @param align         the assumed linesize alignment for dst<br>
	 * @return the number of bytes written to dst, or a negative value<br>
	 * (error code) on error<br>
	 * Original signature : <code>int av_image_copy_to_buffer(uint8_t*, int, const const uint8_t*[4], const int[4], AVPixelFormat, int, int, int)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:135</i>
	 */
	int av_image_copy_to_buffer(ByteBuffer dst, int dst_size, byte[] src_data[], int src_linesize[], int pix_fmt, int width, int height, int align);
	/**
	 * Check if the given dimension of an image is valid, meaning that all<br>
	 * bytes of the image can be addressed with a signed int.<br>
	 * @param w the width of the picture<br>
	 * @param h the height of the picture<br>
	 * @param log_offset the offset to sum to the log level for logging with log_ctx<br>
	 * @param log_ctx the parent logging context, it may be NULL<br>
	 * @return >= 0 if valid, a negative error code otherwise<br>
	 * Original signature : <code>int av_image_check_size(unsigned int, unsigned int, int, void*)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:146</i>
	 */
	int av_image_check_size(int w, int h, int log_offset, Pointer log_ctx);
	/**
	 * Check if the given dimension of an image is valid, meaning that all<br>
	 * bytes of a plane of an image with the specified pix_fmt can be addressed<br>
	 * with a signed int.<br>
	 * @param w the width of the picture<br>
	 * @param h the height of the picture<br>
	 * @param max_pixels the maximum number of pixels the user wants to accept<br>
	 * @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown.<br>
	 * @param log_offset the offset to sum to the log level for logging with log_ctx<br>
	 * @param log_ctx the parent logging context, it may be NULL<br>
	 * @return >= 0 if valid, a negative error code otherwise<br>
	 * Original signature : <code>int av_image_check_size2(unsigned int, unsigned int, int64_t, AVPixelFormat, int, void*)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:160</i>
	 */
	int av_image_check_size2(int w, int h, long max_pixels, int pix_fmt, int log_offset, Pointer log_ctx);
	/**
	 * Check if the given sample aspect ratio of an image is valid.<br>
	 * It is considered invalid if the denominator is 0 or if applying the ratio<br>
	 * to the image size would make the smaller dimension less than 1. If the<br>
	 * sar numerator is 0, it is considered unknown and will return as valid.<br>
	 * @param w width of the image<br>
	 * @param h height of the image<br>
	 * @param sar sample aspect ratio of the image<br>
	 * @return 0 if valid, a negative AVERROR code otherwise<br>
	 * Original signature : <code>int av_image_check_sar(unsigned int, unsigned int, AVRational)</code><br>
	 * <i>native declaration : libavutil\imgutils.h:172</i>
	 */
	int av_image_check_sar(int w, int h, AVRational.ByValue sar);
	/**
	 * Allocate a AVSphericalVideo structure and initialize its fields to default<br>
	 * values.<br>
	 * @return the newly allocated struct or NULL on failure<br>
	 * Original signature : <code>AVSphericalMapping* av_spherical_alloc(size_t*)</code><br>
	 * <i>native declaration : libavutil\spherical.h:38</i>
	 */
	AVSphericalMapping av_spherical_alloc(NativeSizeByReference size);
	/**
	 * Convert the @ref bounding fields from an AVSphericalVideo<br>
	 * from 0.32 fixed point to pixels.<br>
	 * @param map    The AVSphericalVideo map to read bound values from.<br>
	 * @param width  Width of the current frame or stream.<br>
	 * @param height Height of the current frame or stream.<br>
	 * @param left   Pixels from the left edge.<br>
	 * @param top    Pixels from the top edge.<br>
	 * @param right  Pixels from the right edge.<br>
	 * @param bottom Pixels from the bottom edge.<br>
	 * Original signature : <code>void av_spherical_tile_bounds(const AVSphericalMapping*, size_t, size_t, size_t*, size_t*, size_t*, size_t*)</code><br>
	 * <i>native declaration : libavutil\spherical.h:51</i>
	 */
	void av_spherical_tile_bounds(AVSphericalMapping map, NativeSize width, NativeSize height, NativeSizeByReference left, NativeSizeByReference top, NativeSizeByReference right, NativeSizeByReference bottom);
	/**
	 * Provide a human-readable name of a given AVSphericalProjection.<br>
	 * @param projection The input AVSphericalProjection.<br>
	 * @return The name of the AVSphericalProjection, or "unknown".<br>
	 * Original signature : <code>char* av_spherical_projection_name(AVSphericalProjection)</code><br>
	 * <i>native declaration : libavutil\spherical.h:58</i>
	 */
	String av_spherical_projection_name(int projection);
	/**
	 * Get the AVSphericalProjection form a human-readable name.<br>
	 * @param name The input string.<br>
	 * @return The AVSphericalProjection value, or -1 if not found.<br>
	 * Original signature : <code>int av_spherical_from_name(const char*)</code><br>
	 * <i>native declaration : libavutil\spherical.h:65</i><br>
	 * @deprecated use the safer methods {@link #av_spherical_from_name(String)} and {@link #av_spherical_from_name(Pointer)} instead
	 */
	@Deprecated 
	int av_spherical_from_name(Pointer name);
	/**
	 * Get the AVSphericalProjection form a human-readable name.<br>
	 * @param name The input string.<br>
	 * @return The AVSphericalProjection value, or -1 if not found.<br>
	 * Original signature : <code>int av_spherical_from_name(const char*)</code><br>
	 * <i>native declaration : libavutil\spherical.h:65</i>
	 */
	int av_spherical_from_name(String name);
	/**
	 * Return the flags which specify extensions supported by the CPU.<br>
	 * The returned value is affected by av_force_cpu_flags() if that was used<br>
	 * before. So av_get_cpu_flags() can easily be used in an application to<br>
	 * detect the enabled cpu flags.<br>
	 * Original signature : <code>int av_get_cpu_flags()</code><br>
	 * <i>native declaration : .\libavutil\cpu.h:7</i>
	 */
	int av_get_cpu_flags();
	/**
	 * Disables cpu detection and forces the specified flags.<br>
	 * -1 is a special case that disables forcing of specific flags.<br>
	 * Original signature : <code>void av_force_cpu_flags(int)</code><br>
	 * <i>native declaration : .\libavutil\cpu.h:13</i>
	 */
	void av_force_cpu_flags(int flags);
	/**
	 * Set a mask on flags returned by av_get_cpu_flags().<br>
	 * This function is mainly useful for testing.<br>
	 * Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible<br>
	 * Original signature : <code>void av_set_cpu_flags_mask(int)</code><br>
	 * <i>native declaration : .\libavutil\cpu.h:20</i>
	 */
	void av_set_cpu_flags_mask(int mask);
	/**
	 * Parse CPU flags from a string.<br>
	 * The returned flags contain the specified flags as well as related unspecified flags.<br>
	 * This function exists only for compatibility with libav.<br>
	 * Please use av_parse_cpu_caps() when possible.<br>
	 * @return a combination of AV_CPU_* flags, negative on error.<br>
	 * Original signature : <code>int av_parse_cpu_flags(const char*)</code><br>
	 * <i>native declaration : .\libavutil\cpu.h:29</i><br>
	 * @deprecated use the safer methods {@link #av_parse_cpu_flags(String)} and {@link #av_parse_cpu_flags(Pointer)} instead
	 */
	@Deprecated 
	int av_parse_cpu_flags(Pointer s);
	/**
	 * Parse CPU flags from a string.<br>
	 * The returned flags contain the specified flags as well as related unspecified flags.<br>
	 * This function exists only for compatibility with libav.<br>
	 * Please use av_parse_cpu_caps() when possible.<br>
	 * @return a combination of AV_CPU_* flags, negative on error.<br>
	 * Original signature : <code>int av_parse_cpu_flags(const char*)</code><br>
	 * <i>native declaration : .\libavutil\cpu.h:29</i>
	 */
	int av_parse_cpu_flags(String s);
	/**
	 * Parse CPU caps from a string and update the given AV_CPU_* flags based on that.<br>
	 * @return negative on error.<br>
	 * Original signature : <code>int av_parse_cpu_caps(unsigned*, const char*)</code><br>
	 * <i>native declaration : .\libavutil\cpu.h:35</i><br>
	 * @deprecated use the safer methods {@link #av_parse_cpu_caps(IntBuffer, String)} and {@link #av_parse_cpu_caps(IntByReference, Pointer)} instead
	 */
	@Deprecated 
	int av_parse_cpu_caps(IntByReference flags, Pointer s);
	/**
	 * Parse CPU caps from a string and update the given AV_CPU_* flags based on that.<br>
	 * @return negative on error.<br>
	 * Original signature : <code>int av_parse_cpu_caps(unsigned*, const char*)</code><br>
	 * <i>native declaration : .\libavutil\cpu.h:35</i>
	 */
	int av_parse_cpu_caps(IntBuffer flags, String s);
	/**
	 * @return the number of logical CPU cores present.<br>
	 * Original signature : <code>int av_cpu_count()</code><br>
	 * <i>native declaration : .\libavutil\cpu.h:40</i>
	 */
	int av_cpu_count();
	/**
	 * Return a channel layout id that matches name, or 0 if no match is found.<br>
	 * name can be one or several of the following notations,<br>
	 * separated by '+' or '|':<br>
	 * - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,<br>
	 *   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);<br>
	 * - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,<br>
	 *   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);<br>
	 * - a number of channels, in decimal, followed by 'c', yielding<br>
	 *   the default channel layout for that number of channels (@see<br>
	 *   av_get_default_channel_layout);<br>
	 * - a channel layout mask, in hexadecimal starting with "0x" (see the<br>
	 *   AV_CH_* macros).<br>
	 * Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"<br>
	 * Original signature : <code>uint64_t av_get_channel_layout(const char*)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:31</i><br>
	 * @deprecated use the safer methods {@link #av_get_channel_layout(String)} and {@link #av_get_channel_layout(Pointer)} instead
	 */
	@Deprecated 
	long av_get_channel_layout(Pointer name);
	/**
	 * Return a channel layout id that matches name, or 0 if no match is found.<br>
	 * name can be one or several of the following notations,<br>
	 * separated by '+' or '|':<br>
	 * - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,<br>
	 *   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);<br>
	 * - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,<br>
	 *   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);<br>
	 * - a number of channels, in decimal, followed by 'c', yielding<br>
	 *   the default channel layout for that number of channels (@see<br>
	 *   av_get_default_channel_layout);<br>
	 * - a channel layout mask, in hexadecimal starting with "0x" (see the<br>
	 *   AV_CH_* macros).<br>
	 * Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"<br>
	 * Original signature : <code>uint64_t av_get_channel_layout(const char*)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:31</i>
	 */
	long av_get_channel_layout(String name);
	/**
	 * Return a channel layout and the number of channels based on the specified name.<br>
	 * This function is similar to (@see av_get_channel_layout), but can also parse<br>
	 * unknown channel layout specifications.<br>
	 * @param[in]  name             channel layout specification string<br>
	 * @param[out] channel_layout   parsed channel layout (0 if unknown)<br>
	 * @param[out] nb_channels      number of channels<br>
	 * @return 0 on success, AVERROR(EINVAL) if the parsing fails.<br>
	 * Original signature : <code>int av_get_extended_channel_layout(const char*, uint64_t*, int*)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:42</i><br>
	 * @deprecated use the safer methods {@link #av_get_extended_channel_layout(String, LongBuffer, IntBuffer)} and {@link #av_get_extended_channel_layout(Pointer, LongByReference, IntByReference)} instead
	 */
	@Deprecated 
	int av_get_extended_channel_layout(Pointer name, LongByReference channel_layout, IntByReference nb_channels);
	/**
	 * Return a channel layout and the number of channels based on the specified name.<br>
	 * This function is similar to (@see av_get_channel_layout), but can also parse<br>
	 * unknown channel layout specifications.<br>
	 * @param[in]  name             channel layout specification string<br>
	 * @param[out] channel_layout   parsed channel layout (0 if unknown)<br>
	 * @param[out] nb_channels      number of channels<br>
	 * @return 0 on success, AVERROR(EINVAL) if the parsing fails.<br>
	 * Original signature : <code>int av_get_extended_channel_layout(const char*, uint64_t*, int*)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:42</i>
	 */
	int av_get_extended_channel_layout(String name, LongBuffer channel_layout, IntBuffer nb_channels);
	/**
	 * Return a description of a channel layout.<br>
	 * If nb_channels is <= 0, it is guessed from the channel_layout.<br>
	 * @param buf put here the string containing the channel layout<br>
	 * @param buf_size size in bytes of the buffer<br>
	 * Original signature : <code>void av_get_channel_layout_string(char*, int, int, uint64_t)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:50</i><br>
	 * @deprecated use the safer methods {@link #av_get_channel_layout_string(ByteBuffer, int, int, long)} and {@link #av_get_channel_layout_string(Pointer, int, int, long)} instead
	 */
	@Deprecated 
	void av_get_channel_layout_string(Pointer buf, int buf_size, int nb_channels, long channel_layout);
	/**
	 * Return a description of a channel layout.<br>
	 * If nb_channels is <= 0, it is guessed from the channel_layout.<br>
	 * @param buf put here the string containing the channel layout<br>
	 * @param buf_size size in bytes of the buffer<br>
	 * Original signature : <code>void av_get_channel_layout_string(char*, int, int, uint64_t)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:50</i>
	 */
	void av_get_channel_layout_string(ByteBuffer buf, int buf_size, int nb_channels, long channel_layout);
	/**
	 * Append a description of a channel layout to a bprint buffer.<br>
	 * Original signature : <code>void av_bprint_channel_layout(AVBPrint*, int, uint64_t)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:56</i>
	 */
	void av_bprint_channel_layout(AVBPrint bp, int nb_channels, long channel_layout);
	/**
	 * Return the number of channels in the channel layout.<br>
	 * Original signature : <code>int av_get_channel_layout_nb_channels(uint64_t)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:61</i>
	 */
	int av_get_channel_layout_nb_channels(long channel_layout);
	/**
	 * Return default channel layout for a given number of channels.<br>
	 * Original signature : <code>int64_t av_get_default_channel_layout(int)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:66</i>
	 */
	long av_get_default_channel_layout(int nb_channels);
	/**
	 * Get the index of a channel in channel_layout.<br>
	 * @param channel a channel layout describing exactly one channel which must be<br>
	 *                present in channel_layout.<br>
	 * @return index of channel in channel_layout on success, a negative AVERROR<br>
	 *         on error.<br>
	 * Original signature : <code>int av_get_channel_layout_channel_index(uint64_t, uint64_t)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:75</i>
	 */
	int av_get_channel_layout_channel_index(long channel_layout, long channel);
	/**
	 * Get the channel with the given index in channel_layout.<br>
	 * Original signature : <code>uint64_t av_channel_layout_extract_channel(uint64_t, int)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:80</i>
	 */
	long av_channel_layout_extract_channel(long channel_layout, int index);
	/**
	 * Get the name of a given channel.<br>
	 * @return channel name on success, NULL on error.<br>
	 * Original signature : <code>char* av_get_channel_name(uint64_t)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:86</i>
	 */
	String av_get_channel_name(long channel);
	/**
	 * Get the description of a given channel.<br>
	 * @param channel  a channel layout with a single channel<br>
	 * @return  channel description on success, NULL on error<br>
	 * Original signature : <code>char* av_get_channel_description(uint64_t)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:93</i>
	 */
	String av_get_channel_description(long channel);
	/**
	 * Get the value and name of a standard channel layout.<br>
	 * @param[in]  index   index in an internal list, starting at 0<br>
	 * @param[out] layout  channel layout mask<br>
	 * @param[out] name    name of the layout<br>
	 * @return  0  if the layout exists,<br>
	 *          <0 if index is beyond the limits<br>
	 * Original signature : <code>int av_get_standard_channel_layout(unsigned, uint64_t*, const char**)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:103</i><br>
	 * @deprecated use the safer methods {@link #av_get_standard_channel_layout(int, LongBuffer, String[])} and {@link #av_get_standard_channel_layout(int, LongByReference, PointerByReference)} instead
	 */
	@Deprecated 
	int av_get_standard_channel_layout(int index, LongByReference layout, PointerByReference name);
	/**
	 * Get the value and name of a standard channel layout.<br>
	 * @param[in]  index   index in an internal list, starting at 0<br>
	 * @param[out] layout  channel layout mask<br>
	 * @param[out] name    name of the layout<br>
	 * @return  0  if the layout exists,<br>
	 *          <0 if index is beyond the limits<br>
	 * Original signature : <code>int av_get_standard_channel_layout(unsigned, uint64_t*, const char**)</code><br>
	 * <i>native declaration : .\libavutil\channel_layout.h:103</i>
	 */
	int av_get_standard_channel_layout(int index, LongBuffer layout, String name[]);
}
