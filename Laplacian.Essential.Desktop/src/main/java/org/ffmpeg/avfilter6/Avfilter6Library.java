package org.ffmpeg.avfilter6;
import com.sun.jna.*;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import org.ffmpeg.avutil55.AVBufferRef;
import org.ffmpeg.avutil55.AVFrame;
import org.ffmpeg.avutil55.AVRational.ByValue;

import java.nio.ByteBuffer;
/**
 * JNA Wrapper for library <b>avfilter-6</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Avfilter6Library extends Library {
	public static final String JNA_LIBRARY_NAME = "avfilter-6";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(Avfilter6Library.JNA_LIBRARY_NAME);
	public static final Avfilter6Library INSTANCE = (Avfilter6Library)Native.loadLibrary(Avfilter6Library.JNA_LIBRARY_NAME, Avfilter6Library.class);
	/** < all automatic conversions enabled */
	public static final int AVFILTER_AUTO_CONVERT_ALL = 0;
	/** < all automatic conversions disabled */
	public static final int AVFILTER_AUTO_CONVERT_NONE = -1;
	public static final int AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1;
	public static final int AV_BUFFERSRC_FLAG_PUSH = 4;
	public static final int AV_BUFFERSRC_FLAG_KEEP_REF = 8;
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil\rational.h:0</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final int LIBAVFILTER_VERSION_MAJOR = (int)6;
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final int LIBAVFILTER_VERSION_MINOR = (int)82;
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final int LIBAVFILTER_VERSION_MICRO = (int)100;
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final int LIBAVFILTER_VERSION_INT = (int)((6) << 16 | (82) << 8 | (100));
	/**
	 * define<br>
	 * Conversion Error : 6.82.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : .\libavfilter\version.h:0</i><br>
	 * 6.82.
	 */
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final int LIBAVFILTER_BUILD = (int)((6) << 16 | (82) << 8 | (100));
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final String LIBAVFILTER_IDENT = (String)"Lavfi6.82.100";
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final boolean FF_API_OLD_FILTER_OPTS = (boolean)(6 < 7);
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final boolean FF_API_OLD_FILTER_OPTS_ERROR = (boolean)(6 < 7);
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final boolean FF_API_AVFILTER_OPEN = (boolean)(6 < 7);
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final boolean FF_API_AVFILTER_INIT_FILTER = (boolean)(6 < 7);
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final boolean FF_API_OLD_FILTER_REGISTER = (boolean)(6 < 7);
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final boolean FF_API_NOCONST_GET_NAME = (boolean)(6 < 7);
	/** <i>native declaration : .\libavfilter\version.h</i> */
	public static final boolean FF_API_LAVR_OPTS = (boolean)(6 < 7);
	/** <i>native declaration : libavfilter\avfilter.h</i> */
	public static final int AVFILTER_FLAG_DYNAMIC_INPUTS = (int)(1 << 0);
	/** <i>native declaration : libavfilter\avfilter.h</i> */
	public static final int AVFILTER_FLAG_DYNAMIC_OUTPUTS = (int)(1 << 1);
	/** <i>native declaration : libavfilter\avfilter.h</i> */
	public static final int AVFILTER_FLAG_SLICE_THREADS = (int)(1 << 2);
	/** <i>native declaration : libavfilter\avfilter.h</i> */
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = (int)(1 << 16);
	/** <i>native declaration : libavfilter\avfilter.h</i> */
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = (int)(1 << 17);
	/** <i>native declaration : libavfilter\avfilter.h</i> */
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE = (int)((1 << 16) | (1 << 17));
	/** <i>native declaration : libavfilter\avfilter.h</i> */
	public static final int AVFILTER_THREAD_SLICE = (int)(1 << 0);
	/** <i>native declaration : libavfilter\avfilter.h</i> */
	public static final int AVFILTER_CMD_FLAG_ONE = (int)1;
	/** <i>native declaration : libavfilter\avfilter.h</i> */
	public static final int AVFILTER_CMD_FLAG_FAST = (int)2;
	/** <i>native declaration : libavfilter\buffersink.h</i> */
	public static final int AV_BUFFERSINK_FLAG_PEEK = (int)1;
	/** <i>native declaration : libavfilter\buffersink.h</i> */
	public static final int AV_BUFFERSINK_FLAG_NO_REQUEST = (int)2;
	/**
	 * A function pointer passed to the @ref AVFilterGraph.execute callback to be<br>
	 * executed multiple times, possibly in parallel.<br>
	 * * @param ctx the filter context the job belongs to<br>
	 * @param arg an opaque parameter passed through from @ref<br>
	 *            AVFilterGraph.execute<br>
	 * @param jobnr the index of the job being executed<br>
	 * @param nb_jobs the total number of jobs<br>
	 * * @return 0 on success, a negative AVERROR on error<br>
	 * <i>native declaration : libavfilter\avfilter.h:364</i>
	 */
	public interface avfilter_action_func extends Callback {
		int apply(AVFilterContext ctx, Pointer arg, int jobnr, int nb_jobs);
	};
	/**
	 * A function executing multiple jobs, possibly in parallel.<br>
	 * * @param ctx the filter context to which the jobs belong<br>
	 * @param func the function to be called multiple times<br>
	 * @param arg the argument to be passed to func<br>
	 * @param ret a nb_jobs-sized array to be filled with return values from each<br>
	 *            invocation of func<br>
	 * @param nb_jobs the number of jobs to execute<br>
	 * * @return 0 on success, a negative AVERROR on error<br>
	 * <i>native declaration : libavfilter\avfilter.h:375</i>
	 */
	public interface avfilter_execute_func extends Callback {
		int apply(AVFilterContext ctx, avfilter_action_func func, Pointer arg, IntByReference ret, int nb_jobs);
	};
	/**
	 * Return the LIBAVFILTER_VERSION_INT constant.<br>
	 * Original signature : <code>int avfilter_version()</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:4</i>
	 */
	int avfilter_version();
	/**
	 * Return the libavfilter build-time configuration.<br>
	 * Original signature : <code>char* avfilter_configuration()</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:9</i>
	 */
	String avfilter_configuration();
	/**
	 * Return the libavfilter license.<br>
	 * Original signature : <code>char* avfilter_license()</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:14</i>
	 */
	String avfilter_license();
	/**
	 * Get the number of elements in a NULL-terminated array of AVFilterPads (e.g.<br>
	 * AVFilter.inputs/outputs).<br>
	 * Original signature : <code>int avfilter_pad_count(const AVFilterPad*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:32</i>
	 */
	int avfilter_pad_count(AVFilterPad pads);
	/**
	 * Get the name of an AVFilterPad.<br>
	 * @param pads an array of AVFilterPads<br>
	 * @param pad_idx index of the pad in the array it; is the caller's<br>
	 *                responsibility to ensure the index is valid<br>
	 * @return name of the pad_idx'th pad in pads<br>
	 * Original signature : <code>char* avfilter_pad_get_name(const AVFilterPad*, int)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:41</i>
	 */
	String avfilter_pad_get_name(AVFilterPad pads, int pad_idx);
	/**
	 * Get the type of an AVFilterPad.<br>
	 * @param pads an array of AVFilterPads<br>
	 * @param pad_idx index of the pad in the array; it is the caller's<br>
	 *                responsibility to ensure the index is valid<br>
	 * @return type of the pad_idx'th pad in pads<br>
	 * Original signature : <code>AVMediaType avfilter_pad_get_type(const AVFilterPad*, int)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:50</i>
	 */
	int avfilter_pad_get_type(AVFilterPad pads, int pad_idx);
	/**
	 * Link two filters together.<br>
	 * @param src    the source filter<br>
	 * @param srcpad index of the output pad on the source filter<br>
	 * @param dst    the destination filter<br>
	 * @param dstpad index of the input pad on the destination filter<br>
	 * @return       zero on success<br>
	 * Original signature : <code>int avfilter_link(AVFilterContext*, unsigned, AVFilterContext*, unsigned)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:199</i>
	 */
	int avfilter_link(AVFilterContext src, int srcpad, AVFilterContext dst, int dstpad);
	/**
	 * Free the link in *link, and set its pointer to NULL.<br>
	 * Original signature : <code>void avfilter_link_free(AVFilterLink**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:204</i><br>
	 * @deprecated use the safer method {@link #avfilter_link_free(org.ffmpeg.avfilter6.AVFilterLink.ByReference[])} instead
	 */
	@Deprecated 
	void avfilter_link_free(PointerByReference link);
	/**
	 * Free the link in *link, and set its pointer to NULL.<br>
	 * Original signature : <code>void avfilter_link_free(AVFilterLink**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:204</i>
	 */
	void avfilter_link_free(AVFilterLink.ByReference link[]);
	/**
	 * Get the number of channels of a link.<br>
	 * Original signature : <code>int avfilter_link_get_channels(AVFilterLink*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:209</i>
	 */
	int avfilter_link_get_channels(AVFilterLink link);
	/**
	 * Set the closed field of a link.<br>
	 * @deprecated applications are not supposed to mess with links, they should<br>
	 * close the sinks.<br>
	 * Original signature : <code>void avfilter_link_set_closed(AVFilterLink*, int)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:216</i>
	 */
	void avfilter_link_set_closed(AVFilterLink link, int closed);
	/**
	 * Negotiate the media format, dimensions, etc of all inputs to a filter.<br>
	 * @param filter the filter to negotiate the properties for its inputs<br>
	 * @return       zero on successful negotiation<br>
	 * Original signature : <code>int avfilter_config_links(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:223</i>
	 */
	int avfilter_config_links(AVFilterContext filter);
	/**
	 * Make the filter instance process a command.<br>
	 * It is recommended to use avfilter_graph_send_command().<br>
	 * Original signature : <code>int avfilter_process_command(AVFilterContext*, const char*, const char*, char*, int, int)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:229</i><br>
	 * @deprecated use the safer methods {@link #avfilter_process_command(org.ffmpeg.avfilter6.AVFilterContext, String, String, ByteBuffer, int, int)} and {@link #avfilter_process_command(org.ffmpeg.avfilter6.AVFilterContext, Pointer, Pointer, Pointer, int, int)} instead
	 */
	@Deprecated 
	int avfilter_process_command(AVFilterContext filter, Pointer cmd, Pointer arg, Pointer res, int res_len, int flags);
	/**
	 * Make the filter instance process a command.<br>
	 * It is recommended to use avfilter_graph_send_command().<br>
	 * Original signature : <code>int avfilter_process_command(AVFilterContext*, const char*, const char*, char*, int, int)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:229</i>
	 */
	int avfilter_process_command(AVFilterContext filter, String cmd, String arg, ByteBuffer res, int res_len, int flags);
	/**
	 * Initialize the filter system. Register all builtin filters.<br>
	 * Original signature : <code>void avfilter_register_all()</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:234</i>
	 */
	void avfilter_register_all();
	/**
	 * Uninitialize the filter system. Unregister all filters.<br>
	 * Original signature : <code>void avfilter_uninit()</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:239</i>
	 */
	void avfilter_uninit();
	/**
	 * Register a filter. This is only needed if you plan to use<br>
	 * avfilter_get_by_name later to lookup the AVFilter structure by name. A<br>
	 * filter can still by instantiated with avfilter_graph_alloc_filter even if it<br>
	 * is not registered.<br>
	 * @param filter the filter to register<br>
	 * @return 0 if the registration was successful, a negative value<br>
	 * otherwise<br>
	 * Original signature : <code>int avfilter_register(AVFilter*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:250</i>
	 */
	int avfilter_register(AVFilter filter);
	/**
	 * Get a filter definition matching the given name.<br>
	 * @param name the filter name to find<br>
	 * @return     the filter definition, if any matching one is registered.<br>
	 *             NULL if none found.<br>
	 * Original signature : <code>AVFilter* avfilter_get_by_name(const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:258</i><br>
	 * @deprecated use the safer methods {@link #avfilter_get_by_name(String)} and {@link #avfilter_get_by_name(Pointer)} instead
	 */
	@Deprecated 
	AVFilter avfilter_get_by_name(Pointer name);
	/**
	 * Get a filter definition matching the given name.<br>
	 * @param name the filter name to find<br>
	 * @return     the filter definition, if any matching one is registered.<br>
	 *             NULL if none found.<br>
	 * Original signature : <code>AVFilter* avfilter_get_by_name(const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:258</i>
	 */
	AVFilter avfilter_get_by_name(String name);
	/**
	 * Iterate over all registered filters.<br>
	 * @return If prev is non-NULL, next registered filter after prev or NULL if<br>
	 * prev is the last filter. If prev is NULL, return the first registered filter.<br>
	 * Original signature : <code>AVFilter* avfilter_next(const AVFilter*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:265</i>
	 */
	AVFilter avfilter_next(AVFilter prev);
	/**
	 * If filter is NULL, returns a pointer to the first registered filter pointer,<br>
	 * if filter is non-NULL, returns the next pointer after filter.<br>
	 * If the returned pointer points to NULL, the last registered filter<br>
	 * was already reached.<br>
	 * @deprecated use avfilter_next()<br>
	 * Original signature : <code>AVFilter** av_filter_next(AVFilter**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:274</i><br>
	 * @deprecated use the safer method {@link #av_filter_next(org.ffmpeg.avfilter6.AVFilter.ByReference[])} instead
	 */
	@Deprecated 
	AVFilter.ByReference[] av_filter_next(PointerByReference filter);
	/**
	 * If filter is NULL, returns a pointer to the first registered filter pointer,<br>
	 * if filter is non-NULL, returns the next pointer after filter.<br>
	 * If the returned pointer points to NULL, the last registered filter<br>
	 * was already reached.<br>
	 * @deprecated use avfilter_next()<br>
	 * Original signature : <code>AVFilter** av_filter_next(AVFilter**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:274</i>
	 */
	AVFilter.ByReference[] av_filter_next(AVFilter.ByReference filter[]);
	/**
	 * Create a filter instance.<br>
	 * @param filter_ctx put here a pointer to the created filter context<br>
	 * on success, NULL on failure<br>
	 * @param filter    the filter to create an instance of<br>
	 * @param inst_name Name to give to the new instance. Can be NULL for none.<br>
	 * @return >= 0 in case of success, a negative error code otherwise<br>
	 * @deprecated use avfilter_graph_alloc_filter() instead<br>
	 * Original signature : <code>int avfilter_open(AVFilterContext**, AVFilter*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:285</i><br>
	 * @deprecated use the safer methods {@link #avfilter_open(org.ffmpeg.avfilter6.AVFilterContext.ByReference[], org.ffmpeg.avfilter6.AVFilter, String)} and {@link #avfilter_open(org.ffmpeg.avfilter6.AVFilterContext.ByReference[], org.ffmpeg.avfilter6.AVFilter, Pointer)} instead
	 */
	@Deprecated 
	int avfilter_open(PointerByReference filter_ctx, AVFilter filter, Pointer inst_name);
	/**
	 * Create a filter instance.<br>
	 * @param filter_ctx put here a pointer to the created filter context<br>
	 * on success, NULL on failure<br>
	 * @param filter    the filter to create an instance of<br>
	 * @param inst_name Name to give to the new instance. Can be NULL for none.<br>
	 * @return >= 0 in case of success, a negative error code otherwise<br>
	 * @deprecated use avfilter_graph_alloc_filter() instead<br>
	 * Original signature : <code>int avfilter_open(AVFilterContext**, AVFilter*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:285</i>
	 */
	int avfilter_open(AVFilterContext.ByReference filter_ctx[], AVFilter filter, String inst_name);
	/**
	 * Create a filter instance.<br>
	 * @param filter_ctx put here a pointer to the created filter context<br>
	 * on success, NULL on failure<br>
	 * @param filter    the filter to create an instance of<br>
	 * @param inst_name Name to give to the new instance. Can be NULL for none.<br>
	 * @return >= 0 in case of success, a negative error code otherwise<br>
	 * @deprecated use avfilter_graph_alloc_filter() instead<br>
	 * Original signature : <code>int avfilter_open(AVFilterContext**, AVFilter*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:285</i>
	 */
	int avfilter_open(AVFilterContext.ByReference filter_ctx[], AVFilter filter, Pointer inst_name);
	/**
	 * Initialize a filter.<br>
	 * @param filter the filter to initialize<br>
	 * @param args   A string of parameters to use when initializing the filter.<br>
	 *               The format and meaning of this string varies by filter.<br>
	 * @param opaque Any extra non-string data needed by the filter. The meaning<br>
	 *               of this parameter varies by filter.<br>
	 * @return       zero on success<br>
	 * Original signature : <code>int avfilter_init_filter(AVFilterContext*, const char*, void*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:296</i><br>
	 * @deprecated use the safer methods {@link #avfilter_init_filter(org.ffmpeg.avfilter6.AVFilterContext, String, Pointer)} and {@link #avfilter_init_filter(org.ffmpeg.avfilter6.AVFilterContext, Pointer, Pointer)} instead
	 */
	@Deprecated 
	int avfilter_init_filter(AVFilterContext filter, Pointer args, Pointer opaque);
	/**
	 * Initialize a filter.<br>
	 * @param filter the filter to initialize<br>
	 * @param args   A string of parameters to use when initializing the filter.<br>
	 *               The format and meaning of this string varies by filter.<br>
	 * @param opaque Any extra non-string data needed by the filter. The meaning<br>
	 *               of this parameter varies by filter.<br>
	 * @return       zero on success<br>
	 * Original signature : <code>int avfilter_init_filter(AVFilterContext*, const char*, void*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:296</i>
	 */
	int avfilter_init_filter(AVFilterContext filter, String args, Pointer opaque);
	/**
	 * Initialize a filter with the supplied parameters.<br>
	 * @param ctx  uninitialized filter context to initialize<br>
	 * @param args Options to initialize the filter with. This must be a<br>
	 *             ':'-separated list of options in the 'key=value' form.<br>
	 *             May be NULL if the options have been set directly using the<br>
	 *             AVOptions API or there are no options that need to be set.<br>
	 * @return 0 on success, a negative AVERROR on failure<br>
	 * Original signature : <code>int avfilter_init_str(AVFilterContext*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:307</i><br>
	 * @deprecated use the safer methods {@link #avfilter_init_str(org.ffmpeg.avfilter6.AVFilterContext, String)} and {@link #avfilter_init_str(org.ffmpeg.avfilter6.AVFilterContext, Pointer)} instead
	 */
	@Deprecated 
	int avfilter_init_str(AVFilterContext ctx, Pointer args);
	/**
	 * Initialize a filter with the supplied parameters.<br>
	 * @param ctx  uninitialized filter context to initialize<br>
	 * @param args Options to initialize the filter with. This must be a<br>
	 *             ':'-separated list of options in the 'key=value' form.<br>
	 *             May be NULL if the options have been set directly using the<br>
	 *             AVOptions API or there are no options that need to be set.<br>
	 * @return 0 on success, a negative AVERROR on failure<br>
	 * Original signature : <code>int avfilter_init_str(AVFilterContext*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:307</i>
	 */
	int avfilter_init_str(AVFilterContext ctx, String args);
	/**
	 * Initialize a filter with the supplied dictionary of options.<br>
	 * @param ctx     uninitialized filter context to initialize<br>
	 * @param options An AVDictionary filled with options for this filter. On<br>
	 *                return this parameter will be destroyed and replaced with<br>
	 *                a dict containing options that were not found. This dictionary<br>
	 *                must be freed by the caller.<br>
	 *                May be NULL, then this function is equivalent to<br>
	 *                avfilter_init_str() with the second parameter set to NULL.<br>
	 * @return 0 on success, a negative AVERROR on failure<br>
	 * @note This function and avfilter_init_str() do essentially the same thing,<br>
	 * the difference is in manner in which the options are passed. It is up to the<br>
	 * calling code to choose whichever is more preferable. The two functions also<br>
	 * behave differently when some of the provided options are not declared as<br>
	 * supported by the filter. In such a case, avfilter_init_str() will fail, but<br>
	 * this function will leave those extra options in the options AVDictionary and<br>
	 * continue as usual.<br>
	 * Original signature : <code>int avfilter_init_dict(AVFilterContext*, AVDictionary**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:327</i><br>
	 * @deprecated use the safer method {@link #avfilter_init_dict(org.ffmpeg.avfilter6.AVFilterContext, org.ffmpeg.avutil55.AVDictionary.ByReference[])} instead
	 */
	@Deprecated 
	int avfilter_init_dict(AVFilterContext ctx, PointerByReference options);
	/**
	 * Initialize a filter with the supplied dictionary of options.<br>
	 * @param ctx     uninitialized filter context to initialize<br>
	 * @param options An AVDictionary filled with options for this filter. On<br>
	 *                return this parameter will be destroyed and replaced with<br>
	 *                a dict containing options that were not found. This dictionary<br>
	 *                must be freed by the caller.<br>
	 *                May be NULL, then this function is equivalent to<br>
	 *                avfilter_init_str() with the second parameter set to NULL.<br>
	 * @return 0 on success, a negative AVERROR on failure<br>
	 * @note This function and avfilter_init_str() do essentially the same thing,<br>
	 * the difference is in manner in which the options are passed. It is up to the<br>
	 * calling code to choose whichever is more preferable. The two functions also<br>
	 * behave differently when some of the provided options are not declared as<br>
	 * supported by the filter. In such a case, avfilter_init_str() will fail, but<br>
	 * this function will leave those extra options in the options AVDictionary and<br>
	 * continue as usual.<br>
	 * Original signature : <code>int avfilter_init_dict(AVFilterContext*, AVDictionary**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:327</i>
	 */
	int avfilter_init_dict(AVFilterContext ctx, org.ffmpeg.avutil55.AVDictionary.ByReference options[]);
	/**
	 * Free a filter context. This will also remove the filter from its<br>
	 * filtergraph's list of filters.<br>
	 * @param filter the filter to free<br>
	 * Original signature : <code>void avfilter_free(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:334</i>
	 */
	void avfilter_free(AVFilterContext filter);
	/**
	 * Insert a filter in the middle of an existing link.<br>
	 * @param link the link into which the filter should be inserted<br>
	 * @param filt the filter to be inserted<br>
	 * @param filt_srcpad_idx the input pad on the filter to connect<br>
	 * @param filt_dstpad_idx the output pad on the filter to connect<br>
	 * @return     zero on success<br>
	 * Original signature : <code>int avfilter_insert_filter(AVFilterLink*, AVFilterContext*, unsigned, unsigned)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:344</i>
	 */
	int avfilter_insert_filter(AVFilterLink link, AVFilterContext filt, int filt_srcpad_idx, int filt_dstpad_idx);
	/**
	 * @return Pointer for AVFilterContext.<br>
	 * @see av_opt_find().<br>
	 * Original signature : <code>Pointer* avfilter_get_class()</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:350</i>
	 */
	Pointer avfilter_get_class();
	/**
	 * Allocate a filter graph.<br>
	 * @return the allocated filter graph on success or NULL.<br>
	 * Original signature : <code>AVFilterGraph* avfilter_graph_alloc()</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:400</i>
	 */
	AVFilterGraph avfilter_graph_alloc();
	/**
	 * Create a new filter instance in a filter graph.<br>
	 * @param graph graph in which the new filter will be used<br>
	 * @param filter the filter to create an instance of<br>
	 * @param name Name to give to the new instance (will be copied to<br>
	 *             AVFilterContext.name). This may be used by the caller to identify<br>
	 *             different filters, libavfilter itself assigns no semantics to<br>
	 *             this parameter. May be NULL.<br>
	 * @return the context of the newly created filter instance (note that it is<br>
	 *         also retrievable directly through AVFilterGraph.filters or with<br>
	 *         avfilter_graph_get_filter()) on success or NULL on failure.<br>
	 * Original signature : <code>AVFilterContext* avfilter_graph_alloc_filter(AVFilterGraph*, const AVFilter*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:414</i><br>
	 * @deprecated use the safer methods {@link #avfilter_graph_alloc_filter(org.ffmpeg.avfilter6.AVFilterGraph, org.ffmpeg.avfilter6.AVFilter, String)} and {@link #avfilter_graph_alloc_filter(org.ffmpeg.avfilter6.AVFilterGraph, org.ffmpeg.avfilter6.AVFilter, Pointer)} instead
	 */
	@Deprecated 
	AVFilterContext avfilter_graph_alloc_filter(AVFilterGraph graph, AVFilter filter, Pointer name);
	/**
	 * Create a new filter instance in a filter graph.<br>
	 * @param graph graph in which the new filter will be used<br>
	 * @param filter the filter to create an instance of<br>
	 * @param name Name to give to the new instance (will be copied to<br>
	 *             AVFilterContext.name). This may be used by the caller to identify<br>
	 *             different filters, libavfilter itself assigns no semantics to<br>
	 *             this parameter. May be NULL.<br>
	 * @return the context of the newly created filter instance (note that it is<br>
	 *         also retrievable directly through AVFilterGraph.filters or with<br>
	 *         avfilter_graph_get_filter()) on success or NULL on failure.<br>
	 * Original signature : <code>AVFilterContext* avfilter_graph_alloc_filter(AVFilterGraph*, const AVFilter*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:414</i>
	 */
	AVFilterContext avfilter_graph_alloc_filter(AVFilterGraph graph, AVFilter filter, String name);
	/**
	 * Get a filter instance identified by instance name from graph.<br>
	 * @param graph filter graph to search through.<br>
	 * @param name filter instance name (should be unique in the graph).<br>
	 * @return the pointer to the found filter instance or NULL if it<br>
	 * cannot be found.<br>
	 * Original signature : <code>AVFilterContext* avfilter_graph_get_filter(AVFilterGraph*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:423</i><br>
	 * @deprecated use the safer methods {@link #avfilter_graph_get_filter(org.ffmpeg.avfilter6.AVFilterGraph, String)} and {@link #avfilter_graph_get_filter(org.ffmpeg.avfilter6.AVFilterGraph, Pointer)} instead
	 */
	@Deprecated 
	AVFilterContext avfilter_graph_get_filter(AVFilterGraph graph, Pointer name);
	/**
	 * Get a filter instance identified by instance name from graph.<br>
	 * @param graph filter graph to search through.<br>
	 * @param name filter instance name (should be unique in the graph).<br>
	 * @return the pointer to the found filter instance or NULL if it<br>
	 * cannot be found.<br>
	 * Original signature : <code>AVFilterContext* avfilter_graph_get_filter(AVFilterGraph*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:423</i>
	 */
	AVFilterContext avfilter_graph_get_filter(AVFilterGraph graph, String name);
	/**
	 * Add an existing filter instance to a filter graph.<br>
	 * @param graphctx  the filter graph<br>
	 * @param filter the filter to be added<br>
	 * @deprecated use avfilter_graph_alloc_filter() to allocate a filter in a<br>
	 * filter graph<br>
	 * Original signature : <code>int avfilter_graph_add_filter(AVFilterGraph*, AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:432</i>
	 */
	int avfilter_graph_add_filter(AVFilterGraph graphctx, AVFilterContext filter);
	/**
	 * Create and add a filter instance into an existing graph.<br>
	 * The filter instance is created from the filter filt and inited<br>
	 * with the parameters args and opaque.<br>
	 * In case of success put in *filt_ctx the pointer to the created<br>
	 * filter instance, otherwise set *filt_ctx to NULL.<br>
	 * @param name the instance name to give to the created filter instance<br>
	 * @param graph_ctx the filter graph<br>
	 * @return a negative AVERROR error code in case of failure, a non<br>
	 * negative value otherwise<br>
	 * Original signature : <code>int avfilter_graph_create_filter(AVFilterContext**, const AVFilter*, const char*, const char*, void*, AVFilterGraph*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:445</i><br>
	 * @deprecated use the safer methods {@link #avfilter_graph_create_filter(org.ffmpeg.avfilter6.AVFilterContext.ByReference[], org.ffmpeg.avfilter6.AVFilter, String, String, Pointer, org.ffmpeg.avfilter6.AVFilterGraph)} and {@link #avfilter_graph_create_filter(org.ffmpeg.avfilter6.AVFilterContext.ByReference[], org.ffmpeg.avfilter6.AVFilter, Pointer, Pointer, Pointer, org.ffmpeg.avfilter6.AVFilterGraph)} instead
	 */
	@Deprecated 
	int avfilter_graph_create_filter(PointerByReference filt_ctx, AVFilter filt, Pointer name, Pointer args, Pointer opaque, AVFilterGraph graph_ctx);
	/**
	 * Create and add a filter instance into an existing graph.<br>
	 * The filter instance is created from the filter filt and inited<br>
	 * with the parameters args and opaque.<br>
	 * In case of success put in *filt_ctx the pointer to the created<br>
	 * filter instance, otherwise set *filt_ctx to NULL.<br>
	 * @param name the instance name to give to the created filter instance<br>
	 * @param graph_ctx the filter graph<br>
	 * @return a negative AVERROR error code in case of failure, a non<br>
	 * negative value otherwise<br>
	 * Original signature : <code>int avfilter_graph_create_filter(AVFilterContext**, const AVFilter*, const char*, const char*, void*, AVFilterGraph*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:445</i>
	 */
	int avfilter_graph_create_filter(AVFilterContext.ByReference filt_ctx[], AVFilter filt, String name, String args, Pointer opaque, AVFilterGraph graph_ctx);
	/**
	 * Create and add a filter instance into an existing graph.<br>
	 * The filter instance is created from the filter filt and inited<br>
	 * with the parameters args and opaque.<br>
	 * In case of success put in *filt_ctx the pointer to the created<br>
	 * filter instance, otherwise set *filt_ctx to NULL.<br>
	 * @param name the instance name to give to the created filter instance<br>
	 * @param graph_ctx the filter graph<br>
	 * @return a negative AVERROR error code in case of failure, a non<br>
	 * negative value otherwise<br>
	 * Original signature : <code>int avfilter_graph_create_filter(AVFilterContext**, const AVFilter*, const char*, const char*, void*, AVFilterGraph*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:445</i>
	 */
	int avfilter_graph_create_filter(AVFilterContext.ByReference filt_ctx[], AVFilter filt, Pointer name, Pointer args, Pointer opaque, AVFilterGraph graph_ctx);
	/**
	 * Enable or disable automatic format conversion inside the graph.<br>
	 * Note that format conversion can still happen inside explicitly inserted<br>
	 * scale and aresample filters.<br>
	 * @param flags  any of the AVFILTER_AUTO_CONVERT_* constants<br>
	 * Original signature : <code>void avfilter_graph_set_auto_convert(AVFilterGraph*, unsigned)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:453</i>
	 */
	void avfilter_graph_set_auto_convert(AVFilterGraph graph, int flags);
	/**
	 * Check validity and configure all the links and formats in the graph.<br>
	 * @param graphctx the filter graph<br>
	 * @param log_ctx context used for logging<br>
	 * @return >= 0 in case of success, a negative AVERROR code otherwise<br>
	 * Original signature : <code>int avfilter_graph_config(AVFilterGraph*, void*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:465</i>
	 */
	int avfilter_graph_config(AVFilterGraph graphctx, Pointer log_ctx);
	/**
	 * Free a graph, destroy its links, and set *graph to NULL.<br>
	 * If *graph is NULL, do nothing.<br>
	 * Original signature : <code>void avfilter_graph_free(AVFilterGraph**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:471</i><br>
	 * @deprecated use the safer method {@link #avfilter_graph_free(org.ffmpeg.avfilter6.AVFilterGraph.ByReference[])} instead
	 */
	@Deprecated 
	void avfilter_graph_free(PointerByReference graph);
	/**
	 * Free a graph, destroy its links, and set *graph to NULL.<br>
	 * If *graph is NULL, do nothing.<br>
	 * Original signature : <code>void avfilter_graph_free(AVFilterGraph**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:471</i>
	 */
	void avfilter_graph_free(AVFilterGraph.ByReference graph[]);
	/**
	 * Allocate a single AVFilterInOut entry.<br>
	 * Must be freed with avfilter_inout_free().<br>
	 * @return allocated AVFilterInOut on success, NULL on failure.<br>
	 * Original signature : <code>AVFilterInOut* avfilter_inout_alloc()</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:492</i>
	 */
	AVFilterInOut avfilter_inout_alloc();
	/**
	 * Free the supplied list of AVFilterInOut and set *inout to NULL.<br>
	 * If *inout is NULL, do nothing.<br>
	 * Original signature : <code>void avfilter_inout_free(AVFilterInOut**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:498</i><br>
	 * @deprecated use the safer method {@link #avfilter_inout_free(org.ffmpeg.avfilter6.AVFilterInOut.ByReference[])} instead
	 */
	@Deprecated 
	void avfilter_inout_free(PointerByReference inout);
	/**
	 * Free the supplied list of AVFilterInOut and set *inout to NULL.<br>
	 * If *inout is NULL, do nothing.<br>
	 * Original signature : <code>void avfilter_inout_free(AVFilterInOut**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:498</i>
	 */
	void avfilter_inout_free(AVFilterInOut.ByReference inout[]);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * @note The caller must provide the lists of inputs and outputs,<br>
	 * which therefore must be known before calling the function.<br>
	 * @note The inputs parameter describes inputs of the already existing<br>
	 * part of the graph; i.e. from the point of view of the newly created<br>
	 * part, they are outputs. Similarly the outputs parameter describes<br>
	 * outputs of the already existing filters, which are provided as<br>
	 * inputs to the parsed filters.<br>
	 * @param graph   the filter graph where to link the parsed graph context<br>
	 * @param filters string to be parsed<br>
	 * @param inputs  linked list to the inputs of the graph<br>
	 * @param outputs linked list to the outputs of the graph<br>
	 * @return zero on success, a negative AVERROR code on error<br>
	 * Original signature : <code>int avfilter_graph_parse(AVFilterGraph*, const char*, AVFilterInOut*, AVFilterInOut*, void*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:515</i><br>
	 * @deprecated use the safer methods {@link #avfilter_graph_parse(org.ffmpeg.avfilter6.AVFilterGraph, String, org.ffmpeg.avfilter6.AVFilterInOut, org.ffmpeg.avfilter6.AVFilterInOut, Pointer)} and {@link #avfilter_graph_parse(org.ffmpeg.avfilter6.AVFilterGraph, Pointer, org.ffmpeg.avfilter6.AVFilterInOut, org.ffmpeg.avfilter6.AVFilterInOut, Pointer)} instead
	 */
	@Deprecated 
	int avfilter_graph_parse(AVFilterGraph graph, Pointer filters, AVFilterInOut inputs, AVFilterInOut outputs, Pointer log_ctx);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * @note The caller must provide the lists of inputs and outputs,<br>
	 * which therefore must be known before calling the function.<br>
	 * @note The inputs parameter describes inputs of the already existing<br>
	 * part of the graph; i.e. from the point of view of the newly created<br>
	 * part, they are outputs. Similarly the outputs parameter describes<br>
	 * outputs of the already existing filters, which are provided as<br>
	 * inputs to the parsed filters.<br>
	 * @param graph   the filter graph where to link the parsed graph context<br>
	 * @param filters string to be parsed<br>
	 * @param inputs  linked list to the inputs of the graph<br>
	 * @param outputs linked list to the outputs of the graph<br>
	 * @return zero on success, a negative AVERROR code on error<br>
	 * Original signature : <code>int avfilter_graph_parse(AVFilterGraph*, const char*, AVFilterInOut*, AVFilterInOut*, void*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:515</i>
	 */
	int avfilter_graph_parse(AVFilterGraph graph, String filters, AVFilterInOut inputs, AVFilterInOut outputs, Pointer log_ctx);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * In the graph filters description, if the input label of the first<br>
	 * filter is not specified, "in" is assumed; if the output label of<br>
	 * the last filter is not specified, "out" is assumed.<br>
	 * @param graph   the filter graph where to link the parsed graph context<br>
	 * @param filters string to be parsed<br>
	 * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.<br>
	 *                If non-NULL, *inputs is updated to contain the list of open inputs<br>
	 *                after the parsing, should be freed with avfilter_inout_free().<br>
	 * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.<br>
	 *                If non-NULL, *outputs is updated to contain the list of open outputs<br>
	 *                after the parsing, should be freed with avfilter_inout_free().<br>
	 * @return non negative on success, a negative AVERROR code on error<br>
	 * Original signature : <code>int avfilter_graph_parse_ptr(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**, void*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:532</i><br>
	 * @deprecated use the safer methods {@link #avfilter_graph_parse_ptr(org.ffmpeg.avfilter6.AVFilterGraph, String, org.ffmpeg.avfilter6.AVFilterInOut.ByReference[], org.ffmpeg.avfilter6.AVFilterInOut.ByReference[], Pointer)} and {@link #avfilter_graph_parse_ptr(org.ffmpeg.avfilter6.AVFilterGraph, Pointer, org.ffmpeg.avfilter6.AVFilterInOut.ByReference[], org.ffmpeg.avfilter6.AVFilterInOut.ByReference[], Pointer)} instead
	 */
	@Deprecated 
	int avfilter_graph_parse_ptr(AVFilterGraph graph, Pointer filters, PointerByReference inputs, PointerByReference outputs, Pointer log_ctx);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * In the graph filters description, if the input label of the first<br>
	 * filter is not specified, "in" is assumed; if the output label of<br>
	 * the last filter is not specified, "out" is assumed.<br>
	 * @param graph   the filter graph where to link the parsed graph context<br>
	 * @param filters string to be parsed<br>
	 * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.<br>
	 *                If non-NULL, *inputs is updated to contain the list of open inputs<br>
	 *                after the parsing, should be freed with avfilter_inout_free().<br>
	 * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.<br>
	 *                If non-NULL, *outputs is updated to contain the list of open outputs<br>
	 *                after the parsing, should be freed with avfilter_inout_free().<br>
	 * @return non negative on success, a negative AVERROR code on error<br>
	 * Original signature : <code>int avfilter_graph_parse_ptr(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**, void*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:532</i>
	 */
	int avfilter_graph_parse_ptr(AVFilterGraph graph, String filters, AVFilterInOut.ByReference inputs[], AVFilterInOut.ByReference outputs[], Pointer log_ctx);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * In the graph filters description, if the input label of the first<br>
	 * filter is not specified, "in" is assumed; if the output label of<br>
	 * the last filter is not specified, "out" is assumed.<br>
	 * @param graph   the filter graph where to link the parsed graph context<br>
	 * @param filters string to be parsed<br>
	 * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.<br>
	 *                If non-NULL, *inputs is updated to contain the list of open inputs<br>
	 *                after the parsing, should be freed with avfilter_inout_free().<br>
	 * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.<br>
	 *                If non-NULL, *outputs is updated to contain the list of open outputs<br>
	 *                after the parsing, should be freed with avfilter_inout_free().<br>
	 * @return non negative on success, a negative AVERROR code on error<br>
	 * Original signature : <code>int avfilter_graph_parse_ptr(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**, void*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:532</i>
	 */
	int avfilter_graph_parse_ptr(AVFilterGraph graph, Pointer filters, AVFilterInOut.ByReference inputs[], AVFilterInOut.ByReference outputs[], Pointer log_ctx);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * @param[in]  graph   the filter graph where to link the parsed graph context<br>
	 * @param[in]  filters string to be parsed<br>
	 * @param[out] inputs  a linked list of all free (unlinked) inputs of the<br>
	 *                     parsed graph will be returned here. It is to be freed<br>
	 *                     by the caller using avfilter_inout_free().<br>
	 * @param[out] outputs a linked list of all free (unlinked) outputs of the<br>
	 *                     parsed graph will be returned here. It is to be freed by the<br>
	 *                     caller using avfilter_inout_free().<br>
	 * @return zero on success, a negative AVERROR code on error<br>
	 * @note This function returns the inputs and outputs that are left<br>
	 * unlinked after parsing the graph and the caller then deals with<br>
	 * them.<br>
	 * @note This function makes no reference whatsoever to already<br>
	 * existing parts of the graph and the inputs parameter will on return<br>
	 * contain inputs of the newly parsed part of the graph.  Analogously<br>
	 * the outputs parameter will contain outputs of the newly created<br>
	 * filters.<br>
	 * Original signature : <code>int avfilter_graph_parse2(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:554</i><br>
	 * @deprecated use the safer methods {@link #avfilter_graph_parse2(org.ffmpeg.avfilter6.AVFilterGraph, String, org.ffmpeg.avfilter6.AVFilterInOut.ByReference[], org.ffmpeg.avfilter6.AVFilterInOut.ByReference[])} and {@link #avfilter_graph_parse2(org.ffmpeg.avfilter6.AVFilterGraph, Pointer, org.ffmpeg.avfilter6.AVFilterInOut.ByReference[], org.ffmpeg.avfilter6.AVFilterInOut.ByReference[])} instead
	 */
	@Deprecated 
	int avfilter_graph_parse2(AVFilterGraph graph, Pointer filters, PointerByReference inputs, PointerByReference outputs);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * @param[in]  graph   the filter graph where to link the parsed graph context<br>
	 * @param[in]  filters string to be parsed<br>
	 * @param[out] inputs  a linked list of all free (unlinked) inputs of the<br>
	 *                     parsed graph will be returned here. It is to be freed<br>
	 *                     by the caller using avfilter_inout_free().<br>
	 * @param[out] outputs a linked list of all free (unlinked) outputs of the<br>
	 *                     parsed graph will be returned here. It is to be freed by the<br>
	 *                     caller using avfilter_inout_free().<br>
	 * @return zero on success, a negative AVERROR code on error<br>
	 * @note This function returns the inputs and outputs that are left<br>
	 * unlinked after parsing the graph and the caller then deals with<br>
	 * them.<br>
	 * @note This function makes no reference whatsoever to already<br>
	 * existing parts of the graph and the inputs parameter will on return<br>
	 * contain inputs of the newly parsed part of the graph.  Analogously<br>
	 * the outputs parameter will contain outputs of the newly created<br>
	 * filters.<br>
	 * Original signature : <code>int avfilter_graph_parse2(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:554</i>
	 */
	int avfilter_graph_parse2(AVFilterGraph graph, String filters, AVFilterInOut.ByReference inputs[], AVFilterInOut.ByReference outputs[]);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * @param[in]  graph   the filter graph where to link the parsed graph context<br>
	 * @param[in]  filters string to be parsed<br>
	 * @param[out] inputs  a linked list of all free (unlinked) inputs of the<br>
	 *                     parsed graph will be returned here. It is to be freed<br>
	 *                     by the caller using avfilter_inout_free().<br>
	 * @param[out] outputs a linked list of all free (unlinked) outputs of the<br>
	 *                     parsed graph will be returned here. It is to be freed by the<br>
	 *                     caller using avfilter_inout_free().<br>
	 * @return zero on success, a negative AVERROR code on error<br>
	 * @note This function returns the inputs and outputs that are left<br>
	 * unlinked after parsing the graph and the caller then deals with<br>
	 * them.<br>
	 * @note This function makes no reference whatsoever to already<br>
	 * existing parts of the graph and the inputs parameter will on return<br>
	 * contain inputs of the newly parsed part of the graph.  Analogously<br>
	 * the outputs parameter will contain outputs of the newly created<br>
	 * filters.<br>
	 * Original signature : <code>int avfilter_graph_parse2(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:554</i>
	 */
	int avfilter_graph_parse2(AVFilterGraph graph, Pointer filters, AVFilterInOut.ByReference inputs[], AVFilterInOut.ByReference outputs[]);
	/**
	 * Send a command to one or more filter instances.<br>
	 * @param graph  the filter graph<br>
	 * @param target the filter(s) to which the command should be sent<br>
	 *               "all" sends to all filters<br>
	 *               otherwise it can be a filter or filter instance name<br>
	 *               which will send the command to all matching filters.<br>
	 * @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only<br>
	 * @param arg    the argument for the command<br>
	 * @param res    a buffer with size res_size where the filter(s) can return a response.<br>
	 * @returns >=0 on success otherwise an error code.<br>
	 *              AVERROR(ENOSYS) on unsupported commands<br>
	 * Original signature : <code>int avfilter_graph_send_command(AVFilterGraph*, const char*, const char*, const char*, char*, int, int)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:569</i><br>
	 * @deprecated use the safer methods {@link #avfilter_graph_send_command(org.ffmpeg.avfilter6.AVFilterGraph, String, String, String, ByteBuffer, int, int)} and {@link #avfilter_graph_send_command(org.ffmpeg.avfilter6.AVFilterGraph, Pointer, Pointer, Pointer, Pointer, int, int)} instead
	 */
	@Deprecated 
	int avfilter_graph_send_command(AVFilterGraph graph, Pointer target, Pointer cmd, Pointer arg, Pointer res, int res_len, int flags);
	/**
	 * Send a command to one or more filter instances.<br>
	 * @param graph  the filter graph<br>
	 * @param target the filter(s) to which the command should be sent<br>
	 *               "all" sends to all filters<br>
	 *               otherwise it can be a filter or filter instance name<br>
	 *               which will send the command to all matching filters.<br>
	 * @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only<br>
	 * @param arg    the argument for the command<br>
	 * @param res    a buffer with size res_size where the filter(s) can return a response.<br>
	 * @returns >=0 on success otherwise an error code.<br>
	 *              AVERROR(ENOSYS) on unsupported commands<br>
	 * Original signature : <code>int avfilter_graph_send_command(AVFilterGraph*, const char*, const char*, const char*, char*, int, int)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:569</i>
	 */
	int avfilter_graph_send_command(AVFilterGraph graph, String target, String cmd, String arg, ByteBuffer res, int res_len, int flags);
	/**
	 * Queue a command for one or more filter instances.<br>
	 * @param graph  the filter graph<br>
	 * @param target the filter(s) to which the command should be sent<br>
	 *               "all" sends to all filters<br>
	 *               otherwise it can be a filter or filter instance name<br>
	 *               which will send the command to all matching filters.<br>
	 * @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only<br>
	 * @param arg    the argument for the command<br>
	 * @param ts     time at which the command should be sent to the filter<br>
	 * @note As this executes commands after this function returns, no return code<br>
	 *       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.<br>
	 * Original signature : <code>int avfilter_graph_queue_command(AVFilterGraph*, const char*, const char*, const char*, int, double)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:584</i><br>
	 * @deprecated use the safer methods {@link #avfilter_graph_queue_command(org.ffmpeg.avfilter6.AVFilterGraph, String, String, String, int, double)} and {@link #avfilter_graph_queue_command(org.ffmpeg.avfilter6.AVFilterGraph, Pointer, Pointer, Pointer, int, double)} instead
	 */
	@Deprecated 
	int avfilter_graph_queue_command(AVFilterGraph graph, Pointer target, Pointer cmd, Pointer arg, int flags, double ts);
	/**
	 * Queue a command for one or more filter instances.<br>
	 * @param graph  the filter graph<br>
	 * @param target the filter(s) to which the command should be sent<br>
	 *               "all" sends to all filters<br>
	 *               otherwise it can be a filter or filter instance name<br>
	 *               which will send the command to all matching filters.<br>
	 * @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only<br>
	 * @param arg    the argument for the command<br>
	 * @param ts     time at which the command should be sent to the filter<br>
	 * @note As this executes commands after this function returns, no return code<br>
	 *       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.<br>
	 * Original signature : <code>int avfilter_graph_queue_command(AVFilterGraph*, const char*, const char*, const char*, int, double)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:584</i>
	 */
	int avfilter_graph_queue_command(AVFilterGraph graph, String target, String cmd, String arg, int flags, double ts);
	/**
	 * Dump a graph into a human-readable string representation.<br>
	 * @param graph    the graph to dump<br>
	 * @param options  formatting options; currently ignored<br>
	 * @return  a string, or NULL in case of memory allocation failure;<br>
	 *          the string must be freed using av_free<br>
	 * Original signature : <code>char* avfilter_graph_dump(AVFilterGraph*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:593</i><br>
	 * @deprecated use the safer methods {@link #avfilter_graph_dump(org.ffmpeg.avfilter6.AVFilterGraph, String)} and {@link #avfilter_graph_dump(org.ffmpeg.avfilter6.AVFilterGraph, Pointer)} instead
	 */
	@Deprecated 
	Pointer avfilter_graph_dump(AVFilterGraph graph, Pointer options);
	/**
	 * Dump a graph into a human-readable string representation.<br>
	 * @param graph    the graph to dump<br>
	 * @param options  formatting options; currently ignored<br>
	 * @return  a string, or NULL in case of memory allocation failure;<br>
	 *          the string must be freed using av_free<br>
	 * Original signature : <code>char* avfilter_graph_dump(AVFilterGraph*, const char*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:593</i>
	 */
	Pointer avfilter_graph_dump(AVFilterGraph graph, String options);
	/**
	 * Request a frame on the oldest sink link.<br>
	 * If the request returns AVERROR_EOF, try the next.<br>
	 * Note that this function is not meant to be the sole scheduling mechanism<br>
	 * of a filtergraph, only a convenience function to help drain a filtergraph<br>
	 * in a balanced way under normal circumstances.<br>
	 * Also note that AVERROR_EOF does not mean that frames did not arrive on<br>
	 * some of the sinks during the process.<br>
	 * When there are multiple sink links, in case the requested link<br>
	 * returns an EOF, this may cause a filter to flush pending frames<br>
	 * which are sent to another sink link, although unrequested.<br>
	 * @return  the return value of ff_request_frame(),<br>
	 *          or AVERROR_EOF if all links returned AVERROR_EOF<br>
	 * Original signature : <code>int avfilter_graph_request_oldest(AVFilterGraph*)</code><br>
	 * <i>native declaration : libavfilter\avfilter.h:609</i>
	 */
	int avfilter_graph_request_oldest(AVFilterGraph graph);
	/**
	 * Get a frame with filtered data from sink and put it in frame.<br>
	 * @param ctx    pointer to a buffersink or abuffersink filter context.<br>
	 * @param frame  pointer to an allocated frame that will be filled with data.<br>
	 *               The data must be freed using av_frame_unref() / av_frame_free()<br>
	 * @param flags  a combination of AV_BUFFERSINK_FLAG_* flags<br>
	 * @return  >= 0 in for success, a negative AVERROR code for failure.<br>
	 * Original signature : <code>int av_buffersink_get_frame_flags(AVFilterContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:9</i>
	 */
	int av_buffersink_get_frame_flags(AVFilterContext ctx, AVFrame frame, int flags);
	/**
	 * Create an AVBufferSinkParams structure.<br>
	 * Must be freed with av_free().<br>
	 * Original signature : <code>AVBufferSinkParams* av_buffersink_params_alloc()</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:22</i>
	 */
	AVBufferSinkParams av_buffersink_params_alloc();
	/**
	 * Create an AVABufferSinkParams structure.<br>
	 * Must be freed with av_free().<br>
	 * Original signature : <code>AVABufferSinkParams* av_abuffersink_params_alloc()</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:43</i>
	 */
	AVABufferSinkParams av_abuffersink_params_alloc();
	/**
	 * Set the frame size for an audio buffer sink.<br>
	 * All calls to av_buffersink_get_buffer_ref will return a buffer with<br>
	 * exactly the specified number of samples, or AVERROR(EAGAIN) if there is<br>
	 * not enough. The last buffer at EOF will be padded with 0.<br>
	 * Original signature : <code>void av_buffersink_set_frame_size(AVFilterContext*, unsigned)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:51</i>
	 */
	void av_buffersink_set_frame_size(AVFilterContext ctx, int frame_size);
	/**
	 * @defgroup lavfi_buffersink_accessors Buffer sink accessors<br>
	 * Get the properties of the stream<br>
	 * @{<br>
	 * Original signature : <code>AVMediaType av_buffersink_get_type(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:58</i>
	 */
	int av_buffersink_get_type(AVFilterContext ctx);
	/**
	 * Original signature : <code>AVRational av_buffersink_get_time_base(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:60</i>
	 */
	ByValue av_buffersink_get_time_base(AVFilterContext ctx);
	/**
	 * Original signature : <code>int av_buffersink_get_format(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:62</i>
	 */
	int av_buffersink_get_format(AVFilterContext ctx);
	/**
	 * Original signature : <code>AVRational av_buffersink_get_frame_rate(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:64</i>
	 */
	ByValue av_buffersink_get_frame_rate(AVFilterContext ctx);
	/**
	 * Original signature : <code>int av_buffersink_get_w(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:66</i>
	 */
	int av_buffersink_get_w(AVFilterContext ctx);
	/**
	 * Original signature : <code>int av_buffersink_get_h(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:68</i>
	 */
	int av_buffersink_get_h(AVFilterContext ctx);
	/**
	 * Original signature : <code>AVRational av_buffersink_get_sample_aspect_ratio(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:70</i>
	 */
	ByValue av_buffersink_get_sample_aspect_ratio(AVFilterContext ctx);
	/**
	 * Original signature : <code>int av_buffersink_get_channels(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:72</i>
	 */
	int av_buffersink_get_channels(AVFilterContext ctx);
	/**
	 * Original signature : <code>uint64_t av_buffersink_get_channel_layout(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:74</i>
	 */
	long av_buffersink_get_channel_layout(AVFilterContext ctx);
	/**
	 * Original signature : <code>int av_buffersink_get_sample_rate(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:76</i>
	 */
	int av_buffersink_get_sample_rate(AVFilterContext ctx);
	/**
	 * Original signature : <code>AVBufferRef* av_buffersink_get_hw_frames_ctx(const AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:78</i>
	 */
	AVBufferRef av_buffersink_get_hw_frames_ctx(AVFilterContext ctx);
	/**
	 * Get a frame with filtered data from sink and put it in frame.<br>
	 * @param ctx pointer to a context of a buffersink or abuffersink AVFilter.<br>
	 * @param frame pointer to an allocated frame that will be filled with data.<br>
	 *              The data must be freed using av_frame_unref() / av_frame_free()<br>
	 * @return<br>
	 *         - >= 0 if a frame was successfully returned.<br>
	 *         - AVERROR(EAGAIN) if no frames are available at this point; more<br>
	 *           input frames must be added to the filtergraph to get more output.<br>
	 *         - AVERROR_EOF if there will be no more output frames on this sink.<br>
	 *         - A different negative AVERROR code in other failure cases.<br>
	 * Original signature : <code>int av_buffersink_get_frame(AVFilterContext*, AVFrame*)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:92</i>
	 */
	int av_buffersink_get_frame(AVFilterContext ctx, AVFrame frame);
	/**
	 * Same as av_buffersink_get_frame(), but with the ability to specify the number<br>
	 * of samples read. This function is less efficient than<br>
	 * av_buffersink_get_frame(), because it copies the data around.<br>
	 * @param ctx pointer to a context of the abuffersink AVFilter.<br>
	 * @param frame pointer to an allocated frame that will be filled with data.<br>
	 *              The data must be freed using av_frame_unref() / av_frame_free()<br>
	 *              frame will contain exactly nb_samples audio samples, except at<br>
	 *              the end of stream, when it can contain less than nb_samples.<br>
	 * @return The return codes have the same meaning as for<br>
	 *         av_buffersink_get_samples().<br>
	 * @warning do not mix this function with av_buffersink_get_frame(). Use only one or<br>
	 * the other with a single sink, not both.<br>
	 * Original signature : <code>int av_buffersink_get_samples(AVFilterContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter\buffersink.h:108</i>
	 */
	int av_buffersink_get_samples(AVFilterContext ctx, AVFrame frame, int nb_samples);
	/**
	 * Get the number of failed requests.<br>
	 * A failed request is when the request_frame method is called while no<br>
	 * frame is present in the buffer.<br>
	 * The number is reset when a frame is added.<br>
	 * Original signature : <code>int av_buffersrc_get_nb_failed_requests(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter\buffersrc.h:17</i>
	 */
	int av_buffersrc_get_nb_failed_requests(AVFilterContext buffer_src);
	/**
	 * Allocate a new AVBufferSrcParameters instance. It should be freed by the<br>
	 * caller with av_free().<br>
	 * Original signature : <code>AVBufferSrcParameters* av_buffersrc_parameters_alloc()</code><br>
	 * <i>native declaration : libavfilter\buffersrc.h:40</i>
	 */
	AVBufferSrcParameters av_buffersrc_parameters_alloc();
	/**
	 * Initialize the buffersrc or abuffersrc filter with the provided parameters.<br>
	 * This function may be called multiple times, the later calls override the<br>
	 * previous ones. Some of the parameters may also be set through AVOptions, then<br>
	 * whatever method is used last takes precedence.<br>
	 * @param ctx an instance of the buffersrc or abuffersrc filter<br>
	 * @param param the stream parameters. The frames later passed to this filter<br>
	 *              must conform to those parameters. All the allocated fields in<br>
	 *              param remain owned by the caller, libavfilter will make internal<br>
	 *              copies or references when necessary.<br>
	 * @return 0 on success, a negative AVERROR code on failure.<br>
	 * Original signature : <code>int av_buffersrc_parameters_set(AVFilterContext*, AVBufferSrcParameters*)</code><br>
	 * <i>native declaration : libavfilter\buffersrc.h:54</i>
	 */
	int av_buffersrc_parameters_set(AVFilterContext ctx, AVBufferSrcParameters param);
	/**
	 * Add a frame to the buffer source.<br>
	 * @param ctx   an instance of the buffersrc filter<br>
	 * @param frame frame to be added. If the frame is reference counted, this<br>
	 * function will make a new reference to it. Otherwise the frame data will be<br>
	 * copied.<br>
	 * @return 0 on success, a negative AVERROR on error<br>
	 * This function is equivalent to av_buffersrc_add_frame_flags() with the<br>
	 * AV_BUFFERSRC_FLAG_KEEP_REF flag.<br>
	 * Original signature : <code>int av_buffersrc_write_frame(AVFilterContext*, const AVFrame*)</code><br>
	 * <i>native declaration : libavfilter\buffersrc.h:66</i>
	 */
	int av_buffersrc_write_frame(AVFilterContext ctx, AVFrame frame);
	/**
	 * Add a frame to the buffer source.<br>
	 * @param ctx   an instance of the buffersrc filter<br>
	 * @param frame frame to be added. If the frame is reference counted, this<br>
	 * function will take ownership of the reference(s) and reset the frame.<br>
	 * Otherwise the frame data will be copied. If this function returns an error,<br>
	 * the input frame is not touched.<br>
	 * @return 0 on success, a negative AVERROR on error.<br>
	 * @note the difference between this function and av_buffersrc_write_frame() is<br>
	 * that av_buffersrc_write_frame() creates a new reference to the input frame,<br>
	 * while this function takes ownership of the reference passed to it.<br>
	 * This function is equivalent to av_buffersrc_add_frame_flags() without the<br>
	 * AV_BUFFERSRC_FLAG_KEEP_REF flag.<br>
	 * Original signature : <code>int av_buffersrc_add_frame(AVFilterContext*, AVFrame*)</code><br>
	 * <i>native declaration : libavfilter\buffersrc.h:82</i>
	 */
	int av_buffersrc_add_frame(AVFilterContext ctx, AVFrame frame);
	/**
	 * Add a frame to the buffer source.<br>
	 * By default, if the frame is reference-counted, this function will take<br>
	 * ownership of the reference(s) and reset the frame. This can be controlled<br>
	 * using the flags.<br>
	 * If this function returns an error, the input frame is not touched.<br>
	 * @param buffer_src  pointer to a buffer source context<br>
	 * @param frame       a frame, or NULL to mark EOF<br>
	 * @param flags       a combination of AV_BUFFERSRC_FLAG_*<br>
	 * @return            >= 0 in case of success, a negative AVERROR code<br>
	 *                    in case of failure<br>
	 * Original signature : <code>int av_buffersrc_add_frame_flags(AVFilterContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter\buffersrc.h:96</i>
	 */
	int av_buffersrc_add_frame_flags(AVFilterContext buffer_src, AVFrame frame, int flags);
}
