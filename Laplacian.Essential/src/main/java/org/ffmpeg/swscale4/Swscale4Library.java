package org.ffmpeg.swscale4;
import com.sun.jna.*;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;
/**
 * JNA Wrapper for library <b>swscale-4</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Swscale4Library extends Library {
	public static final String JNA_LIBRARY_NAME = "swscale-4";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(Swscale4Library.JNA_LIBRARY_NAME);
	public static final Swscale4Library INSTANCE = (Swscale4Library)Native.loadLibrary(Swscale4Library.JNA_LIBRARY_NAME, Swscale4Library.class);
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil\rational.h:30</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : libswscale\version.h</i> */
	public static final int LIBSWSCALE_VERSION_MAJOR = (int)4;
	/** <i>native declaration : libswscale\version.h</i> */
	public static final int LIBSWSCALE_VERSION_MINOR = (int)6;
	/** <i>native declaration : libswscale\version.h</i> */
	public static final int LIBSWSCALE_VERSION_MICRO = (int)100;
	/** <i>native declaration : libswscale\version.h</i> */
	public static final int LIBSWSCALE_VERSION_INT = (int)((4) << 16 | (6) << 8 | (100));
	/**
	 * define<br>
	 * Conversion Error : 4.6.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libswscale\version.h:0</i><br>
	 * 4.6.
	 */
	/** <i>native declaration : libswscale\version.h</i> */
	public static final int LIBSWSCALE_BUILD = (int)((4) << 16 | (6) << 8 | (100));
	/** <i>native declaration : libswscale\version.h</i> */
	public static final String LIBSWSCALE_IDENT = (String)"SwS4.6.100";
	/** <i>native declaration : libswscale\version.h</i> */
	public static final boolean FF_API_SWS_VECTOR = (boolean)(4 < 6);
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_FAST_BILINEAR = (int)1;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_BILINEAR = (int)2;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_BICUBIC = (int)4;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_X = (int)8;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_POINT = (int)0x10;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_AREA = (int)0x20;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_BICUBLIN = (int)0x40;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_GAUSS = (int)0x80;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_SINC = (int)0x100;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_LANCZOS = (int)0x200;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_SPLINE = (int)0x400;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_SRC_V_CHR_DROP_MASK = (int)0x30000;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_SRC_V_CHR_DROP_SHIFT = (int)16;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_PARAM_DEFAULT = (int)123456;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_PRINT_INFO = (int)0x1000;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_FULL_CHR_H_INT = (int)0x2000;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_FULL_CHR_H_INP = (int)0x4000;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_DIRECT_BGR = (int)0x8000;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_ACCURATE_RND = (int)0x40000;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_BITEXACT = (int)0x80000;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_ERROR_DIFFUSION = (int)0x800000;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final double SWS_MAX_REDUCE_CUTOFF = (double)0.002;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_CS_ITU709 = (int)1;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_CS_FCC = (int)4;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_CS_ITU601 = (int)5;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_CS_ITU624 = (int)5;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_CS_SMPTE170M = (int)5;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_CS_SMPTE240M = (int)7;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_CS_DEFAULT = (int)5;
	/** <i>native declaration : libswscale\swscale.h</i> */
	public static final int SWS_CS_BT2020 = (int)9;
	/**
	 * @defgroup libsws libswscale<br>
	 * Color conversion and scaling library.<br>
	 * @{<br>
	 * Return the LIBSWSCALE_VERSION_INT constant.<br>
	 * Original signature : <code>int swscale_version()</code><br>
	 * <i>native declaration : libswscale\swscale.h:7</i>
	 */
	int swscale_version();
	/**
	 * Return the libswscale build-time configuration.<br>
	 * Original signature : <code>char* swscale_configuration()</code><br>
	 * <i>native declaration : libswscale\swscale.h:12</i>
	 */
	String swscale_configuration();
	/**
	 * Return the libswscale license.<br>
	 * Original signature : <code>char* swscale_license()</code><br>
	 * <i>native declaration : libswscale\swscale.h:17</i>
	 */
	String swscale_license();
	/**
	 * Return a pointer to yuv<->rgb coefficients for the given colorspace<br>
	 * suitable for sws_setColorspaceDetails().<br>
	 * @param colorspace One of the SWS_CS_* macros. If invalid,<br>
	 * SWS_CS_DEFAULT is used.<br>
	 * Original signature : <code>int* sws_getCoefficients(int)</code><br>
	 * <i>native declaration : libswscale\swscale.h:25</i>
	 */
	IntByReference sws_getCoefficients(int colorspace);
	/**
	 * Return a positive value if pix_fmt is a supported input format, 0<br>
	 * otherwise.<br>
	 * Original signature : <code>int sws_isSupportedInput(AVPixelFormat)</code><br>
	 * <i>native declaration : libswscale\swscale.h:46</i>
	 */
	int sws_isSupportedInput(int pix_fmt);
	/**
	 * Return a positive value if pix_fmt is a supported output format, 0<br>
	 * otherwise.<br>
	 * Original signature : <code>int sws_isSupportedOutput(AVPixelFormat)</code><br>
	 * <i>native declaration : libswscale\swscale.h:52</i>
	 */
	int sws_isSupportedOutput(int pix_fmt);
	/**
	 * @param[in]  pix_fmt the pixel format<br>
	 * @return a positive value if an endianness conversion for pix_fmt is<br>
	 * supported, 0 otherwise.<br>
	 * Original signature : <code>int sws_isSupportedEndiannessConversion(AVPixelFormat)</code><br>
	 * <i>native declaration : libswscale\swscale.h:59</i>
	 */
	int sws_isSupportedEndiannessConversion(int pix_fmt);
	/**
	 * Allocate an empty SwsContext. This must be filled and passed to<br>
	 * sws_init_context(). For filling see AVOptions, options.c and<br>
	 * sws_setColorspaceDetails().<br>
	 * Original signature : <code>SwsContext* sws_alloc_context()</code><br>
	 * <i>native declaration : libswscale\swscale.h:66</i>
	 */
	SwsContext sws_alloc_context();
	/**
	 * Initialize the swscaler context sws_context.<br>
	 * @return zero or positive value on success, a negative value on<br>
	 * error<br>
	 * Original signature : <code>int sws_init_context(SwsContext*, SwsFilter*, SwsFilter*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:73</i>
	 */
	int sws_init_context(SwsContext sws_context, SwsFilter srcFilter, SwsFilter dstFilter);
	/**
	 * Free the swscaler context swsContext.<br>
	 * If swsContext is NULL, then does nothing.<br>
	 * Original signature : <code>void sws_freeContext(SwsContext*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:79</i>
	 */
	void sws_freeContext(SwsContext swsContext);
	/**
	 * Allocate and return an SwsContext. You need it to perform<br>
	 * scaling/conversion operations using sws_scale().<br>
	 * @param srcW the width of the source image<br>
	 * @param srcH the height of the source image<br>
	 * @param srcFormat the source image format<br>
	 * @param dstW the width of the destination image<br>
	 * @param dstH the height of the destination image<br>
	 * @param dstFormat the destination image format<br>
	 * @param flags specify which algorithm and options to use for rescaling<br>
	 * @param param extra parameters to tune the used scaler<br>
	 *              For SWS_BICUBIC param[0] and [1] tune the shape of the basis<br>
	 *              function, param[0] tunes f(1) and param[1] f\u9e93(1)<br>
	 *              For SWS_GAUSS param[0] tunes the exponent and thus cutoff<br>
	 *              frequency<br>
	 *              For SWS_LANCZOS param[0] tunes the width of the window function<br>
	 * @return a pointer to an allocated context, or NULL in case of error<br>
	 * @note this function is to be removed after a saner alternative is<br>
	 *       written<br>
	 * Original signature : <code>SwsContext* sws_getContext(int, int, AVPixelFormat, int, int, AVPixelFormat, int, SwsFilter*, SwsFilter*, const double*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:101</i><br>
	 * @deprecated use the safer methods {@link #sws_getContext(int, int, int, int, int, int, int, org.ffmpeg.swscale4.SwsFilter, org.ffmpeg.swscale4.SwsFilter, double[])} and {@link #sws_getContext(int, int, int, int, int, int, int, org.ffmpeg.swscale4.SwsFilter, org.ffmpeg.swscale4.SwsFilter, DoubleByReference)} instead
	 */
	@Deprecated 
	SwsContext sws_getContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, SwsFilter srcFilter, SwsFilter dstFilter, DoubleByReference param);
	/**
	 * Allocate and return an SwsContext. You need it to perform<br>
	 * scaling/conversion operations using sws_scale().<br>
	 * @param srcW the width of the source image<br>
	 * @param srcH the height of the source image<br>
	 * @param srcFormat the source image format<br>
	 * @param dstW the width of the destination image<br>
	 * @param dstH the height of the destination image<br>
	 * @param dstFormat the destination image format<br>
	 * @param flags specify which algorithm and options to use for rescaling<br>
	 * @param param extra parameters to tune the used scaler<br>
	 *              For SWS_BICUBIC param[0] and [1] tune the shape of the basis<br>
	 *              function, param[0] tunes f(1) and param[1] f\u9e93(1)<br>
	 *              For SWS_GAUSS param[0] tunes the exponent and thus cutoff<br>
	 *              frequency<br>
	 *              For SWS_LANCZOS param[0] tunes the width of the window function<br>
	 * @return a pointer to an allocated context, or NULL in case of error<br>
	 * @note this function is to be removed after a saner alternative is<br>
	 *       written<br>
	 * Original signature : <code>SwsContext* sws_getContext(int, int, AVPixelFormat, int, int, AVPixelFormat, int, SwsFilter*, SwsFilter*, const double*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:101</i>
	 */
	SwsContext sws_getContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, SwsFilter srcFilter, SwsFilter dstFilter, double param[]);
	/**
	 * Scale the image slice in srcSlice and put the resulting scaled<br>
	 * slice in the image in dst. A slice is a sequence of consecutive<br>
	 * rows in an image.<br>
	 * Slices have to be provided in sequential order, either in<br>
	 * top-bottom or bottom-top order. If slices are provided in<br>
	 * non-sequential order the behavior of the function is undefined.<br>
	 * @param c         the scaling context previously created with<br>
	 *                  sws_getContext()<br>
	 * @param srcSlice  the array containing the pointers to the planes of<br>
	 *                  the source slice<br>
	 * @param srcStride the array containing the strides for each plane of<br>
	 *                  the source image<br>
	 * @param srcSliceY the position in the source image of the slice to<br>
	 *                  process, that is the number (counted starting from<br>
	 *                  zero) in the image of the first row of the slice<br>
	 * @param srcSliceH the height of the source slice, that is the number<br>
	 *                  of rows in the slice<br>
	 * @param dst       the array containing the pointers to the planes of<br>
	 *                  the destination image<br>
	 * @param dstStride the array containing the strides for each plane of<br>
	 *                  the destination image<br>
	 * @return          the height of the output slice<br>
	 * Original signature : <code>int sws_scale(SwsContext*, const const uint8_t*[], const int[], int, int, const uint8_t*[], const int[])</code><br>
	 * <i>native declaration : libswscale\swscale.h:127</i><br>
	 * @deprecated use the safer methods {@link #sws_scale(org.ffmpeg.swscale4.Swscale4Library.SwsContext, byte[][], int[], int, int, byte[][], int[])} and {@link #sws_scale(org.ffmpeg.swscale4.Swscale4Library.SwsContext, PointerByReference, IntByReference, int, int, PointerByReference, IntByReference)} instead
	 */
	@Deprecated 
	int sws_scale(SwsContext c, PointerByReference srcSlice, IntByReference srcStride, int srcSliceY, int srcSliceH, PointerByReference dst, IntByReference dstStride);
	/**
	 * Scale the image slice in srcSlice and put the resulting scaled<br>
	 * slice in the image in dst. A slice is a sequence of consecutive<br>
	 * rows in an image.<br>
	 * Slices have to be provided in sequential order, either in<br>
	 * top-bottom or bottom-top order. If slices are provided in<br>
	 * non-sequential order the behavior of the function is undefined.<br>
	 * @param c         the scaling context previously created with<br>
	 *                  sws_getContext()<br>
	 * @param srcSlice  the array containing the pointers to the planes of<br>
	 *                  the source slice<br>
	 * @param srcStride the array containing the strides for each plane of<br>
	 *                  the source image<br>
	 * @param srcSliceY the position in the source image of the slice to<br>
	 *                  process, that is the number (counted starting from<br>
	 *                  zero) in the image of the first row of the slice<br>
	 * @param srcSliceH the height of the source slice, that is the number<br>
	 *                  of rows in the slice<br>
	 * @param dst       the array containing the pointers to the planes of<br>
	 *                  the destination image<br>
	 * @param dstStride the array containing the strides for each plane of<br>
	 *                  the destination image<br>
	 * @return          the height of the output slice<br>
	 * Original signature : <code>int sws_scale(SwsContext*, const const uint8_t*[], const int[], int, int, const uint8_t*[], const int[])</code><br>
	 * <i>native declaration : libswscale\swscale.h:127</i>
	 */
	int sws_scale(SwsContext c, byte[] srcSlice[], int srcStride[], int srcSliceY, int srcSliceH, byte[] dst[], int dstStride[]);
	/**
	 * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)<br>
	 * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)<br>
	 * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]<br>
	 * @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]<br>
	 * @param brightness 16.16 fixed point brightness correction<br>
	 * @param contrast 16.16 fixed point contrast correction<br>
	 * @param saturation 16.16 fixed point saturation correction<br>
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_setColorspaceDetails(SwsContext*, const int[4], int, const int[4], int, int, int, int)</code><br>
	 * <i>native declaration : libswscale\swscale.h:139</i><br>
	 * @deprecated use the safer methods {@link #sws_setColorspaceDetails(org.ffmpeg.swscale4.Swscale4Library.SwsContext, int[], int, int[], int, int, int, int)} and {@link #sws_setColorspaceDetails(org.ffmpeg.swscale4.Swscale4Library.SwsContext, IntByReference, int, IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int sws_setColorspaceDetails(SwsContext c, IntByReference inv_table, int srcRange, IntByReference table, int dstRange, int brightness, int contrast, int saturation);
	/**
	 * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)<br>
	 * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)<br>
	 * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]<br>
	 * @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]<br>
	 * @param brightness 16.16 fixed point brightness correction<br>
	 * @param contrast 16.16 fixed point contrast correction<br>
	 * @param saturation 16.16 fixed point saturation correction<br>
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_setColorspaceDetails(SwsContext*, const int[4], int, const int[4], int, int, int, int)</code><br>
	 * <i>native declaration : libswscale\swscale.h:139</i>
	 */
	int sws_setColorspaceDetails(SwsContext c, int inv_table[], int srcRange, int table[], int dstRange, int brightness, int contrast, int saturation);
	/**
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_getColorspaceDetails(SwsContext*, int**, int*, int**, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:144</i><br>
	 * @deprecated use the safer methods {@link #sws_getColorspaceDetails(org.ffmpeg.swscale4.Swscale4Library.SwsContext, PointerByReference, IntBuffer, PointerByReference, IntBuffer, IntBuffer, IntBuffer, IntBuffer)} and {@link #sws_getColorspaceDetails(org.ffmpeg.swscale4.Swscale4Library.SwsContext, PointerByReference, IntByReference, PointerByReference, IntByReference, IntByReference, IntByReference, IntByReference)} instead
	 */
	@Deprecated 
	int sws_getColorspaceDetails(SwsContext c, PointerByReference inv_table, IntByReference srcRange, PointerByReference table, IntByReference dstRange, IntByReference brightness, IntByReference contrast, IntByReference saturation);
	/**
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_getColorspaceDetails(SwsContext*, int**, int*, int**, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:144</i>
	 */
	int sws_getColorspaceDetails(SwsContext c, PointerByReference inv_table, IntBuffer srcRange, PointerByReference table, IntBuffer dstRange, IntBuffer brightness, IntBuffer contrast, IntBuffer saturation);
	/**
	 * Allocate and return an uninitialized vector with length coefficients.<br>
	 * Original signature : <code>SwsVector* sws_allocVec(int)</code><br>
	 * <i>native declaration : libswscale\swscale.h:149</i>
	 */
	SwsVector sws_allocVec(int length);
	/**
	 * Return a normalized Gaussian curve used to filter stuff<br>
	 * quality = 3 is high quality, lower is lower quality.<br>
	 * Original signature : <code>SwsVector* sws_getGaussianVec(double, double)</code><br>
	 * <i>native declaration : libswscale\swscale.h:155</i>
	 */
	SwsVector sws_getGaussianVec(double variance, double quality);
	/**
	 * Scale all the coefficients of a by the scalar value.<br>
	 * Original signature : <code>void sws_scaleVec(SwsVector*, double)</code><br>
	 * <i>native declaration : libswscale\swscale.h:160</i>
	 */
	void sws_scaleVec(SwsVector a, double scalar);
	/**
	 * Scale all the coefficients of a so that their sum equals height.<br>
	 * Original signature : <code>void sws_normalizeVec(SwsVector*, double)</code><br>
	 * <i>native declaration : libswscale\swscale.h:165</i>
	 */
	void sws_normalizeVec(SwsVector a, double height);
	/**
	 * Original signature : <code>SwsVector* sws_getConstVec(double, int)</code><br>
	 * <i>native declaration : libswscale\swscale.h:167</i>
	 */
	SwsVector sws_getConstVec(double c, int length);
	/**
	 * Original signature : <code>SwsVector* sws_getIdentityVec()</code><br>
	 * <i>native declaration : libswscale\swscale.h:169</i>
	 */
	SwsVector sws_getIdentityVec();
	/**
	 * Original signature : <code>void sws_convVec(SwsVector*, SwsVector*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:171</i>
	 */
	void sws_convVec(SwsVector a, SwsVector b);
	/**
	 * Original signature : <code>void sws_addVec(SwsVector*, SwsVector*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:173</i>
	 */
	void sws_addVec(SwsVector a, SwsVector b);
	/**
	 * Original signature : <code>void sws_subVec(SwsVector*, SwsVector*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:175</i>
	 */
	void sws_subVec(SwsVector a, SwsVector b);
	/**
	 * Original signature : <code>void sws_shiftVec(SwsVector*, int)</code><br>
	 * <i>native declaration : libswscale\swscale.h:177</i>
	 */
	void sws_shiftVec(SwsVector a, int shift);
	/**
	 * Original signature : <code>SwsVector* sws_cloneVec(SwsVector*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:179</i>
	 */
	SwsVector sws_cloneVec(SwsVector a);
	/**
	 * Original signature : <code>void sws_printVec2(SwsVector*, AVClass*, int)</code><br>
	 * <i>native declaration : libswscale\swscale.h:181</i>
	 */
	void sws_printVec2(SwsVector a, Pointer log_ctx, int log_level);
	/**
	 * Original signature : <code>void sws_freeVec(SwsVector*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:183</i>
	 */
	void sws_freeVec(SwsVector a);
	/**
	 * Original signature : <code>SwsFilter* sws_getDefaultFilter(float, float, float, float, float, float, int)</code><br>
	 * <i>native declaration : libswscale\swscale.h:185</i>
	 */
	SwsFilter sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose);
	/**
	 * Original signature : <code>void sws_freeFilter(SwsFilter*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:187</i>
	 */
	void sws_freeFilter(SwsFilter filter);
	/**
	 * Check if context can be reused, otherwise reallocate a new one.<br>
	 * If context is NULL, just calls sws_getContext() to get a new<br>
	 * context. Otherwise, checks if the parameters are the ones already<br>
	 * saved in context. If that is the case, returns the current<br>
	 * context. Otherwise, frees context and gets a new context with<br>
	 * the new parameters.<br>
	 * Be warned that srcFilter and dstFilter are not checked, they<br>
	 * are assumed to remain the same.<br>
	 * Original signature : <code>SwsContext* sws_getCachedContext(SwsContext*, int, int, AVPixelFormat, int, int, AVPixelFormat, int, SwsFilter*, SwsFilter*, const double*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:199</i><br>
	 * @deprecated use the safer methods {@link #sws_getCachedContext(org.ffmpeg.swscale4.Swscale4Library.SwsContext, int, int, int, int, int, int, int, org.ffmpeg.swscale4.SwsFilter, org.ffmpeg.swscale4.SwsFilter, double[])} and {@link #sws_getCachedContext(org.ffmpeg.swscale4.Swscale4Library.SwsContext, int, int, int, int, int, int, int, org.ffmpeg.swscale4.SwsFilter, org.ffmpeg.swscale4.SwsFilter, DoubleByReference)} instead
	 */
	@Deprecated 
	SwsContext sws_getCachedContext(SwsContext context, int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, SwsFilter srcFilter, SwsFilter dstFilter, DoubleByReference param);
	/**
	 * Check if context can be reused, otherwise reallocate a new one.<br>
	 * If context is NULL, just calls sws_getContext() to get a new<br>
	 * context. Otherwise, checks if the parameters are the ones already<br>
	 * saved in context. If that is the case, returns the current<br>
	 * context. Otherwise, frees context and gets a new context with<br>
	 * the new parameters.<br>
	 * Be warned that srcFilter and dstFilter are not checked, they<br>
	 * are assumed to remain the same.<br>
	 * Original signature : <code>SwsContext* sws_getCachedContext(SwsContext*, int, int, AVPixelFormat, int, int, AVPixelFormat, int, SwsFilter*, SwsFilter*, const double*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:199</i>
	 */
	SwsContext sws_getCachedContext(SwsContext context, int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, SwsFilter srcFilter, SwsFilter dstFilter, double param[]);
	/**
	 * Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.<br>
	 * The output frame will have the same packed format as the palette.<br>
	 * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked32(const uint8_t*, uint8_t*, int, const uint8_t*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:209</i><br>
	 * @deprecated use the safer methods {@link #sws_convertPalette8ToPacked32(byte[], ByteBuffer, int, byte[])} and {@link #sws_convertPalette8ToPacked32(Pointer, Pointer, int, Pointer)} instead
	 */
	@Deprecated 
	void sws_convertPalette8ToPacked32(Pointer src, Pointer dst, int num_pixels, Pointer palette);
	/**
	 * Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.<br>
	 * The output frame will have the same packed format as the palette.<br>
	 * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked32(const uint8_t*, uint8_t*, int, const uint8_t*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:209</i>
	 */
	void sws_convertPalette8ToPacked32(byte src[], ByteBuffer dst, int num_pixels, byte palette[]);
	/**
	 * Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.<br>
	 * With the palette format "ABCD", the destination frame ends up with the format "ABC".<br>
	 * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked24(const uint8_t*, uint8_t*, int, const uint8_t*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:219</i><br>
	 * @deprecated use the safer methods {@link #sws_convertPalette8ToPacked24(byte[], ByteBuffer, int, byte[])} and {@link #sws_convertPalette8ToPacked24(Pointer, Pointer, int, Pointer)} instead
	 */
	@Deprecated 
	void sws_convertPalette8ToPacked24(Pointer src, Pointer dst, int num_pixels, Pointer palette);
	/**
	 * Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.<br>
	 * With the palette format "ABCD", the destination frame ends up with the format "ABC".<br>
	 * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked24(const uint8_t*, uint8_t*, int, const uint8_t*)</code><br>
	 * <i>native declaration : libswscale\swscale.h:219</i>
	 */
	void sws_convertPalette8ToPacked24(byte src[], ByteBuffer dst, int num_pixels, byte palette[]);
	/**
	 * Get the AVClass for swsContext. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * @see av_opt_find().<br>
	 * Original signature : <code>AVClass* sws_get_class()</code><br>
	 * <i>native declaration : libswscale\swscale.h:226</i>
	 */
	Pointer sws_get_class();
	public static class SwsContext extends PointerType {
		public SwsContext(Pointer address) {
			super(address);
		}
		public SwsContext() {
			super();
		}
	};
}
